schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""action type"""
type Action {
  description: String!
  value: String!
}

"""
Boolean expression to filter rows from the table "action". All fields are combined with a logical 'AND'.
"""
input ActionBoolExp {
  _and: [ActionBoolExp!]
  _not: ActionBoolExp
  _or: [ActionBoolExp!]
  description: StringComparisonExp
  value: StringComparisonExp
}

enum ActionEnum {
  """BLOCK"""
  BLOCK

  """CALLOUT_INSPECTION"""
  CALLOUT_INSPECTION

  """CALLOUT_TERMINATING"""
  CALLOUT_TERMINATING

  """CALLOUT_UNKNOWN"""
  CALLOUT_UNKNOWN

  """PERMIT"""
  PERMIT
}

"""
Boolean expression to compare columns of type "ActionEnum". All fields are combined with logical 'AND'.
"""
input ActionEnumComparisonExp {
  _eq: ActionEnum
  _in: [ActionEnum!]
  _isNull: Boolean
  _neq: ActionEnum
  _nin: [ActionEnum!]
}

"""Ordering options when selecting data from "action"."""
input ActionOrderBy {
  description: OrderBy
  value: OrderBy
}

"""
select columns of table "action"
"""
enum ActionSelectColumn {
  """column name"""
  description

  """column name"""
  value
}

"""
Streaming cursor of the table "action"
"""
input ActionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ActionStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ActionStreamCursorValueInput {
  description: String
  value: String
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""device to pool bridge table """
type DevicePool {
  createdAt: timestamptz!
  createdBy: String!

  """An object relationship"""
  device: Devices!
  deviceId: uuid!
  id: uuid!

  """An object relationship"""
  pool: Pools!
  poolId: uuid!
  updatedAt: timestamptz!
  updatedBy: String!
}

"""
order by aggregate values of table "device_pool"
"""
input DevicePoolAggregateOrderBy {
  count: OrderBy
  max: DevicePoolMaxOrderBy
  min: DevicePoolMinOrderBy
}

"""
input type for inserting array relation for remote table "device_pool"
"""
input DevicePoolArrRelInsertInput {
  data: [DevicePoolInsertInput!]!

  """upsert condition"""
  onConflict: DevicePoolOnConflict
}

"""
Boolean expression to filter rows from the table "device_pool". All fields are combined with a logical 'AND'.
"""
input DevicePoolBoolExp {
  _and: [DevicePoolBoolExp!]
  _not: DevicePoolBoolExp
  _or: [DevicePoolBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: StringComparisonExp
  device: DevicesBoolExp
  deviceId: UuidComparisonExp
  id: UuidComparisonExp
  pool: PoolsBoolExp
  poolId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
  updatedBy: StringComparisonExp
}

"""
unique or primary key constraints on table "device_pool"
"""
enum DevicePoolConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  device_pool_pkey

  """
  unique or primary key constraint on columns "pool_id", "device_id"
  """
  device_pool_pool_id_device_id_key
}

"""
input type for inserting data into table "device_pool"
"""
input DevicePoolInsertInput {
  deviceId: uuid
  pool: PoolsObjRelInsertInput
  poolId: uuid
}

"""
order by max() on columns of table "device_pool"
"""
input DevicePoolMaxOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  deviceId: OrderBy
  id: OrderBy
  poolId: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
}

"""
order by min() on columns of table "device_pool"
"""
input DevicePoolMinOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  deviceId: OrderBy
  id: OrderBy
  poolId: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
}

"""
response of any mutation on the table "device_pool"
"""
type DevicePoolMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [DevicePool!]!
}

"""
on_conflict condition type for table "device_pool"
"""
input DevicePoolOnConflict {
  constraint: DevicePoolConstraint!
  updateColumns: [DevicePoolUpdateColumn!]! = []
  where: DevicePoolBoolExp
}

"""Ordering options when selecting data from "device_pool"."""
input DevicePoolOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  device: DevicesOrderBy
  deviceId: OrderBy
  id: OrderBy
  pool: PoolsOrderBy
  poolId: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
}

"""
select columns of table "device_pool"
"""
enum DevicePoolSelectColumn {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  deviceId

  """column name"""
  id

  """column name"""
  poolId

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

"""
Streaming cursor of the table "device_pool"
"""
input DevicePoolStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DevicePoolStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DevicePoolStreamCursorValueInput {
  createdAt: timestamptz
  createdBy: String
  deviceId: uuid
  id: uuid
  poolId: uuid
  updatedAt: timestamptz
  updatedBy: String
}

"""
placeholder for update columns of table "device_pool" (current role has no relevant permissions)
"""
enum DevicePoolUpdateColumn {
  """placeholder (do not use)"""
  _PLACEHOLDER
}

"""devices metadata"""
type Devices {
  annotations: hstore
  createdAt: timestamptz!
  createdBy: String!
  deletedAt: timestamptz
  description: String

  """An array relationship"""
  device_pools(
    """distinct select on columns"""
    distinctOn: [DevicePoolSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DevicePoolOrderBy!]

    """filter the rows returned"""
    where: DevicePoolBoolExp
  ): [DevicePool!]!
  displayName: String!
  id: uuid!
  ip: String!
  organization: OrganizationEnum!
  tags: [String!]
  updatedAt: timestamptz!
  updatedBy: String!
  version: String
}

"""
Boolean expression to filter rows from the table "devices". All fields are combined with a logical 'AND'.
"""
input DevicesBoolExp {
  _and: [DevicesBoolExp!]
  _not: DevicesBoolExp
  _or: [DevicesBoolExp!]
  annotations: HstoreComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: StringComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  device_pools: DevicePoolBoolExp
  displayName: StringComparisonExp
  id: UuidComparisonExp
  ip: StringComparisonExp
  organization: OrganizationEnumComparisonExp
  tags: StringArrayComparisonExp
  updatedAt: TimestamptzComparisonExp
  updatedBy: StringComparisonExp
  version: StringComparisonExp
}

"""
response of any mutation on the table "devices"
"""
type DevicesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Devices!]!
}

"""Ordering options when selecting data from "devices"."""
input DevicesOrderBy {
  annotations: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  device_poolsAggregate: DevicePoolAggregateOrderBy
  displayName: OrderBy
  id: OrderBy
  ip: OrderBy
  organization: OrderBy
  tags: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
  version: OrderBy
}

"""primary key columns input for table: devices"""
input DevicesPkColumnsInput {
  id: uuid!
}

"""
select columns of table "devices"
"""
enum DevicesSelectColumn {
  """column name"""
  annotations

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  deletedAt

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  organization

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  version
}

"""
input type for updating data in table "devices"
"""
input DevicesSetInput {
  annotations: hstore
  deletedAt: timestamptz
  description: String
  tags: [String!]
}

"""
Streaming cursor of the table "devices"
"""
input DevicesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DevicesStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DevicesStreamCursorValueInput {
  annotations: hstore
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  description: String
  displayName: String
  id: uuid
  ip: String
  organization: OrganizationEnum
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: String
  version: String
}

input DevicesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: DevicesSetInput

  """filter the rows which have to be updated"""
  where: DevicesBoolExp!
}

"""direction type"""
type Direction {
  description: String!
  value: String!
}

"""
aggregated selection of "direction"
"""
type DirectionAggregate {
  aggregate: DirectionAggregateFields
  nodes: [Direction!]!
}

"""
aggregate fields of "direction"
"""
type DirectionAggregateFields {
  count(columns: [DirectionSelectColumn!], distinct: Boolean): Int!
  max: DirectionMaxFields
  min: DirectionMinFields
}

"""
Boolean expression to filter rows from the table "direction". All fields are combined with a logical 'AND'.
"""
input DirectionBoolExp {
  _and: [DirectionBoolExp!]
  _not: DirectionBoolExp
  _or: [DirectionBoolExp!]
  description: StringComparisonExp
  value: StringComparisonExp
}

enum DirectionEnum {
  """EGRESS"""
  EGRESS

  """INGRESS"""
  INGRESS
}

"""
Boolean expression to compare columns of type "DirectionEnum". All fields are combined with logical 'AND'.
"""
input DirectionEnumComparisonExp {
  _eq: DirectionEnum
  _in: [DirectionEnum!]
  _isNull: Boolean
  _neq: DirectionEnum
  _nin: [DirectionEnum!]
}

"""aggregate max on columns"""
type DirectionMaxFields {
  description: String
  value: String
}

"""aggregate min on columns"""
type DirectionMinFields {
  description: String
  value: String
}

"""Ordering options when selecting data from "direction"."""
input DirectionOrderBy {
  description: OrderBy
  value: OrderBy
}

"""
select columns of table "direction"
"""
enum DirectionSelectColumn {
  """column name"""
  description

  """column name"""
  value
}

"""
Streaming cursor of the table "direction"
"""
input DirectionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DirectionStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DirectionStreamCursorValueInput {
  description: String
  value: String
}

"""
Boolean expression to compare columns of type "hstore". All fields are combined with logical 'AND'.
"""
input HstoreComparisonExp {
  _eq: hstore
  _gt: hstore
  _gte: hstore
  _in: [hstore!]
  _isNull: Boolean
  _lt: hstore
  _lte: hstore
  _neq: hstore
  _nin: [hstore!]
}

input ListUniversitiesInput {
  country: String
  name: String
}

type ListUniversitiesOutput {
  alpha_two_code: String
  country: String
  domains: [String!]!
  name: String
  stateprovince: String
  web_pages: [String!]!
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC

  """in ascending order, nulls first"""
  ASC_NULLS_FIRST

  """in ascending order, nulls last"""
  ASC_NULLS_LAST

  """in descending order, nulls first"""
  DESC

  """in descending order, nulls first"""
  DESC_NULLS_FIRST

  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

"""organizations are enums"""
type Organization {
  description: String!
  value: String!
}

"""
Boolean expression to filter rows from the table "organization". All fields are combined with a logical 'AND'.
"""
input OrganizationBoolExp {
  _and: [OrganizationBoolExp!]
  _not: OrganizationBoolExp
  _or: [OrganizationBoolExp!]
  description: StringComparisonExp
  value: StringComparisonExp
}

enum OrganizationEnum {
  """chinthagunta org"""
  CHINTHAGUNTA

  """example org"""
  EXAMPLE
}

"""
Boolean expression to compare columns of type "OrganizationEnum". All fields are combined with logical 'AND'.
"""
input OrganizationEnumComparisonExp {
  _eq: OrganizationEnum
  _in: [OrganizationEnum!]
  _isNull: Boolean
  _neq: OrganizationEnum
  _nin: [OrganizationEnum!]
}

"""Ordering options when selecting data from "organization"."""
input OrganizationOrderBy {
  description: OrderBy
  value: OrderBy
}

"""
select columns of table "organization"
"""
enum OrganizationSelectColumn {
  """column name"""
  description

  """column name"""
  value
}

"""
Streaming cursor of the table "organization"
"""
input OrganizationStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: OrganizationStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input OrganizationStreamCursorValueInput {
  description: String
  value: String
}

"""
policies is a joint table to connect a Subject polymorphically  and a Rule
"""
type Policies {
  active: Boolean!
  createdAt: timestamptz!
  createdBy: String!
  id: uuid!
  organization: OrganizationEnum!

  """An object relationship"""
  rule: Rules!
  ruleId: uuid!
  subjectDisplayName: String!
  subjectId: uuid!
  subjectSecondaryId: String!
  subjectType: SubjectTypeEnum!
  updatedAt: timestamptz!
  updatedBy: String!
  validFrom: timestamptz!
  validTo: timestamptz
  weight: smallint!
}

"""
Boolean expression to filter rows from the table "policies". All fields are combined with a logical 'AND'.
"""
input PoliciesBoolExp {
  _and: [PoliciesBoolExp!]
  _not: PoliciesBoolExp
  _or: [PoliciesBoolExp!]
  active: BooleanComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: StringComparisonExp
  id: UuidComparisonExp
  organization: OrganizationEnumComparisonExp
  rule: RulesBoolExp
  ruleId: UuidComparisonExp
  subjectDisplayName: StringComparisonExp
  subjectId: UuidComparisonExp
  subjectSecondaryId: StringComparisonExp
  subjectType: SubjectTypeEnumComparisonExp
  updatedAt: TimestamptzComparisonExp
  updatedBy: StringComparisonExp
  validFrom: TimestamptzComparisonExp
  validTo: TimestamptzComparisonExp
  weight: SmallintComparisonExp
}

"""
unique or primary key constraints on table "policies"
"""
enum PoliciesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  policies_pkey

  """
  unique or primary key constraint on columns "rule_id", "subject_id", "subject_type", "organization"
  """
  policies_subject_id_subject_type_rule_id_organization_unique
}

"""
input type for incrementing numeric columns in table "policies"
"""
input PoliciesIncInput {
  weight: smallint
}

"""
input type for inserting data into table "policies"
"""
input PoliciesInsertInput {
  active: Boolean
  rule: RulesObjRelInsertInput
  ruleId: uuid
  subjectDisplayName: String
  subjectId: uuid
  subjectSecondaryId: String
  subjectType: SubjectTypeEnum
  validFrom: timestamptz
  validTo: timestamptz
  weight: smallint
}

"""
response of any mutation on the table "policies"
"""
type PoliciesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Policies!]!
}

"""
on_conflict condition type for table "policies"
"""
input PoliciesOnConflict {
  constraint: PoliciesConstraint!
  updateColumns: [PoliciesUpdateColumn!]! = []
  where: PoliciesBoolExp
}

"""Ordering options when selecting data from "policies"."""
input PoliciesOrderBy {
  active: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  id: OrderBy
  organization: OrderBy
  rule: RulesOrderBy
  ruleId: OrderBy
  subjectDisplayName: OrderBy
  subjectId: OrderBy
  subjectSecondaryId: OrderBy
  subjectType: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
  validFrom: OrderBy
  validTo: OrderBy
  weight: OrderBy
}

"""primary key columns input for table: policies"""
input PoliciesPkColumnsInput {
  id: uuid!
}

"""
select columns of table "policies"
"""
enum PoliciesSelectColumn {
  """column name"""
  active

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  id

  """column name"""
  organization

  """column name"""
  ruleId

  """column name"""
  subjectDisplayName

  """column name"""
  subjectId

  """column name"""
  subjectSecondaryId

  """column name"""
  subjectType

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  validFrom

  """column name"""
  validTo

  """column name"""
  weight
}

"""
input type for updating data in table "policies"
"""
input PoliciesSetInput {
  active: Boolean
  deletedAt: timestamptz
  validFrom: timestamptz
  validTo: timestamptz
  weight: smallint
}

"""
Streaming cursor of the table "policies"
"""
input PoliciesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PoliciesStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PoliciesStreamCursorValueInput {
  active: Boolean
  createdAt: timestamptz
  createdBy: String
  id: uuid
  organization: OrganizationEnum
  ruleId: uuid
  subjectDisplayName: String
  subjectId: uuid
  subjectSecondaryId: String
  subjectType: SubjectTypeEnum
  updatedAt: timestamptz
  updatedBy: String
  validFrom: timestamptz
  validTo: timestamptz
  weight: smallint
}

"""
update columns of table "policies"
"""
enum PoliciesUpdateColumn {
  """column name"""
  active

  """column name"""
  deletedAt

  """column name"""
  validFrom

  """column name"""
  validTo

  """column name"""
  weight
}

input PoliciesUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PoliciesIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: PoliciesSetInput

  """filter the rows which have to be updated"""
  where: PoliciesBoolExp!
}

"""Device pools"""
type Pools {
  annotations: hstore
  createdAt: timestamptz!
  createdBy: String!
  deletedAt: timestamptz
  description: String
  displayName: String!
  id: uuid!
  organization: OrganizationEnum!

  """An array relationship"""
  pool_devices(
    """distinct select on columns"""
    distinctOn: [DevicePoolSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DevicePoolOrderBy!]

    """filter the rows returned"""
    where: DevicePoolBoolExp
  ): [DevicePool!]!
  tags: [String!]
  updatedAt: timestamptz!
  updatedBy: String!
}

"""
Boolean expression to filter rows from the table "pools". All fields are combined with a logical 'AND'.
"""
input PoolsBoolExp {
  _and: [PoolsBoolExp!]
  _not: PoolsBoolExp
  _or: [PoolsBoolExp!]
  annotations: HstoreComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: StringComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  displayName: StringComparisonExp
  id: UuidComparisonExp
  organization: OrganizationEnumComparisonExp
  pool_devices: DevicePoolBoolExp
  tags: StringArrayComparisonExp
  updatedAt: TimestamptzComparisonExp
  updatedBy: StringComparisonExp
}

"""
unique or primary key constraints on table "pools"
"""
enum PoolsConstraint {
  """
  unique or primary key constraint on columns "organization", "display_name"
  """
  pools_display_name_organization_unique

  """
  unique or primary key constraint on columns "id"
  """
  pools_pkey
}

"""
input type for inserting data into table "pools"
"""
input PoolsInsertInput {
  annotations: hstore
  description: String
  displayName: String
  pool_devices: DevicePoolArrRelInsertInput
  tags: [String!]
}

"""
response of any mutation on the table "pools"
"""
type PoolsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Pools!]!
}

"""
input type for inserting object relation for remote table "pools"
"""
input PoolsObjRelInsertInput {
  data: PoolsInsertInput!

  """upsert condition"""
  onConflict: PoolsOnConflict
}

"""
on_conflict condition type for table "pools"
"""
input PoolsOnConflict {
  constraint: PoolsConstraint!
  updateColumns: [PoolsUpdateColumn!]! = []
  where: PoolsBoolExp
}

"""Ordering options when selecting data from "pools"."""
input PoolsOrderBy {
  annotations: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  displayName: OrderBy
  id: OrderBy
  organization: OrderBy
  pool_devicesAggregate: DevicePoolAggregateOrderBy
  tags: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
}

"""primary key columns input for table: pools"""
input PoolsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "pools"
"""
enum PoolsSelectColumn {
  """column name"""
  annotations

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  deletedAt

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  organization

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

"""
input type for updating data in table "pools"
"""
input PoolsSetInput {
  annotations: hstore
  deletedAt: timestamptz
  description: String
  displayName: String
  tags: [String!]
}

"""
Streaming cursor of the table "pools"
"""
input PoolsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PoolsStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PoolsStreamCursorValueInput {
  annotations: hstore
  createdAt: timestamptz
  createdBy: String
  deletedAt: timestamptz
  description: String
  displayName: String
  id: uuid
  organization: OrganizationEnum
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: String
}

"""
update columns of table "pools"
"""
enum PoolsUpdateColumn {
  """column name"""
  annotations

  """column name"""
  deletedAt

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  tags
}

input PoolsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PoolsSetInput

  """filter the rows which have to be updated"""
  where: PoolsBoolExp!
}

"""network protocol enum"""
type Protocol {
  description: String!
  value: String!
}

"""
aggregated selection of "protocol"
"""
type ProtocolAggregate {
  aggregate: ProtocolAggregateFields
  nodes: [Protocol!]!
}

"""
aggregate fields of "protocol"
"""
type ProtocolAggregateFields {
  count(columns: [ProtocolSelectColumn!], distinct: Boolean): Int!
  max: ProtocolMaxFields
  min: ProtocolMinFields
}

"""
Boolean expression to filter rows from the table "protocol". All fields are combined with a logical 'AND'.
"""
input ProtocolBoolExp {
  _and: [ProtocolBoolExp!]
  _not: ProtocolBoolExp
  _or: [ProtocolBoolExp!]
  description: StringComparisonExp
  value: StringComparisonExp
}

enum ProtocolEnum {
  """Any"""
  ANY

  """ICMP"""
  ICMP

  """ICMPV6"""
  ICMPV6

  """IGMP"""
  IGMP

  """IP"""
  IP

  """IPV6"""
  IPV6

  """RM"""
  RM

  """TCP"""
  TCP

  """UDP"""
  UDP
}

"""
Boolean expression to compare columns of type "ProtocolEnum". All fields are combined with logical 'AND'.
"""
input ProtocolEnumComparisonExp {
  _eq: ProtocolEnum
  _in: [ProtocolEnum!]
  _isNull: Boolean
  _neq: ProtocolEnum
  _nin: [ProtocolEnum!]
}

"""aggregate max on columns"""
type ProtocolMaxFields {
  description: String
  value: String
}

"""aggregate min on columns"""
type ProtocolMinFields {
  description: String
  value: String
}

"""Ordering options when selecting data from "protocol"."""
input ProtocolOrderBy {
  description: OrderBy
  value: OrderBy
}

"""
select columns of table "protocol"
"""
enum ProtocolSelectColumn {
  """column name"""
  description

  """column name"""
  value
}

"""
Streaming cursor of the table "protocol"
"""
input ProtocolStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProtocolStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProtocolStreamCursorValueInput {
  description: String
  value: String
}

"""5-tuple firewalls rules"""
type Rules {
  action: ActionEnum!
  annotations: hstore
  appId: String
  createdAt: timestamptz!
  createdBy: String!
  description: String
  destination: String
  destinationPort: String
  direction: DirectionEnum!
  displayName: String!
  id: uuid!
  organization: OrganizationEnum!
  protocol: ProtocolEnum!
  shared: Boolean!
  source: String
  sourcePort: String
  tags: [String!]
  throttleRate: String
  updatedAt: timestamptz!
  updatedBy: String!
  weight: smallint!
}

"""
Boolean expression to filter rows from the table "rules". All fields are combined with a logical 'AND'.
"""
input RulesBoolExp {
  _and: [RulesBoolExp!]
  _not: RulesBoolExp
  _or: [RulesBoolExp!]
  action: ActionEnumComparisonExp
  annotations: HstoreComparisonExp
  appId: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: StringComparisonExp
  description: StringComparisonExp
  destination: StringComparisonExp
  destinationPort: StringComparisonExp
  direction: DirectionEnumComparisonExp
  displayName: StringComparisonExp
  id: UuidComparisonExp
  organization: OrganizationEnumComparisonExp
  protocol: ProtocolEnumComparisonExp
  shared: BooleanComparisonExp
  source: StringComparisonExp
  sourcePort: StringComparisonExp
  tags: StringArrayComparisonExp
  throttleRate: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  updatedBy: StringComparisonExp
  weight: SmallintComparisonExp
}

"""
unique or primary key constraints on table "rules"
"""
enum RulesConstraint {
  """
  unique or primary key constraint on columns "organization", "display_name"
  """
  rules_display_name_organization_unique

  """
  unique or primary key constraint on columns "id"
  """
  rules_pkey
}

"""
input type for incrementing numeric columns in table "rules"
"""
input RulesIncInput {
  weight: smallint
}

"""
input type for inserting data into table "rules"
"""
input RulesInsertInput {
  action: ActionEnum
  annotations: hstore
  appId: String
  description: String
  destination: String
  destinationPort: String
  direction: DirectionEnum
  displayName: String
  protocol: ProtocolEnum
  shared: Boolean
  source: String
  sourcePort: String
  tags: [String!]
  throttleRate: String
  weight: smallint
}

"""
response of any mutation on the table "rules"
"""
type RulesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Rules!]!
}

"""
input type for inserting object relation for remote table "rules"
"""
input RulesObjRelInsertInput {
  data: RulesInsertInput!

  """upsert condition"""
  onConflict: RulesOnConflict
}

"""
on_conflict condition type for table "rules"
"""
input RulesOnConflict {
  constraint: RulesConstraint!
  updateColumns: [RulesUpdateColumn!]! = []
  where: RulesBoolExp
}

"""Ordering options when selecting data from "rules"."""
input RulesOrderBy {
  action: OrderBy
  annotations: OrderBy
  appId: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  description: OrderBy
  destination: OrderBy
  destinationPort: OrderBy
  direction: OrderBy
  displayName: OrderBy
  id: OrderBy
  organization: OrderBy
  protocol: OrderBy
  shared: OrderBy
  source: OrderBy
  sourcePort: OrderBy
  tags: OrderBy
  throttleRate: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
  weight: OrderBy
}

"""primary key columns input for table: rules"""
input RulesPkColumnsInput {
  id: uuid!
}

"""
select columns of table "rules"
"""
enum RulesSelectColumn {
  """column name"""
  action

  """column name"""
  annotations

  """column name"""
  appId

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  description

  """column name"""
  destination

  """column name"""
  destinationPort

  """column name"""
  direction

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  organization

  """column name"""
  protocol

  """column name"""
  shared

  """column name"""
  source

  """column name"""
  sourcePort

  """column name"""
  tags

  """column name"""
  throttleRate

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  weight
}

"""
input type for updating data in table "rules"
"""
input RulesSetInput {
  action: ActionEnum
  annotations: hstore
  appId: String
  deletedAt: timestamptz
  description: String
  destination: String
  destinationPort: String
  direction: DirectionEnum
  displayName: String
  protocol: ProtocolEnum
  shared: Boolean
  source: String
  sourcePort: String
  tags: [String!]
  throttleRate: String
  weight: smallint
}

"""
Streaming cursor of the table "rules"
"""
input RulesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: RulesStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input RulesStreamCursorValueInput {
  action: ActionEnum
  annotations: hstore
  appId: String
  createdAt: timestamptz
  createdBy: String
  description: String
  destination: String
  destinationPort: String
  direction: DirectionEnum
  displayName: String
  id: uuid
  organization: OrganizationEnum
  protocol: ProtocolEnum
  shared: Boolean
  source: String
  sourcePort: String
  tags: [String!]
  throttleRate: String
  updatedAt: timestamptz
  updatedBy: String
  weight: smallint
}

"""
update columns of table "rules"
"""
enum RulesUpdateColumn {
  """column name"""
  action

  """column name"""
  annotations

  """column name"""
  appId

  """column name"""
  deletedAt

  """column name"""
  description

  """column name"""
  destination

  """column name"""
  destinationPort

  """column name"""
  direction

  """column name"""
  displayName

  """column name"""
  protocol

  """column name"""
  shared

  """column name"""
  source

  """column name"""
  sourcePort

  """column name"""
  tags

  """column name"""
  throttleRate

  """column name"""
  weight
}

input RulesUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: RulesIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: RulesSetInput

  """filter the rows which have to be updated"""
  where: RulesBoolExp!
}

input SearchRestroomsInput {
  city: String
  limit: Int
  offset: Int
  page: Int
}

type SearchRestroomsOutput {
  accessible: Boolean
  approved: Boolean
  changing_table: Boolean
  city: String
  comment: String
  country: String
  created_at: String
  directions: String
  downvote: Int
  edit_id: Int
  id: Int
  latitude: Float
  longitude: Float
  name: String
  state: String
  street: String
  unisex: Boolean
  updated_at: String
  upvote: Int
}

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input SmallintComparisonExp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _isNull: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringArrayComparisonExp {
  """is the array contained in the given array value"""
  _containedIn: [String!]

  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _isNull: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""Subject Type"""
type SubjectType {
  description: String!
  value: String!
}

"""
Boolean expression to filter rows from the table "subject_type". All fields are combined with a logical 'AND'.
"""
input SubjectTypeBoolExp {
  _and: [SubjectTypeBoolExp!]
  _not: SubjectTypeBoolExp
  _or: [SubjectTypeBoolExp!]
  description: StringComparisonExp
  value: StringComparisonExp
}

enum SubjectTypeEnum {
  """DEVICE"""
  DEVICE

  """DEVICE_POOL"""
  DEVICE_POOL

  """GROUP"""
  GROUP

  """SERVICE_ACCOUNT"""
  SERVICE_ACCOUNT

  """USER"""
  USER
}

"""
Boolean expression to compare columns of type "SubjectTypeEnum". All fields are combined with logical 'AND'.
"""
input SubjectTypeEnumComparisonExp {
  _eq: SubjectTypeEnum
  _in: [SubjectTypeEnum!]
  _isNull: Boolean
  _neq: SubjectTypeEnum
  _nin: [SubjectTypeEnum!]
}

"""Ordering options when selecting data from "subject_type"."""
input SubjectTypeOrderBy {
  description: OrderBy
  value: OrderBy
}

"""
select columns of table "subject_type"
"""
enum SubjectTypeSelectColumn {
  """column name"""
  description

  """column name"""
  value
}

"""
Streaming cursor of the table "subject_type"
"""
input SubjectTypeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: SubjectTypeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input SubjectTypeStreamCursorValueInput {
  description: String
  value: String
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

input devicesNotInPoolArgs {
  poolid: uuid
}

scalar hstore

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "device_pool"
  """
  deleteDevicePool(
    """filter the rows which have to be deleted"""
    where: DevicePoolBoolExp!
  ): DevicePoolMutationResponse

  """
  delete single row from the table: "device_pool"
  """
  deleteDevicePoolByPk(id: uuid!): DevicePool

  """
  delete data from the table: "pools"
  """
  deletePools(
    """filter the rows which have to be deleted"""
    where: PoolsBoolExp!
  ): PoolsMutationResponse

  """
  delete single row from the table: "pools"
  """
  deletePoolsByPk(id: uuid!): Pools

  """
  insert data into the table: "device_pool"
  """
  insertDevicePool(
    """the rows to be inserted"""
    objects: [DevicePoolInsertInput!]!

    """upsert condition"""
    onConflict: DevicePoolOnConflict
  ): DevicePoolMutationResponse

  """
  insert a single row into the table: "device_pool"
  """
  insertDevicePoolOne(
    """the row to be inserted"""
    object: DevicePoolInsertInput!

    """upsert condition"""
    onConflict: DevicePoolOnConflict
  ): DevicePool

  """
  insert data into the table: "policies"
  """
  insertPolicies(
    """the rows to be inserted"""
    objects: [PoliciesInsertInput!]!

    """upsert condition"""
    onConflict: PoliciesOnConflict
  ): PoliciesMutationResponse

  """
  insert a single row into the table: "policies"
  """
  insertPoliciesOne(
    """the row to be inserted"""
    object: PoliciesInsertInput!

    """upsert condition"""
    onConflict: PoliciesOnConflict
  ): Policies

  """
  insert data into the table: "pools"
  """
  insertPools(
    """the rows to be inserted"""
    objects: [PoolsInsertInput!]!

    """upsert condition"""
    onConflict: PoolsOnConflict
  ): PoolsMutationResponse

  """
  insert a single row into the table: "pools"
  """
  insertPoolsOne(
    """the row to be inserted"""
    object: PoolsInsertInput!

    """upsert condition"""
    onConflict: PoolsOnConflict
  ): Pools

  """
  insert data into the table: "rules"
  """
  insertRules(
    """the rows to be inserted"""
    objects: [RulesInsertInput!]!

    """upsert condition"""
    onConflict: RulesOnConflict
  ): RulesMutationResponse

  """
  insert a single row into the table: "rules"
  """
  insertRulesOne(
    """the row to be inserted"""
    object: RulesInsertInput!

    """upsert condition"""
    onConflict: RulesOnConflict
  ): Rules

  """
  update data of the table: "devices"
  """
  updateDevices(
    """sets the columns of the filtered rows to the given values"""
    _set: DevicesSetInput

    """filter the rows which have to be updated"""
    where: DevicesBoolExp!
  ): DevicesMutationResponse

  """
  update single row of the table: "devices"
  """
  updateDevicesByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: DevicesSetInput
    pkColumns: DevicesPkColumnsInput!
  ): Devices

  """
  update multiples rows of table: "devices"
  """
  updateDevicesMany(
    """updates to execute, in order"""
    updates: [DevicesUpdates!]!
  ): [DevicesMutationResponse]

  """
  update data of the table: "policies"
  """
  updatePolicies(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PoliciesIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PoliciesSetInput

    """filter the rows which have to be updated"""
    where: PoliciesBoolExp!
  ): PoliciesMutationResponse

  """
  update single row of the table: "policies"
  """
  updatePoliciesByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PoliciesIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PoliciesSetInput
    pkColumns: PoliciesPkColumnsInput!
  ): Policies

  """
  update multiples rows of table: "policies"
  """
  updatePoliciesMany(
    """updates to execute, in order"""
    updates: [PoliciesUpdates!]!
  ): [PoliciesMutationResponse]

  """
  update data of the table: "pools"
  """
  updatePools(
    """sets the columns of the filtered rows to the given values"""
    _set: PoolsSetInput

    """filter the rows which have to be updated"""
    where: PoolsBoolExp!
  ): PoolsMutationResponse

  """
  update single row of the table: "pools"
  """
  updatePoolsByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PoolsSetInput
    pkColumns: PoolsPkColumnsInput!
  ): Pools

  """
  update multiples rows of table: "pools"
  """
  updatePoolsMany(
    """updates to execute, in order"""
    updates: [PoolsUpdates!]!
  ): [PoolsMutationResponse]

  """
  update data of the table: "rules"
  """
  updateRules(
    """increments the numeric columns with given value of the filtered values"""
    _inc: RulesIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: RulesSetInput

    """filter the rows which have to be updated"""
    where: RulesBoolExp!
  ): RulesMutationResponse

  """
  update single row of the table: "rules"
  """
  updateRulesByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: RulesIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: RulesSetInput
    pkColumns: RulesPkColumnsInput!
  ): Rules

  """
  update multiples rows of table: "rules"
  """
  updateRulesMany(
    """updates to execute, in order"""
    updates: [RulesUpdates!]!
  ): [RulesMutationResponse]
}

type query_root {
  """Universities API"""
  ListUniversities(arg1: ListUniversitiesInput!): [ListUniversitiesOutput]

  """Restrooms API"""
  SearchRestrooms(arg1: SearchRestroomsInput!): [SearchRestroomsOutput]

  """
  fetch data from the table: "action"
  """
  action(
    """distinct select on columns"""
    distinctOn: [ActionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ActionOrderBy!]

    """filter the rows returned"""
    where: ActionBoolExp
  ): [Action!]!

  """fetch data from the table: "action" using primary key columns"""
  actionByPk(value: String!): Action

  """
  fetch data from the table: "device_pool"
  """
  devicePool(
    """distinct select on columns"""
    distinctOn: [DevicePoolSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DevicePoolOrderBy!]

    """filter the rows returned"""
    where: DevicePoolBoolExp
  ): [DevicePool!]!

  """fetch data from the table: "device_pool" using primary key columns"""
  devicePoolByPk(id: uuid!): DevicePool

  """
  fetch data from the table: "devices"
  """
  devices(
    """distinct select on columns"""
    distinctOn: [DevicesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DevicesOrderBy!]

    """filter the rows returned"""
    where: DevicesBoolExp
  ): [Devices!]!

  """fetch data from the table: "devices" using primary key columns"""
  devicesByPk(id: uuid!): Devices

  """
  execute function "devices_not_in_pool" which returns "devices"
  """
  devicesNotInPool(
    """
    input parameters for function "devicesNotInPool"
    """
    args: devicesNotInPoolArgs!

    """distinct select on columns"""
    distinctOn: [DevicesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DevicesOrderBy!]

    """filter the rows returned"""
    where: DevicesBoolExp
  ): [Devices!]!

  """
  fetch data from the table: "direction"
  """
  direction(
    """distinct select on columns"""
    distinctOn: [DirectionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DirectionOrderBy!]

    """filter the rows returned"""
    where: DirectionBoolExp
  ): [Direction!]!

  """
  fetch aggregated fields from the table: "direction"
  """
  directionAggregate(
    """distinct select on columns"""
    distinctOn: [DirectionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DirectionOrderBy!]

    """filter the rows returned"""
    where: DirectionBoolExp
  ): DirectionAggregate!

  """fetch data from the table: "direction" using primary key columns"""
  directionByPk(value: String!): Direction

  """
  fetch data from the table: "organization"
  """
  organization(
    """distinct select on columns"""
    distinctOn: [OrganizationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [OrganizationOrderBy!]

    """filter the rows returned"""
    where: OrganizationBoolExp
  ): [Organization!]!

  """fetch data from the table: "organization" using primary key columns"""
  organizationByPk(value: String!): Organization

  """
  fetch data from the table: "policies"
  """
  policies(
    """distinct select on columns"""
    distinctOn: [PoliciesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PoliciesOrderBy!]

    """filter the rows returned"""
    where: PoliciesBoolExp
  ): [Policies!]!

  """fetch data from the table: "policies" using primary key columns"""
  policiesByPk(id: uuid!): Policies

  """
  fetch data from the table: "pools"
  """
  pools(
    """distinct select on columns"""
    distinctOn: [PoolsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PoolsOrderBy!]

    """filter the rows returned"""
    where: PoolsBoolExp
  ): [Pools!]!

  """fetch data from the table: "pools" using primary key columns"""
  poolsByPk(id: uuid!): Pools

  """
  fetch data from the table: "protocol"
  """
  protocol(
    """distinct select on columns"""
    distinctOn: [ProtocolSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProtocolOrderBy!]

    """filter the rows returned"""
    where: ProtocolBoolExp
  ): [Protocol!]!

  """
  fetch aggregated fields from the table: "protocol"
  """
  protocolAggregate(
    """distinct select on columns"""
    distinctOn: [ProtocolSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProtocolOrderBy!]

    """filter the rows returned"""
    where: ProtocolBoolExp
  ): ProtocolAggregate!

  """fetch data from the table: "protocol" using primary key columns"""
  protocolByPk(value: String!): Protocol

  """
  fetch data from the table: "rules"
  """
  rules(
    """distinct select on columns"""
    distinctOn: [RulesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RulesOrderBy!]

    """filter the rows returned"""
    where: RulesBoolExp
  ): [Rules!]!

  """fetch data from the table: "rules" using primary key columns"""
  rulesByPk(id: uuid!): Rules

  """
  fetch data from the table: "subject_type"
  """
  subjectType(
    """distinct select on columns"""
    distinctOn: [SubjectTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SubjectTypeOrderBy!]

    """filter the rows returned"""
    where: SubjectTypeBoolExp
  ): [SubjectType!]!

  """fetch data from the table: "subject_type" using primary key columns"""
  subjectTypeByPk(value: String!): SubjectType
}

scalar smallint

type subscription_root {
  """
  fetch data from the table: "action"
  """
  action(
    """distinct select on columns"""
    distinctOn: [ActionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ActionOrderBy!]

    """filter the rows returned"""
    where: ActionBoolExp
  ): [Action!]!

  """fetch data from the table: "action" using primary key columns"""
  actionByPk(value: String!): Action

  """
  fetch data from the table in a streaming manner: "action"
  """
  actionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ActionStreamCursorInput]!

    """filter the rows returned"""
    where: ActionBoolExp
  ): [Action!]!

  """
  fetch data from the table: "device_pool"
  """
  devicePool(
    """distinct select on columns"""
    distinctOn: [DevicePoolSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DevicePoolOrderBy!]

    """filter the rows returned"""
    where: DevicePoolBoolExp
  ): [DevicePool!]!

  """fetch data from the table: "device_pool" using primary key columns"""
  devicePoolByPk(id: uuid!): DevicePool

  """
  fetch data from the table in a streaming manner: "device_pool"
  """
  devicePoolStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [DevicePoolStreamCursorInput]!

    """filter the rows returned"""
    where: DevicePoolBoolExp
  ): [DevicePool!]!

  """
  fetch data from the table: "devices"
  """
  devices(
    """distinct select on columns"""
    distinctOn: [DevicesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DevicesOrderBy!]

    """filter the rows returned"""
    where: DevicesBoolExp
  ): [Devices!]!

  """fetch data from the table: "devices" using primary key columns"""
  devicesByPk(id: uuid!): Devices

  """
  execute function "devices_not_in_pool" which returns "devices"
  """
  devicesNotInPool(
    """
    input parameters for function "devicesNotInPool"
    """
    args: devicesNotInPoolArgs!

    """distinct select on columns"""
    distinctOn: [DevicesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DevicesOrderBy!]

    """filter the rows returned"""
    where: DevicesBoolExp
  ): [Devices!]!

  """
  fetch data from the table in a streaming manner: "devices"
  """
  devicesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [DevicesStreamCursorInput]!

    """filter the rows returned"""
    where: DevicesBoolExp
  ): [Devices!]!

  """
  fetch data from the table: "direction"
  """
  direction(
    """distinct select on columns"""
    distinctOn: [DirectionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DirectionOrderBy!]

    """filter the rows returned"""
    where: DirectionBoolExp
  ): [Direction!]!

  """
  fetch aggregated fields from the table: "direction"
  """
  directionAggregate(
    """distinct select on columns"""
    distinctOn: [DirectionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DirectionOrderBy!]

    """filter the rows returned"""
    where: DirectionBoolExp
  ): DirectionAggregate!

  """fetch data from the table: "direction" using primary key columns"""
  directionByPk(value: String!): Direction

  """
  fetch data from the table in a streaming manner: "direction"
  """
  directionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [DirectionStreamCursorInput]!

    """filter the rows returned"""
    where: DirectionBoolExp
  ): [Direction!]!

  """
  fetch data from the table: "organization"
  """
  organization(
    """distinct select on columns"""
    distinctOn: [OrganizationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [OrganizationOrderBy!]

    """filter the rows returned"""
    where: OrganizationBoolExp
  ): [Organization!]!

  """fetch data from the table: "organization" using primary key columns"""
  organizationByPk(value: String!): Organization

  """
  fetch data from the table in a streaming manner: "organization"
  """
  organizationStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [OrganizationStreamCursorInput]!

    """filter the rows returned"""
    where: OrganizationBoolExp
  ): [Organization!]!

  """
  fetch data from the table: "policies"
  """
  policies(
    """distinct select on columns"""
    distinctOn: [PoliciesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PoliciesOrderBy!]

    """filter the rows returned"""
    where: PoliciesBoolExp
  ): [Policies!]!

  """fetch data from the table: "policies" using primary key columns"""
  policiesByPk(id: uuid!): Policies

  """
  fetch data from the table in a streaming manner: "policies"
  """
  policiesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PoliciesStreamCursorInput]!

    """filter the rows returned"""
    where: PoliciesBoolExp
  ): [Policies!]!

  """
  fetch data from the table: "pools"
  """
  pools(
    """distinct select on columns"""
    distinctOn: [PoolsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PoolsOrderBy!]

    """filter the rows returned"""
    where: PoolsBoolExp
  ): [Pools!]!

  """fetch data from the table: "pools" using primary key columns"""
  poolsByPk(id: uuid!): Pools

  """
  fetch data from the table in a streaming manner: "pools"
  """
  poolsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PoolsStreamCursorInput]!

    """filter the rows returned"""
    where: PoolsBoolExp
  ): [Pools!]!

  """
  fetch data from the table: "protocol"
  """
  protocol(
    """distinct select on columns"""
    distinctOn: [ProtocolSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProtocolOrderBy!]

    """filter the rows returned"""
    where: ProtocolBoolExp
  ): [Protocol!]!

  """
  fetch aggregated fields from the table: "protocol"
  """
  protocolAggregate(
    """distinct select on columns"""
    distinctOn: [ProtocolSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProtocolOrderBy!]

    """filter the rows returned"""
    where: ProtocolBoolExp
  ): ProtocolAggregate!

  """fetch data from the table: "protocol" using primary key columns"""
  protocolByPk(value: String!): Protocol

  """
  fetch data from the table in a streaming manner: "protocol"
  """
  protocolStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProtocolStreamCursorInput]!

    """filter the rows returned"""
    where: ProtocolBoolExp
  ): [Protocol!]!

  """
  fetch data from the table: "rules"
  """
  rules(
    """distinct select on columns"""
    distinctOn: [RulesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RulesOrderBy!]

    """filter the rows returned"""
    where: RulesBoolExp
  ): [Rules!]!

  """fetch data from the table: "rules" using primary key columns"""
  rulesByPk(id: uuid!): Rules

  """
  fetch data from the table in a streaming manner: "rules"
  """
  rulesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [RulesStreamCursorInput]!

    """filter the rows returned"""
    where: RulesBoolExp
  ): [Rules!]!

  """
  fetch data from the table: "subject_type"
  """
  subjectType(
    """distinct select on columns"""
    distinctOn: [SubjectTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SubjectTypeOrderBy!]

    """filter the rows returned"""
    where: SubjectTypeBoolExp
  ): [SubjectType!]!

  """fetch data from the table: "subject_type" using primary key columns"""
  subjectTypeByPk(value: String!): SubjectType

  """
  fetch data from the table in a streaming manner: "subject_type"
  """
  subjectTypeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [SubjectTypeStreamCursorInput]!

    """filter the rows returned"""
    where: SubjectTypeBoolExp
  ): [SubjectType!]!
}

scalar timestamptz

scalar uuid
