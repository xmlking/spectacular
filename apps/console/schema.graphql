schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input ListUniversitiesInput {
  country: String
  name: String
}

type ListUniversitiesOutput {
  alpha_two_code: String
  country: String
  domains: [String!]!
  name: String
  stateprovince: String
  web_pages: [String!]!
}

input SearchRestroomsInput {
  city: String
  limit: Int
  offset: Int
  page: Int
}

type SearchRestroomsOutput {
  accessible: Boolean
  approved: Boolean
  changing_table: Boolean
  city: String
  comment: String
  country: String
  created_at: String
  directions: String
  downvote: Int
  edit_id: Int
  id: Int
  latitude: Float
  longitude: Float
  name: String
  state: String
  street: String
  unisex: Boolean
  updated_at: String
  upvote: Int
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [String!]

  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _is_null: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""policy action enum"""
type action {
  description: String!
  value: String!
}

"""
aggregated selection of "action"
"""
type action_aggregate {
  aggregate: action_aggregate_fields
  nodes: [action!]!
}

"""
aggregate fields of "action"
"""
type action_aggregate_fields {
  count(columns: [action_select_column!], distinct: Boolean): Int!
  max: action_max_fields
  min: action_min_fields
}

"""
Boolean expression to filter rows from the table "action". All fields are combined with a logical 'AND'.
"""
input action_bool_exp {
  _and: [action_bool_exp!]
  _not: action_bool_exp
  _or: [action_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "action"
"""
enum action_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  action_pkey
}

enum action_enum {
  """BLOCK"""
  block

  """CALLOUT_INSPECTION"""
  callout_inspection

  """CALLOUT_TERMINATING"""
  callout_terminating

  """CALLOUT_UNKNOWN"""
  callout_unknown

  """PERMIT"""
  permit
}

"""
Boolean expression to compare columns of type "action_enum". All fields are combined with logical 'AND'.
"""
input action_enum_comparison_exp {
  _eq: action_enum
  _in: [action_enum!]
  _is_null: Boolean
  _neq: action_enum
  _nin: [action_enum!]
}

"""
input type for inserting data into table "action"
"""
input action_insert_input {
  description: String
  value: String
}

"""aggregate max on columns"""
type action_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type action_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "action"
"""
type action_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [action!]!
}

"""
on_conflict condition type for table "action"
"""
input action_on_conflict {
  constraint: action_constraint!
  update_columns: [action_update_column!]! = []
  where: action_bool_exp
}

"""Ordering options when selecting data from "action"."""
input action_order_by {
  description: order_by
  value: order_by
}

"""primary key columns input for table: action"""
input action_pk_columns_input {
  value: String!
}

"""
select columns of table "action"
"""
enum action_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "action"
"""
input action_set_input {
  description: String
  value: String
}

"""
Streaming cursor of the table "action"
"""
input action_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: action_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input action_stream_cursor_value_input {
  description: String
  value: String
}

"""
update columns of table "action"
"""
enum action_update_column {
  """column name"""
  description

  """column name"""
  value
}

input action_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: action_set_input

  """filter the rows which have to be updated"""
  where: action_bool_exp!
}

"""
Oauth requests, inserted before redirecting to the provider's site. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authProviderRequests {
  id: uuid!
  options(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "auth.provider_requests"
"""
type authProviderRequests_aggregate {
  aggregate: authProviderRequests_aggregate_fields
  nodes: [authProviderRequests!]!
}

"""
aggregate fields of "auth.provider_requests"
"""
type authProviderRequests_aggregate_fields {
  count(columns: [authProviderRequests_select_column!], distinct: Boolean): Int!
  max: authProviderRequests_max_fields
  min: authProviderRequests_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input authProviderRequests_append_input {
  options: jsonb
}

"""
Boolean expression to filter rows from the table "auth.provider_requests". All fields are combined with a logical 'AND'.
"""
input authProviderRequests_bool_exp {
  _and: [authProviderRequests_bool_exp!]
  _not: authProviderRequests_bool_exp
  _or: [authProviderRequests_bool_exp!]
  id: uuid_comparison_exp
  options: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "auth.provider_requests"
"""
enum authProviderRequests_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  provider_requests_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input authProviderRequests_delete_at_path_input {
  options: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input authProviderRequests_delete_elem_input {
  options: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input authProviderRequests_delete_key_input {
  options: String
}

"""
input type for inserting data into table "auth.provider_requests"
"""
input authProviderRequests_insert_input {
  id: uuid
  options: jsonb
}

"""aggregate max on columns"""
type authProviderRequests_max_fields {
  id: uuid
}

"""aggregate min on columns"""
type authProviderRequests_min_fields {
  id: uuid
}

"""
response of any mutation on the table "auth.provider_requests"
"""
type authProviderRequests_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authProviderRequests!]!
}

"""
on_conflict condition type for table "auth.provider_requests"
"""
input authProviderRequests_on_conflict {
  constraint: authProviderRequests_constraint!
  update_columns: [authProviderRequests_update_column!]! = []
  where: authProviderRequests_bool_exp
}

"""Ordering options when selecting data from "auth.provider_requests"."""
input authProviderRequests_order_by {
  id: order_by
  options: order_by
}

"""primary key columns input for table: auth.provider_requests"""
input authProviderRequests_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input authProviderRequests_prepend_input {
  options: jsonb
}

"""
select columns of table "auth.provider_requests"
"""
enum authProviderRequests_select_column {
  """column name"""
  id

  """column name"""
  options
}

"""
input type for updating data in table "auth.provider_requests"
"""
input authProviderRequests_set_input {
  id: uuid
  options: jsonb
}

"""
Streaming cursor of the table "authProviderRequests"
"""
input authProviderRequests_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authProviderRequests_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authProviderRequests_stream_cursor_value_input {
  id: uuid
  options: jsonb
}

"""
update columns of table "auth.provider_requests"
"""
enum authProviderRequests_update_column {
  """column name"""
  id

  """column name"""
  options
}

input authProviderRequests_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: authProviderRequests_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: authProviderRequests_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: authProviderRequests_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: authProviderRequests_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: authProviderRequests_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: authProviderRequests_set_input

  """filter the rows which have to be updated"""
  where: authProviderRequests_bool_exp!
}

"""
List of available Oauth providers. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authProviders {
  id: String!

  """An array relationship"""
  userProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """An aggregate relationship"""
  userProviders_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!
}

"""
aggregated selection of "auth.providers"
"""
type authProviders_aggregate {
  aggregate: authProviders_aggregate_fields
  nodes: [authProviders!]!
}

"""
aggregate fields of "auth.providers"
"""
type authProviders_aggregate_fields {
  count(columns: [authProviders_select_column!], distinct: Boolean): Int!
  max: authProviders_max_fields
  min: authProviders_min_fields
}

"""
Boolean expression to filter rows from the table "auth.providers". All fields are combined with a logical 'AND'.
"""
input authProviders_bool_exp {
  _and: [authProviders_bool_exp!]
  _not: authProviders_bool_exp
  _or: [authProviders_bool_exp!]
  id: String_comparison_exp
  userProviders: authUserProviders_bool_exp
  userProviders_aggregate: authUserProviders_aggregate_bool_exp
}

"""
unique or primary key constraints on table "auth.providers"
"""
enum authProviders_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  providers_pkey
}

"""
input type for inserting data into table "auth.providers"
"""
input authProviders_insert_input {
  id: String
  userProviders: authUserProviders_arr_rel_insert_input
}

"""aggregate max on columns"""
type authProviders_max_fields {
  id: String
}

"""aggregate min on columns"""
type authProviders_min_fields {
  id: String
}

"""
response of any mutation on the table "auth.providers"
"""
type authProviders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authProviders!]!
}

"""
input type for inserting object relation for remote table "auth.providers"
"""
input authProviders_obj_rel_insert_input {
  data: authProviders_insert_input!

  """upsert condition"""
  on_conflict: authProviders_on_conflict
}

"""
on_conflict condition type for table "auth.providers"
"""
input authProviders_on_conflict {
  constraint: authProviders_constraint!
  update_columns: [authProviders_update_column!]! = []
  where: authProviders_bool_exp
}

"""Ordering options when selecting data from "auth.providers"."""
input authProviders_order_by {
  id: order_by
  userProviders_aggregate: authUserProviders_aggregate_order_by
}

"""primary key columns input for table: auth.providers"""
input authProviders_pk_columns_input {
  id: String!
}

"""
select columns of table "auth.providers"
"""
enum authProviders_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "auth.providers"
"""
input authProviders_set_input {
  id: String
}

"""
Streaming cursor of the table "authProviders"
"""
input authProviders_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authProviders_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authProviders_stream_cursor_value_input {
  id: String
}

"""
update columns of table "auth.providers"
"""
enum authProviders_update_column {
  """column name"""
  id
}

input authProviders_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authProviders_set_input

  """filter the rows which have to be updated"""
  where: authProviders_bool_exp!
}

"""
columns and relationships of "auth.refresh_token_types"
"""
type authRefreshTokenTypes {
  comment: String

  """An array relationship"""
  refreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """An aggregate relationship"""
  refreshTokens_aggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!
  value: String!
}

"""
aggregated selection of "auth.refresh_token_types"
"""
type authRefreshTokenTypes_aggregate {
  aggregate: authRefreshTokenTypes_aggregate_fields
  nodes: [authRefreshTokenTypes!]!
}

"""
aggregate fields of "auth.refresh_token_types"
"""
type authRefreshTokenTypes_aggregate_fields {
  count(columns: [authRefreshTokenTypes_select_column!], distinct: Boolean): Int!
  max: authRefreshTokenTypes_max_fields
  min: authRefreshTokenTypes_min_fields
}

"""
Boolean expression to filter rows from the table "auth.refresh_token_types". All fields are combined with a logical 'AND'.
"""
input authRefreshTokenTypes_bool_exp {
  _and: [authRefreshTokenTypes_bool_exp!]
  _not: authRefreshTokenTypes_bool_exp
  _or: [authRefreshTokenTypes_bool_exp!]
  comment: String_comparison_exp
  refreshTokens: authRefreshTokens_bool_exp
  refreshTokens_aggregate: authRefreshTokens_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "auth.refresh_token_types"
"""
enum authRefreshTokenTypes_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  refresh_token_types_pkey
}

enum authRefreshTokenTypes_enum {
  """Personal access token"""
  pat

  """Regular refresh token"""
  regular
}

"""
Boolean expression to compare columns of type "authRefreshTokenTypes_enum". All fields are combined with logical 'AND'.
"""
input authRefreshTokenTypes_enum_comparison_exp {
  _eq: authRefreshTokenTypes_enum
  _in: [authRefreshTokenTypes_enum!]
  _is_null: Boolean
  _neq: authRefreshTokenTypes_enum
  _nin: [authRefreshTokenTypes_enum!]
}

"""
input type for inserting data into table "auth.refresh_token_types"
"""
input authRefreshTokenTypes_insert_input {
  comment: String
  refreshTokens: authRefreshTokens_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type authRefreshTokenTypes_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type authRefreshTokenTypes_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "auth.refresh_token_types"
"""
type authRefreshTokenTypes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRefreshTokenTypes!]!
}

"""
on_conflict condition type for table "auth.refresh_token_types"
"""
input authRefreshTokenTypes_on_conflict {
  constraint: authRefreshTokenTypes_constraint!
  update_columns: [authRefreshTokenTypes_update_column!]! = []
  where: authRefreshTokenTypes_bool_exp
}

"""Ordering options when selecting data from "auth.refresh_token_types"."""
input authRefreshTokenTypes_order_by {
  comment: order_by
  refreshTokens_aggregate: authRefreshTokens_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: auth.refresh_token_types"""
input authRefreshTokenTypes_pk_columns_input {
  value: String!
}

"""
select columns of table "auth.refresh_token_types"
"""
enum authRefreshTokenTypes_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "auth.refresh_token_types"
"""
input authRefreshTokenTypes_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "authRefreshTokenTypes"
"""
input authRefreshTokenTypes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authRefreshTokenTypes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authRefreshTokenTypes_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "auth.refresh_token_types"
"""
enum authRefreshTokenTypes_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input authRefreshTokenTypes_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authRefreshTokenTypes_set_input

  """filter the rows which have to be updated"""
  where: authRefreshTokenTypes_bool_exp!
}

"""
User refresh tokens. Hasura auth uses them to rotate new access tokens as long as the refresh token is not expired. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authRefreshTokens {
  createdAt: timestamptz!
  expiresAt: timestamptz!
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  refreshTokenHash: String
  type: authRefreshTokenTypes_enum!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.refresh_tokens"
"""
type authRefreshTokens_aggregate {
  aggregate: authRefreshTokens_aggregate_fields
  nodes: [authRefreshTokens!]!
}

input authRefreshTokens_aggregate_bool_exp {
  count: authRefreshTokens_aggregate_bool_exp_count
}

input authRefreshTokens_aggregate_bool_exp_count {
  arguments: [authRefreshTokens_select_column!]
  distinct: Boolean
  filter: authRefreshTokens_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.refresh_tokens"
"""
type authRefreshTokens_aggregate_fields {
  count(columns: [authRefreshTokens_select_column!], distinct: Boolean): Int!
  max: authRefreshTokens_max_fields
  min: authRefreshTokens_min_fields
}

"""
order by aggregate values of table "auth.refresh_tokens"
"""
input authRefreshTokens_aggregate_order_by {
  count: order_by
  max: authRefreshTokens_max_order_by
  min: authRefreshTokens_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input authRefreshTokens_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "auth.refresh_tokens"
"""
input authRefreshTokens_arr_rel_insert_input {
  data: [authRefreshTokens_insert_input!]!

  """upsert condition"""
  on_conflict: authRefreshTokens_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'.
"""
input authRefreshTokens_bool_exp {
  _and: [authRefreshTokens_bool_exp!]
  _not: authRefreshTokens_bool_exp
  _or: [authRefreshTokens_bool_exp!]
  createdAt: timestamptz_comparison_exp
  expiresAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  refreshTokenHash: String_comparison_exp
  type: authRefreshTokenTypes_enum_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.refresh_tokens"
"""
enum authRefreshTokens_constraint {
  """
  unique or primary key constraint on columns "user_id"
  """
  refresh_tokens_metadata_name_user_id_unique

  """
  unique or primary key constraint on columns "id"
  """
  refresh_tokens_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input authRefreshTokens_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input authRefreshTokens_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input authRefreshTokens_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "auth.refresh_tokens"
"""
input authRefreshTokens_insert_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  metadata: jsonb
  refreshTokenHash: String
  type: authRefreshTokenTypes_enum
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authRefreshTokens_max_fields {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  refreshTokenHash: String
  userId: uuid
}

"""
order by max() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_max_order_by {
  createdAt: order_by
  expiresAt: order_by
  id: order_by
  refreshTokenHash: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authRefreshTokens_min_fields {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  refreshTokenHash: String
  userId: uuid
}

"""
order by min() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_min_order_by {
  createdAt: order_by
  expiresAt: order_by
  id: order_by
  refreshTokenHash: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.refresh_tokens"
"""
type authRefreshTokens_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRefreshTokens!]!
}

"""
on_conflict condition type for table "auth.refresh_tokens"
"""
input authRefreshTokens_on_conflict {
  constraint: authRefreshTokens_constraint!
  update_columns: [authRefreshTokens_update_column!]! = []
  where: authRefreshTokens_bool_exp
}

"""Ordering options when selecting data from "auth.refresh_tokens"."""
input authRefreshTokens_order_by {
  createdAt: order_by
  expiresAt: order_by
  id: order_by
  metadata: order_by
  refreshTokenHash: order_by
  type: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.refresh_tokens"""
input authRefreshTokens_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input authRefreshTokens_prepend_input {
  metadata: jsonb
}

"""
select columns of table "auth.refresh_tokens"
"""
enum authRefreshTokens_select_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  refreshTokenHash

  """column name"""
  type

  """column name"""
  userId
}

"""
input type for updating data in table "auth.refresh_tokens"
"""
input authRefreshTokens_set_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  metadata: jsonb
  refreshTokenHash: String
  type: authRefreshTokenTypes_enum
  userId: uuid
}

"""
Streaming cursor of the table "authRefreshTokens"
"""
input authRefreshTokens_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authRefreshTokens_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authRefreshTokens_stream_cursor_value_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  metadata: jsonb
  refreshTokenHash: String
  type: authRefreshTokenTypes_enum
  userId: uuid
}

"""
update columns of table "auth.refresh_tokens"
"""
enum authRefreshTokens_update_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  refreshTokenHash

  """column name"""
  type

  """column name"""
  userId
}

input authRefreshTokens_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: authRefreshTokens_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: authRefreshTokens_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: authRefreshTokens_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: authRefreshTokens_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: authRefreshTokens_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: authRefreshTokens_set_input

  """filter the rows which have to be updated"""
  where: authRefreshTokens_bool_exp!
}

"""
Persistent Hasura roles for users. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authRoles {
  role: String!

  """An array relationship"""
  userRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """An aggregate relationship"""
  userRoles_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """An array relationship"""
  usersByDefaultRole(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  usersByDefaultRole_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
}

"""
aggregated selection of "auth.roles"
"""
type authRoles_aggregate {
  aggregate: authRoles_aggregate_fields
  nodes: [authRoles!]!
}

"""
aggregate fields of "auth.roles"
"""
type authRoles_aggregate_fields {
  count(columns: [authRoles_select_column!], distinct: Boolean): Int!
  max: authRoles_max_fields
  min: authRoles_min_fields
}

"""
Boolean expression to filter rows from the table "auth.roles". All fields are combined with a logical 'AND'.
"""
input authRoles_bool_exp {
  _and: [authRoles_bool_exp!]
  _not: authRoles_bool_exp
  _or: [authRoles_bool_exp!]
  role: String_comparison_exp
  userRoles: authUserRoles_bool_exp
  userRoles_aggregate: authUserRoles_aggregate_bool_exp
  usersByDefaultRole: users_bool_exp
  usersByDefaultRole_aggregate: users_aggregate_bool_exp
}

"""
unique or primary key constraints on table "auth.roles"
"""
enum authRoles_constraint {
  """
  unique or primary key constraint on columns "role"
  """
  roles_pkey
}

"""
input type for inserting data into table "auth.roles"
"""
input authRoles_insert_input {
  role: String
  userRoles: authUserRoles_arr_rel_insert_input
  usersByDefaultRole: users_arr_rel_insert_input
}

"""aggregate max on columns"""
type authRoles_max_fields {
  role: String
}

"""aggregate min on columns"""
type authRoles_min_fields {
  role: String
}

"""
response of any mutation on the table "auth.roles"
"""
type authRoles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRoles!]!
}

"""
input type for inserting object relation for remote table "auth.roles"
"""
input authRoles_obj_rel_insert_input {
  data: authRoles_insert_input!

  """upsert condition"""
  on_conflict: authRoles_on_conflict
}

"""
on_conflict condition type for table "auth.roles"
"""
input authRoles_on_conflict {
  constraint: authRoles_constraint!
  update_columns: [authRoles_update_column!]! = []
  where: authRoles_bool_exp
}

"""Ordering options when selecting data from "auth.roles"."""
input authRoles_order_by {
  role: order_by
  userRoles_aggregate: authUserRoles_aggregate_order_by
  usersByDefaultRole_aggregate: users_aggregate_order_by
}

"""primary key columns input for table: auth.roles"""
input authRoles_pk_columns_input {
  role: String!
}

"""
select columns of table "auth.roles"
"""
enum authRoles_select_column {
  """column name"""
  role
}

"""
input type for updating data in table "auth.roles"
"""
input authRoles_set_input {
  role: String
}

"""
Streaming cursor of the table "authRoles"
"""
input authRoles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authRoles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authRoles_stream_cursor_value_input {
  role: String
}

"""
update columns of table "auth.roles"
"""
enum authRoles_update_column {
  """column name"""
  role
}

input authRoles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authRoles_set_input

  """filter the rows which have to be updated"""
  where: authRoles_bool_exp!
}

"""
Active providers for a given user. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserProviders {
  accessToken: String!
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  provider: authProviders!
  providerId: String!
  providerUserId: String!
  refreshToken: String
  updatedAt: timestamptz!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_providers"
"""
type authUserProviders_aggregate {
  aggregate: authUserProviders_aggregate_fields
  nodes: [authUserProviders!]!
}

input authUserProviders_aggregate_bool_exp {
  count: authUserProviders_aggregate_bool_exp_count
}

input authUserProviders_aggregate_bool_exp_count {
  arguments: [authUserProviders_select_column!]
  distinct: Boolean
  filter: authUserProviders_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.user_providers"
"""
type authUserProviders_aggregate_fields {
  count(columns: [authUserProviders_select_column!], distinct: Boolean): Int!
  max: authUserProviders_max_fields
  min: authUserProviders_min_fields
}

"""
order by aggregate values of table "auth.user_providers"
"""
input authUserProviders_aggregate_order_by {
  count: order_by
  max: authUserProviders_max_order_by
  min: authUserProviders_min_order_by
}

"""
input type for inserting array relation for remote table "auth.user_providers"
"""
input authUserProviders_arr_rel_insert_input {
  data: [authUserProviders_insert_input!]!

  """upsert condition"""
  on_conflict: authUserProviders_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.user_providers". All fields are combined with a logical 'AND'.
"""
input authUserProviders_bool_exp {
  _and: [authUserProviders_bool_exp!]
  _not: authUserProviders_bool_exp
  _or: [authUserProviders_bool_exp!]
  accessToken: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  provider: authProviders_bool_exp
  providerId: String_comparison_exp
  providerUserId: String_comparison_exp
  refreshToken: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_providers"
"""
enum authUserProviders_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_providers_pkey

  """
  unique or primary key constraint on columns "provider_user_id", "provider_id"
  """
  user_providers_provider_id_provider_user_id_key

  """
  unique or primary key constraint on columns "user_id", "provider_id"
  """
  user_providers_user_id_provider_id_key
}

"""
input type for inserting data into table "auth.user_providers"
"""
input authUserProviders_insert_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  provider: authProviders_obj_rel_insert_input
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserProviders_max_fields {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "auth.user_providers"
"""
input authUserProviders_max_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserProviders_min_fields {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "auth.user_providers"
"""
input authUserProviders_min_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_providers"
"""
type authUserProviders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserProviders!]!
}

"""
on_conflict condition type for table "auth.user_providers"
"""
input authUserProviders_on_conflict {
  constraint: authUserProviders_constraint!
  update_columns: [authUserProviders_update_column!]! = []
  where: authUserProviders_bool_exp
}

"""Ordering options when selecting data from "auth.user_providers"."""
input authUserProviders_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  provider: authProviders_order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.user_providers"""
input authUserProviders_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_providers"
"""
enum authUserProviders_select_column {
  """column name"""
  accessToken

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  providerId

  """column name"""
  providerUserId

  """column name"""
  refreshToken

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_providers"
"""
input authUserProviders_set_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "authUserProviders"
"""
input authUserProviders_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserProviders_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserProviders_stream_cursor_value_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "auth.user_providers"
"""
enum authUserProviders_update_column {
  """column name"""
  accessToken

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  providerId

  """column name"""
  providerUserId

  """column name"""
  refreshToken

  """column name"""
  updatedAt

  """column name"""
  userId
}

input authUserProviders_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authUserProviders_set_input

  """filter the rows which have to be updated"""
  where: authUserProviders_bool_exp!
}

"""
Roles of users. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserRoles {
  createdAt: timestamptz!
  id: uuid!
  role: String!

  """An object relationship"""
  roleByRole: authRoles!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_roles"
"""
type authUserRoles_aggregate {
  aggregate: authUserRoles_aggregate_fields
  nodes: [authUserRoles!]!
}

input authUserRoles_aggregate_bool_exp {
  count: authUserRoles_aggregate_bool_exp_count
}

input authUserRoles_aggregate_bool_exp_count {
  arguments: [authUserRoles_select_column!]
  distinct: Boolean
  filter: authUserRoles_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.user_roles"
"""
type authUserRoles_aggregate_fields {
  count(columns: [authUserRoles_select_column!], distinct: Boolean): Int!
  max: authUserRoles_max_fields
  min: authUserRoles_min_fields
}

"""
order by aggregate values of table "auth.user_roles"
"""
input authUserRoles_aggregate_order_by {
  count: order_by
  max: authUserRoles_max_order_by
  min: authUserRoles_min_order_by
}

"""
input type for inserting array relation for remote table "auth.user_roles"
"""
input authUserRoles_arr_rel_insert_input {
  data: [authUserRoles_insert_input!]!

  """upsert condition"""
  on_conflict: authUserRoles_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.user_roles". All fields are combined with a logical 'AND'.
"""
input authUserRoles_bool_exp {
  _and: [authUserRoles_bool_exp!]
  _not: authUserRoles_bool_exp
  _or: [authUserRoles_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  role: String_comparison_exp
  roleByRole: authRoles_bool_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_roles"
"""
enum authUserRoles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_roles_pkey

  """
  unique or primary key constraint on columns "user_id", "role"
  """
  user_roles_user_id_role_key
}

"""
input type for inserting data into table "auth.user_roles"
"""
input authUserRoles_insert_input {
  createdAt: timestamptz
  id: uuid
  role: String
  roleByRole: authRoles_obj_rel_insert_input
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserRoles_max_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
order by max() on columns of table "auth.user_roles"
"""
input authUserRoles_max_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserRoles_min_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
order by min() on columns of table "auth.user_roles"
"""
input authUserRoles_min_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_roles"
"""
type authUserRoles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserRoles!]!
}

"""
on_conflict condition type for table "auth.user_roles"
"""
input authUserRoles_on_conflict {
  constraint: authUserRoles_constraint!
  update_columns: [authUserRoles_update_column!]! = []
  where: authUserRoles_bool_exp
}

"""Ordering options when selecting data from "auth.user_roles"."""
input authUserRoles_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  roleByRole: authRoles_order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.user_roles"""
input authUserRoles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_roles"
"""
enum authUserRoles_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  role

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_roles"
"""
input authUserRoles_set_input {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
Streaming cursor of the table "authUserRoles"
"""
input authUserRoles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserRoles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserRoles_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
update columns of table "auth.user_roles"
"""
enum authUserRoles_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  role

  """column name"""
  userId
}

input authUserRoles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authUserRoles_set_input

  """filter the rows which have to be updated"""
  where: authUserRoles_bool_exp!
}

"""
User webauthn security keys. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserSecurityKeys {
  counter: bigint!
  credentialId: String!
  credentialPublicKey: bytea
  id: uuid!
  nickname: String
  transports: String!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_security_keys"
"""
type authUserSecurityKeys_aggregate {
  aggregate: authUserSecurityKeys_aggregate_fields
  nodes: [authUserSecurityKeys!]!
}

input authUserSecurityKeys_aggregate_bool_exp {
  count: authUserSecurityKeys_aggregate_bool_exp_count
}

input authUserSecurityKeys_aggregate_bool_exp_count {
  arguments: [authUserSecurityKeys_select_column!]
  distinct: Boolean
  filter: authUserSecurityKeys_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.user_security_keys"
"""
type authUserSecurityKeys_aggregate_fields {
  avg: authUserSecurityKeys_avg_fields
  count(columns: [authUserSecurityKeys_select_column!], distinct: Boolean): Int!
  max: authUserSecurityKeys_max_fields
  min: authUserSecurityKeys_min_fields
  stddev: authUserSecurityKeys_stddev_fields
  stddev_pop: authUserSecurityKeys_stddev_pop_fields
  stddev_samp: authUserSecurityKeys_stddev_samp_fields
  sum: authUserSecurityKeys_sum_fields
  var_pop: authUserSecurityKeys_var_pop_fields
  var_samp: authUserSecurityKeys_var_samp_fields
  variance: authUserSecurityKeys_variance_fields
}

"""
order by aggregate values of table "auth.user_security_keys"
"""
input authUserSecurityKeys_aggregate_order_by {
  avg: authUserSecurityKeys_avg_order_by
  count: order_by
  max: authUserSecurityKeys_max_order_by
  min: authUserSecurityKeys_min_order_by
  stddev: authUserSecurityKeys_stddev_order_by
  stddev_pop: authUserSecurityKeys_stddev_pop_order_by
  stddev_samp: authUserSecurityKeys_stddev_samp_order_by
  sum: authUserSecurityKeys_sum_order_by
  var_pop: authUserSecurityKeys_var_pop_order_by
  var_samp: authUserSecurityKeys_var_samp_order_by
  variance: authUserSecurityKeys_variance_order_by
}

"""
input type for inserting array relation for remote table "auth.user_security_keys"
"""
input authUserSecurityKeys_arr_rel_insert_input {
  data: [authUserSecurityKeys_insert_input!]!

  """upsert condition"""
  on_conflict: authUserSecurityKeys_on_conflict
}

"""aggregate avg on columns"""
type authUserSecurityKeys_avg_fields {
  counter: Float
}

"""
order by avg() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_avg_order_by {
  counter: order_by
}

"""
Boolean expression to filter rows from the table "auth.user_security_keys". All fields are combined with a logical 'AND'.
"""
input authUserSecurityKeys_bool_exp {
  _and: [authUserSecurityKeys_bool_exp!]
  _not: authUserSecurityKeys_bool_exp
  _or: [authUserSecurityKeys_bool_exp!]
  counter: bigint_comparison_exp
  credentialId: String_comparison_exp
  credentialPublicKey: bytea_comparison_exp
  id: uuid_comparison_exp
  nickname: String_comparison_exp
  transports: String_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_security_keys"
"""
enum authUserSecurityKeys_constraint {
  """
  unique or primary key constraint on columns "credential_id"
  """
  user_security_key_credential_id_key

  """
  unique or primary key constraint on columns "id"
  """
  user_security_keys_pkey
}

"""
input type for incrementing numeric columns in table "auth.user_security_keys"
"""
input authUserSecurityKeys_inc_input {
  counter: bigint
}

"""
input type for inserting data into table "auth.user_security_keys"
"""
input authUserSecurityKeys_insert_input {
  counter: bigint
  credentialId: String
  credentialPublicKey: bytea
  id: uuid
  nickname: String
  transports: String
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserSecurityKeys_max_fields {
  counter: bigint
  credentialId: String
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""
order by max() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_max_order_by {
  counter: order_by
  credentialId: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserSecurityKeys_min_fields {
  counter: bigint
  credentialId: String
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""
order by min() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_min_order_by {
  counter: order_by
  credentialId: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_security_keys"
"""
type authUserSecurityKeys_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserSecurityKeys!]!
}

"""
on_conflict condition type for table "auth.user_security_keys"
"""
input authUserSecurityKeys_on_conflict {
  constraint: authUserSecurityKeys_constraint!
  update_columns: [authUserSecurityKeys_update_column!]! = []
  where: authUserSecurityKeys_bool_exp
}

"""Ordering options when selecting data from "auth.user_security_keys"."""
input authUserSecurityKeys_order_by {
  counter: order_by
  credentialId: order_by
  credentialPublicKey: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.user_security_keys"""
input authUserSecurityKeys_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_security_keys"
"""
enum authUserSecurityKeys_select_column {
  """column name"""
  counter

  """column name"""
  credentialId

  """column name"""
  credentialPublicKey

  """column name"""
  id

  """column name"""
  nickname

  """column name"""
  transports

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_security_keys"
"""
input authUserSecurityKeys_set_input {
  counter: bigint
  credentialId: String
  credentialPublicKey: bytea
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""aggregate stddev on columns"""
type authUserSecurityKeys_stddev_fields {
  counter: Float
}

"""
order by stddev() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_order_by {
  counter: order_by
}

"""aggregate stddev_pop on columns"""
type authUserSecurityKeys_stddev_pop_fields {
  counter: Float
}

"""
order by stddev_pop() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_pop_order_by {
  counter: order_by
}

"""aggregate stddev_samp on columns"""
type authUserSecurityKeys_stddev_samp_fields {
  counter: Float
}

"""
order by stddev_samp() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_samp_order_by {
  counter: order_by
}

"""
Streaming cursor of the table "authUserSecurityKeys"
"""
input authUserSecurityKeys_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserSecurityKeys_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserSecurityKeys_stream_cursor_value_input {
  counter: bigint
  credentialId: String
  credentialPublicKey: bytea
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""aggregate sum on columns"""
type authUserSecurityKeys_sum_fields {
  counter: bigint
}

"""
order by sum() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_sum_order_by {
  counter: order_by
}

"""
update columns of table "auth.user_security_keys"
"""
enum authUserSecurityKeys_update_column {
  """column name"""
  counter

  """column name"""
  credentialId

  """column name"""
  credentialPublicKey

  """column name"""
  id

  """column name"""
  nickname

  """column name"""
  transports

  """column name"""
  userId
}

input authUserSecurityKeys_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: authUserSecurityKeys_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: authUserSecurityKeys_set_input

  """filter the rows which have to be updated"""
  where: authUserSecurityKeys_bool_exp!
}

"""aggregate var_pop on columns"""
type authUserSecurityKeys_var_pop_fields {
  counter: Float
}

"""
order by var_pop() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_var_pop_order_by {
  counter: order_by
}

"""aggregate var_samp on columns"""
type authUserSecurityKeys_var_samp_fields {
  counter: Float
}

"""
order by var_samp() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_var_samp_order_by {
  counter: order_by
}

"""aggregate variance on columns"""
type authUserSecurityKeys_variance_fields {
  counter: Float
}

"""
order by variance() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_variance_order_by {
  counter: order_by
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "storage.buckets"
"""
type buckets {
  cacheControl: String
  createdAt: timestamptz!
  downloadExpiration: Int!

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """An aggregate relationship"""
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!
  id: String!
  maxUploadFileSize: Int!
  minUploadFileSize: Int!
  presignedUrlsEnabled: Boolean!
  updatedAt: timestamptz!
}

"""
aggregated selection of "storage.buckets"
"""
type buckets_aggregate {
  aggregate: buckets_aggregate_fields
  nodes: [buckets!]!
}

"""
aggregate fields of "storage.buckets"
"""
type buckets_aggregate_fields {
  avg: buckets_avg_fields
  count(columns: [buckets_select_column!], distinct: Boolean): Int!
  max: buckets_max_fields
  min: buckets_min_fields
  stddev: buckets_stddev_fields
  stddev_pop: buckets_stddev_pop_fields
  stddev_samp: buckets_stddev_samp_fields
  sum: buckets_sum_fields
  var_pop: buckets_var_pop_fields
  var_samp: buckets_var_samp_fields
  variance: buckets_variance_fields
}

"""aggregate avg on columns"""
type buckets_avg_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""
Boolean expression to filter rows from the table "storage.buckets". All fields are combined with a logical 'AND'.
"""
input buckets_bool_exp {
  _and: [buckets_bool_exp!]
  _not: buckets_bool_exp
  _or: [buckets_bool_exp!]
  cacheControl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  downloadExpiration: Int_comparison_exp
  files: files_bool_exp
  files_aggregate: files_aggregate_bool_exp
  id: String_comparison_exp
  maxUploadFileSize: Int_comparison_exp
  minUploadFileSize: Int_comparison_exp
  presignedUrlsEnabled: Boolean_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "storage.buckets"
"""
enum buckets_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  buckets_pkey
}

"""
input type for incrementing numeric columns in table "storage.buckets"
"""
input buckets_inc_input {
  downloadExpiration: Int
  maxUploadFileSize: Int
  minUploadFileSize: Int
}

"""
input type for inserting data into table "storage.buckets"
"""
input buckets_insert_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  files: files_arr_rel_insert_input
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type buckets_max_fields {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type buckets_min_fields {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  updatedAt: timestamptz
}

"""
response of any mutation on the table "storage.buckets"
"""
type buckets_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [buckets!]!
}

"""
input type for inserting object relation for remote table "storage.buckets"
"""
input buckets_obj_rel_insert_input {
  data: buckets_insert_input!

  """upsert condition"""
  on_conflict: buckets_on_conflict
}

"""
on_conflict condition type for table "storage.buckets"
"""
input buckets_on_conflict {
  constraint: buckets_constraint!
  update_columns: [buckets_update_column!]! = []
  where: buckets_bool_exp
}

"""Ordering options when selecting data from "storage.buckets"."""
input buckets_order_by {
  cacheControl: order_by
  createdAt: order_by
  downloadExpiration: order_by
  files_aggregate: files_aggregate_order_by
  id: order_by
  maxUploadFileSize: order_by
  minUploadFileSize: order_by
  presignedUrlsEnabled: order_by
  updatedAt: order_by
}

"""primary key columns input for table: storage.buckets"""
input buckets_pk_columns_input {
  id: String!
}

"""
select columns of table "storage.buckets"
"""
enum buckets_select_column {
  """column name"""
  cacheControl

  """column name"""
  createdAt

  """column name"""
  downloadExpiration

  """column name"""
  id

  """column name"""
  maxUploadFileSize

  """column name"""
  minUploadFileSize

  """column name"""
  presignedUrlsEnabled

  """column name"""
  updatedAt
}

"""
input type for updating data in table "storage.buckets"
"""
input buckets_set_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type buckets_stddev_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate stddev_pop on columns"""
type buckets_stddev_pop_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate stddev_samp on columns"""
type buckets_stddev_samp_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""
Streaming cursor of the table "buckets"
"""
input buckets_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: buckets_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input buckets_stream_cursor_value_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type buckets_sum_fields {
  downloadExpiration: Int
  maxUploadFileSize: Int
  minUploadFileSize: Int
}

"""
update columns of table "storage.buckets"
"""
enum buckets_update_column {
  """column name"""
  cacheControl

  """column name"""
  createdAt

  """column name"""
  downloadExpiration

  """column name"""
  id

  """column name"""
  maxUploadFileSize

  """column name"""
  minUploadFileSize

  """column name"""
  presignedUrlsEnabled

  """column name"""
  updatedAt
}

input buckets_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: buckets_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: buckets_set_input

  """filter the rows which have to be updated"""
  where: buckets_bool_exp!
}

"""aggregate var_pop on columns"""
type buckets_var_pop_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate var_samp on columns"""
type buckets_var_samp_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate variance on columns"""
type buckets_variance_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

scalar bytea

"""
Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'.
"""
input bytea_comparison_exp {
  _eq: bytea
  _gt: bytea
  _gte: bytea
  _in: [bytea!]
  _is_null: Boolean
  _lt: bytea
  _lte: bytea
  _neq: bytea
  _nin: [bytea!]
}

scalar citext

"""
Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
"""
input citext_comparison_exp {
  _eq: citext
  _gt: citext
  _gte: citext

  """does the column match the given case-insensitive pattern"""
  _ilike: citext
  _in: [citext!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: citext
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: citext
  _lt: citext
  _lte: citext
  _neq: citext

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: citext
  _nin: [citext!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: citext

  """does the column NOT match the given pattern"""
  _nlike: citext

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: citext

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: citext

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: citext

  """does the column match the given SQL regular expression"""
  _similar: citext
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

input device_associated_pools_args {
  device_row: devices_scalar
}

input device_dissociated_pools_args {
  device_row: devices_scalar
}

"""Device to Pool association table"""
type device_pools {
  """An object relationship"""
  device: devices!
  deviceId: uuid!

  """An object relationship"""
  pool: pools!
  poolId: uuid!
}

"""
aggregated selection of "device_pools"
"""
type device_pools_aggregate {
  aggregate: device_pools_aggregate_fields
  nodes: [device_pools!]!
}

"""
aggregate fields of "device_pools"
"""
type device_pools_aggregate_fields {
  count(columns: [device_pools_select_column!], distinct: Boolean): Int!
  max: device_pools_max_fields
  min: device_pools_min_fields
}

"""
Boolean expression to filter rows from the table "device_pools". All fields are combined with a logical 'AND'.
"""
input device_pools_bool_exp {
  _and: [device_pools_bool_exp!]
  _not: device_pools_bool_exp
  _or: [device_pools_bool_exp!]
  device: devices_bool_exp
  deviceId: uuid_comparison_exp
  pool: pools_bool_exp
  poolId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "device_pools"
"""
enum device_pools_constraint {
  """
  unique or primary key constraint on columns "pool_id", "device_id"
  """
  device_pools_pkey
}

"""
input type for inserting data into table "device_pools"
"""
input device_pools_insert_input {
  device: devices_obj_rel_insert_input
  deviceId: uuid
  pool: pools_obj_rel_insert_input
  poolId: uuid
}

"""aggregate max on columns"""
type device_pools_max_fields {
  deviceId: uuid
  poolId: uuid
}

"""aggregate min on columns"""
type device_pools_min_fields {
  deviceId: uuid
  poolId: uuid
}

"""
response of any mutation on the table "device_pools"
"""
type device_pools_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [device_pools!]!
}

"""
on_conflict condition type for table "device_pools"
"""
input device_pools_on_conflict {
  constraint: device_pools_constraint!
  update_columns: [device_pools_update_column!]! = []
  where: device_pools_bool_exp
}

"""Ordering options when selecting data from "device_pools"."""
input device_pools_order_by {
  device: devices_order_by
  deviceId: order_by
  pool: pools_order_by
  poolId: order_by
}

"""primary key columns input for table: device_pools"""
input device_pools_pk_columns_input {
  deviceId: uuid!
  poolId: uuid!
}

"""
select columns of table "device_pools"
"""
enum device_pools_select_column {
  """column name"""
  deviceId

  """column name"""
  poolId
}

"""
input type for updating data in table "device_pools"
"""
input device_pools_set_input {
  deviceId: uuid
  poolId: uuid
}

"""
Streaming cursor of the table "device_pools"
"""
input device_pools_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: device_pools_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input device_pools_stream_cursor_value_input {
  deviceId: uuid
  poolId: uuid
}

"""
update columns of table "device_pools"
"""
enum device_pools_update_column {
  """column name"""
  deviceId

  """column name"""
  poolId
}

input device_pools_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: device_pools_set_input

  """filter the rows which have to be updated"""
  where: device_pools_bool_exp!
}

"""Table containing devices data"""
type devices {
  alternateDns: Boolean

  """Used as Computed Field on Devices Table"""
  associatedPools(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]
  createdAt: timestamptz!
  createdBy: uuid!
  description: String
  displayName: String!

  """Used as Computed Field on Devices Table"""
  dissociatedPools(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]
  id: uuid!
  ip: String!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  orgId: uuid!
  proxyIp: Boolean
  publicIp: String
  tags: [String!]
  updatedAt: timestamptz!
  updatedBy: uuid!
  version: String
}

"""
aggregated selection of "devices"
"""
type devices_aggregate {
  aggregate: devices_aggregate_fields
  nodes: [devices!]!
}

input devices_aggregate_bool_exp {
  bool_and: devices_aggregate_bool_exp_bool_and
  bool_or: devices_aggregate_bool_exp_bool_or
  count: devices_aggregate_bool_exp_count
}

input devices_aggregate_bool_exp_bool_and {
  arguments: devices_select_column_devices_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: devices_bool_exp
  predicate: Boolean_comparison_exp!
}

input devices_aggregate_bool_exp_bool_or {
  arguments: devices_select_column_devices_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: devices_bool_exp
  predicate: Boolean_comparison_exp!
}

input devices_aggregate_bool_exp_count {
  arguments: [devices_select_column!]
  distinct: Boolean
  filter: devices_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "devices"
"""
type devices_aggregate_fields {
  count(columns: [devices_select_column!], distinct: Boolean): Int!
  max: devices_max_fields
  min: devices_min_fields
}

"""
order by aggregate values of table "devices"
"""
input devices_aggregate_order_by {
  count: order_by
  max: devices_max_order_by
  min: devices_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input devices_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "devices"
"""
input devices_arr_rel_insert_input {
  data: [devices_insert_input!]!

  """upsert condition"""
  on_conflict: devices_on_conflict
}

"""
Boolean expression to filter rows from the table "devices". All fields are combined with a logical 'AND'.
"""
input devices_bool_exp {
  _and: [devices_bool_exp!]
  _not: devices_bool_exp
  _or: [devices_bool_exp!]
  alternateDns: Boolean_comparison_exp
  associatedPools: pools_bool_exp
  createdAt: timestamptz_comparison_exp
  createdBy: uuid_comparison_exp
  description: String_comparison_exp
  displayName: String_comparison_exp
  dissociatedPools: pools_bool_exp
  id: uuid_comparison_exp
  ip: String_comparison_exp
  metadata: jsonb_comparison_exp
  orgId: uuid_comparison_exp
  proxyIp: Boolean_comparison_exp
  publicIp: String_comparison_exp
  tags: String_array_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: uuid_comparison_exp
  version: String_comparison_exp
}

"""
unique or primary key constraints on table "devices"
"""
enum devices_constraint {
  """
  unique or primary key constraint on columns "display_name", "org_id"
  """
  devices_org_id_display_name_key

  """
  unique or primary key constraint on columns "id"
  """
  devices_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input devices_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input devices_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input devices_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "devices"
"""
input devices_insert_input {
  alternateDns: Boolean
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  ip: String
  metadata: jsonb
  orgId: uuid
  proxyIp: Boolean
  publicIp: String
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
  version: String
}

"""aggregate max on columns"""
type devices_max_fields {
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  ip: String
  orgId: uuid
  publicIp: String
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
  version: String
}

"""
order by max() on columns of table "devices"
"""
input devices_max_order_by {
  createdAt: order_by
  createdBy: order_by
  description: order_by
  displayName: order_by
  id: order_by
  ip: order_by
  orgId: order_by
  publicIp: order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
  version: order_by
}

"""aggregate min on columns"""
type devices_min_fields {
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  ip: String
  orgId: uuid
  publicIp: String
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
  version: String
}

"""
order by min() on columns of table "devices"
"""
input devices_min_order_by {
  createdAt: order_by
  createdBy: order_by
  description: order_by
  displayName: order_by
  id: order_by
  ip: order_by
  orgId: order_by
  publicIp: order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
  version: order_by
}

"""
response of any mutation on the table "devices"
"""
type devices_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [devices!]!
}

"""
input type for inserting object relation for remote table "devices"
"""
input devices_obj_rel_insert_input {
  data: devices_insert_input!

  """upsert condition"""
  on_conflict: devices_on_conflict
}

"""
on_conflict condition type for table "devices"
"""
input devices_on_conflict {
  constraint: devices_constraint!
  update_columns: [devices_update_column!]! = []
  where: devices_bool_exp
}

"""Ordering options when selecting data from "devices"."""
input devices_order_by {
  alternateDns: order_by
  associatedPools_aggregate: pools_aggregate_order_by
  createdAt: order_by
  createdBy: order_by
  description: order_by
  displayName: order_by
  dissociatedPools_aggregate: pools_aggregate_order_by
  id: order_by
  ip: order_by
  metadata: order_by
  orgId: order_by
  proxyIp: order_by
  publicIp: order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
  version: order_by
}

"""primary key columns input for table: devices"""
input devices_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input devices_prepend_input {
  metadata: jsonb
}

scalar devices_scalar

"""
select columns of table "devices"
"""
enum devices_select_column {
  """column name"""
  alternateDns

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  metadata

  """column name"""
  orgId

  """column name"""
  proxyIp

  """column name"""
  publicIp

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  version
}

"""
select "devices_aggregate_bool_exp_bool_and_arguments_columns" columns of table "devices"
"""
enum devices_select_column_devices_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  alternateDns

  """column name"""
  proxyIp
}

"""
select "devices_aggregate_bool_exp_bool_or_arguments_columns" columns of table "devices"
"""
enum devices_select_column_devices_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  alternateDns

  """column name"""
  proxyIp
}

"""
input type for updating data in table "devices"
"""
input devices_set_input {
  alternateDns: Boolean
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  ip: String
  metadata: jsonb
  orgId: uuid
  proxyIp: Boolean
  publicIp: String
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
  version: String
}

"""
Streaming cursor of the table "devices"
"""
input devices_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: devices_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input devices_stream_cursor_value_input {
  alternateDns: Boolean
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  ip: String
  metadata: jsonb
  orgId: uuid
  proxyIp: Boolean
  publicIp: String
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
  version: String
}

"""
update columns of table "devices"
"""
enum devices_update_column {
  """column name"""
  alternateDns

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  metadata

  """column name"""
  orgId

  """column name"""
  proxyIp

  """column name"""
  publicIp

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  version
}

input devices_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: devices_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: devices_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: devices_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: devices_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: devices_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: devices_set_input

  """filter the rows which have to be updated"""
  where: devices_bool_exp!
}

"""policy direction enum"""
type direction {
  description: String!
  value: String!
}

"""
aggregated selection of "direction"
"""
type direction_aggregate {
  aggregate: direction_aggregate_fields
  nodes: [direction!]!
}

"""
aggregate fields of "direction"
"""
type direction_aggregate_fields {
  count(columns: [direction_select_column!], distinct: Boolean): Int!
  max: direction_max_fields
  min: direction_min_fields
}

"""
Boolean expression to filter rows from the table "direction". All fields are combined with a logical 'AND'.
"""
input direction_bool_exp {
  _and: [direction_bool_exp!]
  _not: direction_bool_exp
  _or: [direction_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "direction"
"""
enum direction_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  direction_pkey
}

enum direction_enum {
  """EGRESS"""
  egress

  """INGRESS"""
  ingress
}

"""
Boolean expression to compare columns of type "direction_enum". All fields are combined with logical 'AND'.
"""
input direction_enum_comparison_exp {
  _eq: direction_enum
  _in: [direction_enum!]
  _is_null: Boolean
  _neq: direction_enum
  _nin: [direction_enum!]
}

"""
input type for inserting data into table "direction"
"""
input direction_insert_input {
  description: String
  value: String
}

"""aggregate max on columns"""
type direction_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type direction_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "direction"
"""
type direction_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [direction!]!
}

"""
on_conflict condition type for table "direction"
"""
input direction_on_conflict {
  constraint: direction_constraint!
  update_columns: [direction_update_column!]! = []
  where: direction_bool_exp
}

"""Ordering options when selecting data from "direction"."""
input direction_order_by {
  description: order_by
  value: order_by
}

"""primary key columns input for table: direction"""
input direction_pk_columns_input {
  value: String!
}

"""
select columns of table "direction"
"""
enum direction_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "direction"
"""
input direction_set_input {
  description: String
  value: String
}

"""
Streaming cursor of the table "direction"
"""
input direction_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: direction_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input direction_stream_cursor_value_input {
  description: String
  value: String
}

"""
update columns of table "direction"
"""
enum direction_update_column {
  """column name"""
  description

  """column name"""
  value
}

input direction_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: direction_set_input

  """filter the rows which have to be updated"""
  where: direction_bool_exp!
}

"""
columns and relationships of "storage.files"
"""
type files {
  """An object relationship"""
  bucket: buckets!
  bucketId: String!
  createdAt: timestamptz!
  etag: String
  id: uuid!
  isUploaded: Boolean
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz!
  uploadedByUserId: uuid
}

"""
aggregated selection of "storage.files"
"""
type files_aggregate {
  aggregate: files_aggregate_fields
  nodes: [files!]!
}

input files_aggregate_bool_exp {
  bool_and: files_aggregate_bool_exp_bool_and
  bool_or: files_aggregate_bool_exp_bool_or
  count: files_aggregate_bool_exp_count
}

input files_aggregate_bool_exp_bool_and {
  arguments: files_select_column_files_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: files_bool_exp
  predicate: Boolean_comparison_exp!
}

input files_aggregate_bool_exp_bool_or {
  arguments: files_select_column_files_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: files_bool_exp
  predicate: Boolean_comparison_exp!
}

input files_aggregate_bool_exp_count {
  arguments: [files_select_column!]
  distinct: Boolean
  filter: files_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "storage.files"
"""
type files_aggregate_fields {
  avg: files_avg_fields
  count(columns: [files_select_column!], distinct: Boolean): Int!
  max: files_max_fields
  min: files_min_fields
  stddev: files_stddev_fields
  stddev_pop: files_stddev_pop_fields
  stddev_samp: files_stddev_samp_fields
  sum: files_sum_fields
  var_pop: files_var_pop_fields
  var_samp: files_var_samp_fields
  variance: files_variance_fields
}

"""
order by aggregate values of table "storage.files"
"""
input files_aggregate_order_by {
  avg: files_avg_order_by
  count: order_by
  max: files_max_order_by
  min: files_min_order_by
  stddev: files_stddev_order_by
  stddev_pop: files_stddev_pop_order_by
  stddev_samp: files_stddev_samp_order_by
  sum: files_sum_order_by
  var_pop: files_var_pop_order_by
  var_samp: files_var_samp_order_by
  variance: files_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input files_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "storage.files"
"""
input files_arr_rel_insert_input {
  data: [files_insert_input!]!

  """upsert condition"""
  on_conflict: files_on_conflict
}

"""aggregate avg on columns"""
type files_avg_fields {
  size: Float
}

"""
order by avg() on columns of table "storage.files"
"""
input files_avg_order_by {
  size: order_by
}

"""
Boolean expression to filter rows from the table "storage.files". All fields are combined with a logical 'AND'.
"""
input files_bool_exp {
  _and: [files_bool_exp!]
  _not: files_bool_exp
  _or: [files_bool_exp!]
  bucket: buckets_bool_exp
  bucketId: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  etag: String_comparison_exp
  id: uuid_comparison_exp
  isUploaded: Boolean_comparison_exp
  metadata: jsonb_comparison_exp
  mimeType: String_comparison_exp
  name: String_comparison_exp
  size: Int_comparison_exp
  updatedAt: timestamptz_comparison_exp
  uploadedByUserId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "storage.files"
"""
enum files_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  files_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input files_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input files_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input files_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "storage.files"
"""
input files_inc_input {
  size: Int
}

"""
input type for inserting data into table "storage.files"
"""
input files_insert_input {
  bucket: buckets_obj_rel_insert_input
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  metadata: jsonb
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate max on columns"""
type files_max_fields {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""
order by max() on columns of table "storage.files"
"""
input files_max_order_by {
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""aggregate min on columns"""
type files_min_fields {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""
order by min() on columns of table "storage.files"
"""
input files_min_order_by {
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""
response of any mutation on the table "storage.files"
"""
type files_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [files!]!
}

"""
input type for inserting object relation for remote table "storage.files"
"""
input files_obj_rel_insert_input {
  data: files_insert_input!

  """upsert condition"""
  on_conflict: files_on_conflict
}

"""
on_conflict condition type for table "storage.files"
"""
input files_on_conflict {
  constraint: files_constraint!
  update_columns: [files_update_column!]! = []
  where: files_bool_exp
}

"""Ordering options when selecting data from "storage.files"."""
input files_order_by {
  bucket: buckets_order_by
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  isUploaded: order_by
  metadata: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""primary key columns input for table: storage.files"""
input files_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input files_prepend_input {
  metadata: jsonb
}

"""
select columns of table "storage.files"
"""
enum files_select_column {
  """column name"""
  bucketId

  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  isUploaded

  """column name"""
  metadata

  """column name"""
  mimeType

  """column name"""
  name

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploadedByUserId
}

"""
select "files_aggregate_bool_exp_bool_and_arguments_columns" columns of table "storage.files"
"""
enum files_select_column_files_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  isUploaded
}

"""
select "files_aggregate_bool_exp_bool_or_arguments_columns" columns of table "storage.files"
"""
enum files_select_column_files_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  isUploaded
}

"""
input type for updating data in table "storage.files"
"""
input files_set_input {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  metadata: jsonb
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate stddev on columns"""
type files_stddev_fields {
  size: Float
}

"""
order by stddev() on columns of table "storage.files"
"""
input files_stddev_order_by {
  size: order_by
}

"""aggregate stddev_pop on columns"""
type files_stddev_pop_fields {
  size: Float
}

"""
order by stddev_pop() on columns of table "storage.files"
"""
input files_stddev_pop_order_by {
  size: order_by
}

"""aggregate stddev_samp on columns"""
type files_stddev_samp_fields {
  size: Float
}

"""
order by stddev_samp() on columns of table "storage.files"
"""
input files_stddev_samp_order_by {
  size: order_by
}

"""
Streaming cursor of the table "files"
"""
input files_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: files_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input files_stream_cursor_value_input {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  metadata: jsonb
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate sum on columns"""
type files_sum_fields {
  size: Int
}

"""
order by sum() on columns of table "storage.files"
"""
input files_sum_order_by {
  size: order_by
}

"""
update columns of table "storage.files"
"""
enum files_update_column {
  """column name"""
  bucketId

  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  isUploaded

  """column name"""
  metadata

  """column name"""
  mimeType

  """column name"""
  name

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploadedByUserId
}

input files_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: files_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: files_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: files_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: files_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: files_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: files_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: files_set_input

  """filter the rows which have to be updated"""
  where: files_bool_exp!
}

"""aggregate var_pop on columns"""
type files_var_pop_fields {
  size: Float
}

"""
order by var_pop() on columns of table "storage.files"
"""
input files_var_pop_order_by {
  size: order_by
}

"""aggregate var_samp on columns"""
type files_var_samp_fields {
  size: Float
}

"""
order by var_samp() on columns of table "storage.files"
"""
input files_var_samp_order_by {
  size: order_by
}

"""aggregate variance on columns"""
type files_variance_fields {
  size: Float
}

"""
order by variance() on columns of table "storage.files"
"""
input files_variance_order_by {
  size: order_by
}

"""Table containing user groups that belongs to an organization"""
type groups {
  createdAt: timestamptz!
  createdBy: uuid!
  description: String
  displayName: String!
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  orgId: uuid!

  """An object relationship"""
  organization: organizations!
  tags: [String!]
  updatedAt: timestamptz!
  updatedBy: uuid!
}

"""
aggregated selection of "groups"
"""
type groups_aggregate {
  aggregate: groups_aggregate_fields
  nodes: [groups!]!
}

input groups_aggregate_bool_exp {
  count: groups_aggregate_bool_exp_count
}

input groups_aggregate_bool_exp_count {
  arguments: [groups_select_column!]
  distinct: Boolean
  filter: groups_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "groups"
"""
type groups_aggregate_fields {
  count(columns: [groups_select_column!], distinct: Boolean): Int!
  max: groups_max_fields
  min: groups_min_fields
}

"""
order by aggregate values of table "groups"
"""
input groups_aggregate_order_by {
  count: order_by
  max: groups_max_order_by
  min: groups_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input groups_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "groups"
"""
input groups_arr_rel_insert_input {
  data: [groups_insert_input!]!

  """upsert condition"""
  on_conflict: groups_on_conflict
}

"""
Boolean expression to filter rows from the table "groups". All fields are combined with a logical 'AND'.
"""
input groups_bool_exp {
  _and: [groups_bool_exp!]
  _not: groups_bool_exp
  _or: [groups_bool_exp!]
  createdAt: timestamptz_comparison_exp
  createdBy: uuid_comparison_exp
  description: String_comparison_exp
  displayName: String_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  orgId: uuid_comparison_exp
  organization: organizations_bool_exp
  tags: String_array_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: uuid_comparison_exp
}

"""
unique or primary key constraints on table "groups"
"""
enum groups_constraint {
  """
  unique or primary key constraint on columns "display_name", "org_id"
  """
  groups_org_id_display_name_key

  """
  unique or primary key constraint on columns "id"
  """
  groups_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input groups_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input groups_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input groups_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "groups"
"""
input groups_insert_input {
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  metadata: jsonb
  orgId: uuid
  organization: organizations_obj_rel_insert_input
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
}

"""aggregate max on columns"""
type groups_max_fields {
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  orgId: uuid
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
order by max() on columns of table "groups"
"""
input groups_max_order_by {
  createdAt: order_by
  createdBy: order_by
  description: order_by
  displayName: order_by
  id: order_by
  orgId: order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""aggregate min on columns"""
type groups_min_fields {
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  orgId: uuid
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
order by min() on columns of table "groups"
"""
input groups_min_order_by {
  createdAt: order_by
  createdBy: order_by
  description: order_by
  displayName: order_by
  id: order_by
  orgId: order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""
response of any mutation on the table "groups"
"""
type groups_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [groups!]!
}

"""
input type for inserting object relation for remote table "groups"
"""
input groups_obj_rel_insert_input {
  data: groups_insert_input!

  """upsert condition"""
  on_conflict: groups_on_conflict
}

"""
on_conflict condition type for table "groups"
"""
input groups_on_conflict {
  constraint: groups_constraint!
  update_columns: [groups_update_column!]! = []
  where: groups_bool_exp
}

"""Ordering options when selecting data from "groups"."""
input groups_order_by {
  createdAt: order_by
  createdBy: order_by
  description: order_by
  displayName: order_by
  id: order_by
  metadata: order_by
  orgId: order_by
  organization: organizations_order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""primary key columns input for table: groups"""
input groups_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input groups_prepend_input {
  metadata: jsonb
}

"""
select columns of table "groups"
"""
enum groups_select_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  orgId

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

"""
input type for updating data in table "groups"
"""
input groups_set_input {
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  metadata: jsonb
  orgId: uuid
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
Streaming cursor of the table "groups"
"""
input groups_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: groups_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input groups_stream_cursor_value_input {
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  metadata: jsonb
  orgId: uuid
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
update columns of table "groups"
"""
enum groups_update_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  orgId

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

input groups_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: groups_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: groups_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: groups_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: groups_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: groups_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: groups_set_input

  """filter the rows which have to be updated"""
  where: groups_bool_exp!
}

"""Table containing invitations for non-org members to join an org."""
type invitations {
  createdAt: timestamptz!
  createdBy: uuid!
  email: citext!

  """Used as Computed Field on Invitations Table"""
  inviter_name: String

  """Used as Computed Field on Invitations Table"""
  inviter_org_name: String
  orgId: uuid!

  """An object relationship"""
  organization: organizations!
  role: String!
  status: status_enum!
  updatedAt: timestamptz!
  updatedBy: uuid!
}

"""
aggregated selection of "invitations"
"""
type invitations_aggregate {
  aggregate: invitations_aggregate_fields
  nodes: [invitations!]!
}

input invitations_aggregate_bool_exp {
  count: invitations_aggregate_bool_exp_count
}

input invitations_aggregate_bool_exp_count {
  arguments: [invitations_select_column!]
  distinct: Boolean
  filter: invitations_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "invitations"
"""
type invitations_aggregate_fields {
  count(columns: [invitations_select_column!], distinct: Boolean): Int!
  max: invitations_max_fields
  min: invitations_min_fields
}

"""
order by aggregate values of table "invitations"
"""
input invitations_aggregate_order_by {
  count: order_by
  max: invitations_max_order_by
  min: invitations_min_order_by
}

"""
input type for inserting array relation for remote table "invitations"
"""
input invitations_arr_rel_insert_input {
  data: [invitations_insert_input!]!

  """upsert condition"""
  on_conflict: invitations_on_conflict
}

"""
Boolean expression to filter rows from the table "invitations". All fields are combined with a logical 'AND'.
"""
input invitations_bool_exp {
  _and: [invitations_bool_exp!]
  _not: invitations_bool_exp
  _or: [invitations_bool_exp!]
  createdAt: timestamptz_comparison_exp
  createdBy: uuid_comparison_exp
  email: citext_comparison_exp
  inviter_name: String_comparison_exp
  inviter_org_name: String_comparison_exp
  orgId: uuid_comparison_exp
  organization: organizations_bool_exp
  role: String_comparison_exp
  status: status_enum_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: uuid_comparison_exp
}

"""
unique or primary key constraints on table "invitations"
"""
enum invitations_constraint {
  """
  unique or primary key constraint on columns "email", "org_id"
  """
  invitations_pkey
}

"""
input type for inserting data into table "invitations"
"""
input invitations_insert_input {
  createdAt: timestamptz
  createdBy: uuid
  email: citext
  orgId: uuid
  organization: organizations_obj_rel_insert_input
  role: String
  status: status_enum
  updatedAt: timestamptz
  updatedBy: uuid
}

"""aggregate max on columns"""
type invitations_max_fields {
  createdAt: timestamptz
  createdBy: uuid
  email: citext

  """Used as Computed Field on Invitations Table"""
  inviter_name: String

  """Used as Computed Field on Invitations Table"""
  inviter_org_name: String
  orgId: uuid
  role: String
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
order by max() on columns of table "invitations"
"""
input invitations_max_order_by {
  createdAt: order_by
  createdBy: order_by
  email: order_by
  orgId: order_by
  role: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""aggregate min on columns"""
type invitations_min_fields {
  createdAt: timestamptz
  createdBy: uuid
  email: citext

  """Used as Computed Field on Invitations Table"""
  inviter_name: String

  """Used as Computed Field on Invitations Table"""
  inviter_org_name: String
  orgId: uuid
  role: String
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
order by min() on columns of table "invitations"
"""
input invitations_min_order_by {
  createdAt: order_by
  createdBy: order_by
  email: order_by
  orgId: order_by
  role: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""
response of any mutation on the table "invitations"
"""
type invitations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [invitations!]!
}

"""
on_conflict condition type for table "invitations"
"""
input invitations_on_conflict {
  constraint: invitations_constraint!
  update_columns: [invitations_update_column!]! = []
  where: invitations_bool_exp
}

"""Ordering options when selecting data from "invitations"."""
input invitations_order_by {
  createdAt: order_by
  createdBy: order_by
  email: order_by
  inviter_name: order_by
  inviter_org_name: order_by
  orgId: order_by
  organization: organizations_order_by
  role: order_by
  status: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""primary key columns input for table: invitations"""
input invitations_pk_columns_input {
  email: citext!
  orgId: uuid!
}

"""
select columns of table "invitations"
"""
enum invitations_select_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  email

  """column name"""
  orgId

  """column name"""
  role

  """column name"""
  status

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

"""
input type for updating data in table "invitations"
"""
input invitations_set_input {
  createdAt: timestamptz
  createdBy: uuid
  email: citext
  orgId: uuid
  role: String
  status: status_enum
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
Streaming cursor of the table "invitations"
"""
input invitations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: invitations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input invitations_stream_cursor_value_input {
  createdAt: timestamptz
  createdBy: uuid
  email: citext
  orgId: uuid
  role: String
  status: status_enum
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
update columns of table "invitations"
"""
enum invitations_update_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  email

  """column name"""
  orgId

  """column name"""
  role

  """column name"""
  status

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

input invitations_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: invitations_set_input

  """filter the rows which have to be updated"""
  where: invitations_bool_exp!
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""Table containing user's org and org's default_role"""
type memberships {
  createdAt: timestamptz!
  createdBy: uuid!
  orgId: uuid!

  """An object relationship"""
  organization: organizations!
  role: String!
  updatedAt: timestamptz!
  updatedBy: uuid!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "memberships"
"""
type memberships_aggregate {
  aggregate: memberships_aggregate_fields
  nodes: [memberships!]!
}

input memberships_aggregate_bool_exp {
  count: memberships_aggregate_bool_exp_count
}

input memberships_aggregate_bool_exp_count {
  arguments: [memberships_select_column!]
  distinct: Boolean
  filter: memberships_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "memberships"
"""
type memberships_aggregate_fields {
  count(columns: [memberships_select_column!], distinct: Boolean): Int!
  max: memberships_max_fields
  min: memberships_min_fields
}

"""
order by aggregate values of table "memberships"
"""
input memberships_aggregate_order_by {
  count: order_by
  max: memberships_max_order_by
  min: memberships_min_order_by
}

"""
input type for inserting array relation for remote table "memberships"
"""
input memberships_arr_rel_insert_input {
  data: [memberships_insert_input!]!

  """upsert condition"""
  on_conflict: memberships_on_conflict
}

"""
Boolean expression to filter rows from the table "memberships". All fields are combined with a logical 'AND'.
"""
input memberships_bool_exp {
  _and: [memberships_bool_exp!]
  _not: memberships_bool_exp
  _or: [memberships_bool_exp!]
  createdAt: timestamptz_comparison_exp
  createdBy: uuid_comparison_exp
  orgId: uuid_comparison_exp
  organization: organizations_bool_exp
  role: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: uuid_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "memberships"
"""
enum memberships_constraint {
  """
  unique or primary key constraint on columns "user_id", "org_id"
  """
  memberships_pkey
}

"""
input type for inserting data into table "memberships"
"""
input memberships_insert_input {
  createdAt: timestamptz
  createdBy: uuid
  orgId: uuid
  organization: organizations_obj_rel_insert_input
  role: String
  updatedAt: timestamptz
  updatedBy: uuid
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type memberships_max_fields {
  createdAt: timestamptz
  createdBy: uuid
  orgId: uuid
  role: String
  updatedAt: timestamptz
  updatedBy: uuid
  userId: uuid
}

"""
order by max() on columns of table "memberships"
"""
input memberships_max_order_by {
  createdAt: order_by
  createdBy: order_by
  orgId: order_by
  role: order_by
  updatedAt: order_by
  updatedBy: order_by
  userId: order_by
}

"""aggregate min on columns"""
type memberships_min_fields {
  createdAt: timestamptz
  createdBy: uuid
  orgId: uuid
  role: String
  updatedAt: timestamptz
  updatedBy: uuid
  userId: uuid
}

"""
order by min() on columns of table "memberships"
"""
input memberships_min_order_by {
  createdAt: order_by
  createdBy: order_by
  orgId: order_by
  role: order_by
  updatedAt: order_by
  updatedBy: order_by
  userId: order_by
}

"""
response of any mutation on the table "memberships"
"""
type memberships_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [memberships!]!
}

"""
on_conflict condition type for table "memberships"
"""
input memberships_on_conflict {
  constraint: memberships_constraint!
  update_columns: [memberships_update_column!]! = []
  where: memberships_bool_exp
}

"""Ordering options when selecting data from "memberships"."""
input memberships_order_by {
  createdAt: order_by
  createdBy: order_by
  orgId: order_by
  organization: organizations_order_by
  role: order_by
  updatedAt: order_by
  updatedBy: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: memberships"""
input memberships_pk_columns_input {
  orgId: uuid!
  userId: uuid!
}

"""
select columns of table "memberships"
"""
enum memberships_select_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  orgId

  """column name"""
  role

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  userId
}

"""
input type for updating data in table "memberships"
"""
input memberships_set_input {
  createdAt: timestamptz
  createdBy: uuid
  orgId: uuid
  role: String
  updatedAt: timestamptz
  updatedBy: uuid
  userId: uuid
}

"""
Streaming cursor of the table "memberships"
"""
input memberships_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: memberships_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input memberships_stream_cursor_value_input {
  createdAt: timestamptz
  createdBy: uuid
  orgId: uuid
  role: String
  updatedAt: timestamptz
  updatedBy: uuid
  userId: uuid
}

"""
update columns of table "memberships"
"""
enum memberships_update_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  orgId

  """column name"""
  role

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  userId
}

input memberships_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: memberships_set_input

  """filter the rows which have to be updated"""
  where: memberships_bool_exp!
}

"""mutation root"""
type mutation_root {
  """
  delete single row from the table: "auth.providers"
  """
  deleteAuthProvider(id: String!): authProviders

  """
  delete single row from the table: "auth.provider_requests"
  """
  deleteAuthProviderRequest(id: uuid!): authProviderRequests

  """
  delete data from the table: "auth.provider_requests"
  """
  deleteAuthProviderRequests(
    """filter the rows which have to be deleted"""
    where: authProviderRequests_bool_exp!
  ): authProviderRequests_mutation_response

  """
  delete data from the table: "auth.providers"
  """
  deleteAuthProviders(
    """filter the rows which have to be deleted"""
    where: authProviders_bool_exp!
  ): authProviders_mutation_response

  """
  delete single row from the table: "auth.refresh_tokens"
  """
  deleteAuthRefreshToken(id: uuid!): authRefreshTokens

  """
  delete single row from the table: "auth.refresh_token_types"
  """
  deleteAuthRefreshTokenType(value: String!): authRefreshTokenTypes

  """
  delete data from the table: "auth.refresh_token_types"
  """
  deleteAuthRefreshTokenTypes(
    """filter the rows which have to be deleted"""
    where: authRefreshTokenTypes_bool_exp!
  ): authRefreshTokenTypes_mutation_response

  """
  delete data from the table: "auth.refresh_tokens"
  """
  deleteAuthRefreshTokens(
    """filter the rows which have to be deleted"""
    where: authRefreshTokens_bool_exp!
  ): authRefreshTokens_mutation_response

  """
  delete single row from the table: "auth.roles"
  """
  deleteAuthRole(role: String!): authRoles

  """
  delete data from the table: "auth.roles"
  """
  deleteAuthRoles(
    """filter the rows which have to be deleted"""
    where: authRoles_bool_exp!
  ): authRoles_mutation_response

  """
  delete single row from the table: "auth.user_providers"
  """
  deleteAuthUserProvider(id: uuid!): authUserProviders

  """
  delete data from the table: "auth.user_providers"
  """
  deleteAuthUserProviders(
    """filter the rows which have to be deleted"""
    where: authUserProviders_bool_exp!
  ): authUserProviders_mutation_response

  """
  delete single row from the table: "auth.user_roles"
  """
  deleteAuthUserRole(id: uuid!): authUserRoles

  """
  delete data from the table: "auth.user_roles"
  """
  deleteAuthUserRoles(
    """filter the rows which have to be deleted"""
    where: authUserRoles_bool_exp!
  ): authUserRoles_mutation_response

  """
  delete single row from the table: "auth.user_security_keys"
  """
  deleteAuthUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  delete data from the table: "auth.user_security_keys"
  """
  deleteAuthUserSecurityKeys(
    """filter the rows which have to be deleted"""
    where: authUserSecurityKeys_bool_exp!
  ): authUserSecurityKeys_mutation_response

  """
  delete single row from the table: "storage.buckets"
  """
  deleteBucket(id: String!): buckets

  """
  delete data from the table: "storage.buckets"
  """
  deleteBuckets(
    """filter the rows which have to be deleted"""
    where: buckets_bool_exp!
  ): buckets_mutation_response

  """
  delete single row from the table: "storage.files"
  """
  deleteFile(id: uuid!): files

  """
  delete data from the table: "storage.files"
  """
  deleteFiles(
    """filter the rows which have to be deleted"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  delete single row from the table: "auth.users"
  """
  deleteUser(id: uuid!): users

  """
  delete data from the table: "auth.users"
  """
  deleteUsers(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "storage.virus"
  """
  deleteVirus(id: uuid!): virus

  """
  delete data from the table: "storage.virus"
  """
  deleteViruses(
    """filter the rows which have to be deleted"""
    where: virus_bool_exp!
  ): virus_mutation_response

  """
  delete data from the table: "action"
  """
  delete_action(
    """filter the rows which have to be deleted"""
    where: action_bool_exp!
  ): action_mutation_response

  """
  delete single row from the table: "action"
  """
  delete_action_by_pk(value: String!): action

  """
  delete data from the table: "device_pools"
  """
  delete_device_pools(
    """filter the rows which have to be deleted"""
    where: device_pools_bool_exp!
  ): device_pools_mutation_response

  """
  delete single row from the table: "device_pools"
  """
  delete_device_pools_by_pk(deviceId: uuid!, poolId: uuid!): device_pools

  """
  delete data from the table: "devices"
  """
  delete_devices(
    """filter the rows which have to be deleted"""
    where: devices_bool_exp!
  ): devices_mutation_response

  """
  delete single row from the table: "devices"
  """
  delete_devices_by_pk(id: uuid!): devices

  """
  delete data from the table: "direction"
  """
  delete_direction(
    """filter the rows which have to be deleted"""
    where: direction_bool_exp!
  ): direction_mutation_response

  """
  delete single row from the table: "direction"
  """
  delete_direction_by_pk(value: String!): direction

  """
  delete data from the table: "groups"
  """
  delete_groups(
    """filter the rows which have to be deleted"""
    where: groups_bool_exp!
  ): groups_mutation_response

  """
  delete single row from the table: "groups"
  """
  delete_groups_by_pk(id: uuid!): groups

  """
  delete data from the table: "invitations"
  """
  delete_invitations(
    """filter the rows which have to be deleted"""
    where: invitations_bool_exp!
  ): invitations_mutation_response

  """
  delete single row from the table: "invitations"
  """
  delete_invitations_by_pk(email: citext!, orgId: uuid!): invitations

  """
  delete data from the table: "memberships"
  """
  delete_memberships(
    """filter the rows which have to be deleted"""
    where: memberships_bool_exp!
  ): memberships_mutation_response

  """
  delete single row from the table: "memberships"
  """
  delete_memberships_by_pk(orgId: uuid!, userId: uuid!): memberships

  """
  delete data from the table: "notification_status"
  """
  delete_notification_status(
    """filter the rows which have to be deleted"""
    where: notification_status_bool_exp!
  ): notification_status_mutation_response

  """
  delete single row from the table: "notification_status"
  """
  delete_notification_status_by_pk(value: String!): notification_status

  """
  delete data from the table: "notification_type"
  """
  delete_notification_type(
    """filter the rows which have to be deleted"""
    where: notification_type_bool_exp!
  ): notification_type_mutation_response

  """
  delete single row from the table: "notification_type"
  """
  delete_notification_type_by_pk(value: String!): notification_type

  """
  delete data from the table: "notifications"
  """
  delete_notifications(
    """filter the rows which have to be deleted"""
    where: notifications_bool_exp!
  ): notifications_mutation_response

  """
  delete single row from the table: "notifications"
  """
  delete_notifications_by_pk(id: uuid!): notifications

  """
  delete data from the table: "org_settings"
  """
  delete_org_settings(
    """filter the rows which have to be deleted"""
    where: org_settings_bool_exp!
  ): org_settings_mutation_response

  """
  delete single row from the table: "org_settings"
  """
  delete_org_settings_by_pk(key: String!, orgId: uuid!): org_settings

  """
  delete data from the table: "organizations"
  """
  delete_organizations(
    """filter the rows which have to be deleted"""
    where: organizations_bool_exp!
  ): organizations_mutation_response

  """
  delete single row from the table: "organizations"
  """
  delete_organizations_by_pk(id: uuid!): organizations

  """
  delete data from the table: "plan"
  """
  delete_plan(
    """filter the rows which have to be deleted"""
    where: plan_bool_exp!
  ): plan_mutation_response

  """
  delete single row from the table: "plan"
  """
  delete_plan_by_pk(value: String!): plan

  """
  delete data from the table: "policies"
  """
  delete_policies(
    """filter the rows which have to be deleted"""
    where: policies_bool_exp!
  ): policies_mutation_response

  """
  delete single row from the table: "policies"
  """
  delete_policies_by_pk(id: uuid!): policies

  """
  delete data from the table: "pools"
  """
  delete_pools(
    """filter the rows which have to be deleted"""
    where: pools_bool_exp!
  ): pools_mutation_response

  """
  delete single row from the table: "pools"
  """
  delete_pools_by_pk(id: uuid!): pools

  """
  delete data from the table: "protocol"
  """
  delete_protocol(
    """filter the rows which have to be deleted"""
    where: protocol_bool_exp!
  ): protocol_mutation_response

  """
  delete single row from the table: "protocol"
  """
  delete_protocol_by_pk(value: String!): protocol

  """
  delete data from the table: "rules"
  """
  delete_rules(
    """filter the rows which have to be deleted"""
    where: rules_bool_exp!
  ): rules_mutation_response

  """
  delete single row from the table: "rules"
  """
  delete_rules_by_pk(id: uuid!): rules

  """
  delete data from the table: "setting_type"
  """
  delete_setting_type(
    """filter the rows which have to be deleted"""
    where: setting_type_bool_exp!
  ): setting_type_mutation_response

  """
  delete single row from the table: "setting_type"
  """
  delete_setting_type_by_pk(value: String!): setting_type

  """
  delete data from the table: "settings_metadata"
  """
  delete_settings_metadata(
    """filter the rows which have to be deleted"""
    where: settings_metadata_bool_exp!
  ): settings_metadata_mutation_response

  """
  delete single row from the table: "settings_metadata"
  """
  delete_settings_metadata_by_pk(key: String!): settings_metadata

  """
  delete data from the table: "status"
  """
  delete_status(
    """filter the rows which have to be deleted"""
    where: status_bool_exp!
  ): status_mutation_response

  """
  delete single row from the table: "status"
  """
  delete_status_by_pk(value: String!): status

  """
  delete data from the table: "subject_type"
  """
  delete_subject_type(
    """filter the rows which have to be deleted"""
    where: subject_type_bool_exp!
  ): subject_type_mutation_response

  """
  delete single row from the table: "subject_type"
  """
  delete_subject_type_by_pk(value: String!): subject_type

  """
  delete data from the table: "subscriptions"
  """
  delete_subscriptions(
    """filter the rows which have to be deleted"""
    where: subscriptions_bool_exp!
  ): subscriptions_mutation_response

  """
  delete single row from the table: "subscriptions"
  """
  delete_subscriptions_by_pk(id: uuid!): subscriptions

  """
  delete data from the table: "user_groups"
  """
  delete_user_groups(
    """filter the rows which have to be deleted"""
    where: user_groups_bool_exp!
  ): user_groups_mutation_response

  """
  delete single row from the table: "user_groups"
  """
  delete_user_groups_by_pk(groupId: uuid!, userId: uuid!): user_groups

  """
  delete data from the table: "user_notifications"
  """
  delete_user_notifications(
    """filter the rows which have to be deleted"""
    where: user_notifications_bool_exp!
  ): user_notifications_mutation_response

  """
  delete single row from the table: "user_notifications"
  """
  delete_user_notifications_by_pk(notificationId: uuid!, userId: uuid!): user_notifications

  """
  delete data from the table: "user_settings"
  """
  delete_user_settings(
    """filter the rows which have to be deleted"""
    where: user_settings_bool_exp!
  ): user_settings_mutation_response

  """
  delete single row from the table: "user_settings"
  """
  delete_user_settings_by_pk(key: String!, orgId: uuid!, user_id: uuid!): user_settings

  """
  insert a single row into the table: "auth.providers"
  """
  insertAuthProvider(
    """the row to be inserted"""
    object: authProviders_insert_input!

    """upsert condition"""
    on_conflict: authProviders_on_conflict
  ): authProviders

  """
  insert a single row into the table: "auth.provider_requests"
  """
  insertAuthProviderRequest(
    """the row to be inserted"""
    object: authProviderRequests_insert_input!

    """upsert condition"""
    on_conflict: authProviderRequests_on_conflict
  ): authProviderRequests

  """
  insert data into the table: "auth.provider_requests"
  """
  insertAuthProviderRequests(
    """the rows to be inserted"""
    objects: [authProviderRequests_insert_input!]!

    """upsert condition"""
    on_conflict: authProviderRequests_on_conflict
  ): authProviderRequests_mutation_response

  """
  insert data into the table: "auth.providers"
  """
  insertAuthProviders(
    """the rows to be inserted"""
    objects: [authProviders_insert_input!]!

    """upsert condition"""
    on_conflict: authProviders_on_conflict
  ): authProviders_mutation_response

  """
  insert a single row into the table: "auth.refresh_tokens"
  """
  insertAuthRefreshToken(
    """the row to be inserted"""
    object: authRefreshTokens_insert_input!

    """upsert condition"""
    on_conflict: authRefreshTokens_on_conflict
  ): authRefreshTokens

  """
  insert a single row into the table: "auth.refresh_token_types"
  """
  insertAuthRefreshTokenType(
    """the row to be inserted"""
    object: authRefreshTokenTypes_insert_input!

    """upsert condition"""
    on_conflict: authRefreshTokenTypes_on_conflict
  ): authRefreshTokenTypes

  """
  insert data into the table: "auth.refresh_token_types"
  """
  insertAuthRefreshTokenTypes(
    """the rows to be inserted"""
    objects: [authRefreshTokenTypes_insert_input!]!

    """upsert condition"""
    on_conflict: authRefreshTokenTypes_on_conflict
  ): authRefreshTokenTypes_mutation_response

  """
  insert data into the table: "auth.refresh_tokens"
  """
  insertAuthRefreshTokens(
    """the rows to be inserted"""
    objects: [authRefreshTokens_insert_input!]!

    """upsert condition"""
    on_conflict: authRefreshTokens_on_conflict
  ): authRefreshTokens_mutation_response

  """
  insert a single row into the table: "auth.roles"
  """
  insertAuthRole(
    """the row to be inserted"""
    object: authRoles_insert_input!

    """upsert condition"""
    on_conflict: authRoles_on_conflict
  ): authRoles

  """
  insert data into the table: "auth.roles"
  """
  insertAuthRoles(
    """the rows to be inserted"""
    objects: [authRoles_insert_input!]!

    """upsert condition"""
    on_conflict: authRoles_on_conflict
  ): authRoles_mutation_response

  """
  insert a single row into the table: "auth.user_providers"
  """
  insertAuthUserProvider(
    """the row to be inserted"""
    object: authUserProviders_insert_input!

    """upsert condition"""
    on_conflict: authUserProviders_on_conflict
  ): authUserProviders

  """
  insert data into the table: "auth.user_providers"
  """
  insertAuthUserProviders(
    """the rows to be inserted"""
    objects: [authUserProviders_insert_input!]!

    """upsert condition"""
    on_conflict: authUserProviders_on_conflict
  ): authUserProviders_mutation_response

  """
  insert a single row into the table: "auth.user_roles"
  """
  insertAuthUserRole(
    """the row to be inserted"""
    object: authUserRoles_insert_input!

    """upsert condition"""
    on_conflict: authUserRoles_on_conflict
  ): authUserRoles

  """
  insert data into the table: "auth.user_roles"
  """
  insertAuthUserRoles(
    """the rows to be inserted"""
    objects: [authUserRoles_insert_input!]!

    """upsert condition"""
    on_conflict: authUserRoles_on_conflict
  ): authUserRoles_mutation_response

  """
  insert a single row into the table: "auth.user_security_keys"
  """
  insertAuthUserSecurityKey(
    """the row to be inserted"""
    object: authUserSecurityKeys_insert_input!

    """upsert condition"""
    on_conflict: authUserSecurityKeys_on_conflict
  ): authUserSecurityKeys

  """
  insert data into the table: "auth.user_security_keys"
  """
  insertAuthUserSecurityKeys(
    """the rows to be inserted"""
    objects: [authUserSecurityKeys_insert_input!]!

    """upsert condition"""
    on_conflict: authUserSecurityKeys_on_conflict
  ): authUserSecurityKeys_mutation_response

  """
  insert a single row into the table: "storage.buckets"
  """
  insertBucket(
    """the row to be inserted"""
    object: buckets_insert_input!

    """upsert condition"""
    on_conflict: buckets_on_conflict
  ): buckets

  """
  insert data into the table: "storage.buckets"
  """
  insertBuckets(
    """the rows to be inserted"""
    objects: [buckets_insert_input!]!

    """upsert condition"""
    on_conflict: buckets_on_conflict
  ): buckets_mutation_response

  """
  insert a single row into the table: "storage.files"
  """
  insertFile(
    """the row to be inserted"""
    object: files_insert_input!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files

  """
  insert data into the table: "storage.files"
  """
  insertFiles(
    """the rows to be inserted"""
    objects: [files_insert_input!]!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files_mutation_response

  """
  insert a single row into the table: "auth.users"
  """
  insertUser(
    """the row to be inserted"""
    object: users_insert_input!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "auth.users"
  """
  insertUsers(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "storage.virus"
  """
  insertVirus(
    """the row to be inserted"""
    object: virus_insert_input!

    """upsert condition"""
    on_conflict: virus_on_conflict
  ): virus

  """
  insert data into the table: "storage.virus"
  """
  insertViruses(
    """the rows to be inserted"""
    objects: [virus_insert_input!]!

    """upsert condition"""
    on_conflict: virus_on_conflict
  ): virus_mutation_response

  """
  insert data into the table: "action"
  """
  insert_action(
    """the rows to be inserted"""
    objects: [action_insert_input!]!

    """upsert condition"""
    on_conflict: action_on_conflict
  ): action_mutation_response

  """
  insert a single row into the table: "action"
  """
  insert_action_one(
    """the row to be inserted"""
    object: action_insert_input!

    """upsert condition"""
    on_conflict: action_on_conflict
  ): action

  """
  insert data into the table: "device_pools"
  """
  insert_device_pools(
    """the rows to be inserted"""
    objects: [device_pools_insert_input!]!

    """upsert condition"""
    on_conflict: device_pools_on_conflict
  ): device_pools_mutation_response

  """
  insert a single row into the table: "device_pools"
  """
  insert_device_pools_one(
    """the row to be inserted"""
    object: device_pools_insert_input!

    """upsert condition"""
    on_conflict: device_pools_on_conflict
  ): device_pools

  """
  insert data into the table: "devices"
  """
  insert_devices(
    """the rows to be inserted"""
    objects: [devices_insert_input!]!

    """upsert condition"""
    on_conflict: devices_on_conflict
  ): devices_mutation_response

  """
  insert a single row into the table: "devices"
  """
  insert_devices_one(
    """the row to be inserted"""
    object: devices_insert_input!

    """upsert condition"""
    on_conflict: devices_on_conflict
  ): devices

  """
  insert data into the table: "direction"
  """
  insert_direction(
    """the rows to be inserted"""
    objects: [direction_insert_input!]!

    """upsert condition"""
    on_conflict: direction_on_conflict
  ): direction_mutation_response

  """
  insert a single row into the table: "direction"
  """
  insert_direction_one(
    """the row to be inserted"""
    object: direction_insert_input!

    """upsert condition"""
    on_conflict: direction_on_conflict
  ): direction

  """
  insert data into the table: "groups"
  """
  insert_groups(
    """the rows to be inserted"""
    objects: [groups_insert_input!]!

    """upsert condition"""
    on_conflict: groups_on_conflict
  ): groups_mutation_response

  """
  insert a single row into the table: "groups"
  """
  insert_groups_one(
    """the row to be inserted"""
    object: groups_insert_input!

    """upsert condition"""
    on_conflict: groups_on_conflict
  ): groups

  """
  insert data into the table: "invitations"
  """
  insert_invitations(
    """the rows to be inserted"""
    objects: [invitations_insert_input!]!

    """upsert condition"""
    on_conflict: invitations_on_conflict
  ): invitations_mutation_response

  """
  insert a single row into the table: "invitations"
  """
  insert_invitations_one(
    """the row to be inserted"""
    object: invitations_insert_input!

    """upsert condition"""
    on_conflict: invitations_on_conflict
  ): invitations

  """
  insert data into the table: "memberships"
  """
  insert_memberships(
    """the rows to be inserted"""
    objects: [memberships_insert_input!]!

    """upsert condition"""
    on_conflict: memberships_on_conflict
  ): memberships_mutation_response

  """
  insert a single row into the table: "memberships"
  """
  insert_memberships_one(
    """the row to be inserted"""
    object: memberships_insert_input!

    """upsert condition"""
    on_conflict: memberships_on_conflict
  ): memberships

  """
  insert data into the table: "notification_status"
  """
  insert_notification_status(
    """the rows to be inserted"""
    objects: [notification_status_insert_input!]!

    """upsert condition"""
    on_conflict: notification_status_on_conflict
  ): notification_status_mutation_response

  """
  insert a single row into the table: "notification_status"
  """
  insert_notification_status_one(
    """the row to be inserted"""
    object: notification_status_insert_input!

    """upsert condition"""
    on_conflict: notification_status_on_conflict
  ): notification_status

  """
  insert data into the table: "notification_type"
  """
  insert_notification_type(
    """the rows to be inserted"""
    objects: [notification_type_insert_input!]!

    """upsert condition"""
    on_conflict: notification_type_on_conflict
  ): notification_type_mutation_response

  """
  insert a single row into the table: "notification_type"
  """
  insert_notification_type_one(
    """the row to be inserted"""
    object: notification_type_insert_input!

    """upsert condition"""
    on_conflict: notification_type_on_conflict
  ): notification_type

  """
  insert data into the table: "notifications"
  """
  insert_notifications(
    """the rows to be inserted"""
    objects: [notifications_insert_input!]!

    """upsert condition"""
    on_conflict: notifications_on_conflict
  ): notifications_mutation_response

  """
  insert a single row into the table: "notifications"
  """
  insert_notifications_one(
    """the row to be inserted"""
    object: notifications_insert_input!

    """upsert condition"""
    on_conflict: notifications_on_conflict
  ): notifications

  """
  insert data into the table: "org_settings"
  """
  insert_org_settings(
    """the rows to be inserted"""
    objects: [org_settings_insert_input!]!

    """upsert condition"""
    on_conflict: org_settings_on_conflict
  ): org_settings_mutation_response

  """
  insert a single row into the table: "org_settings"
  """
  insert_org_settings_one(
    """the row to be inserted"""
    object: org_settings_insert_input!

    """upsert condition"""
    on_conflict: org_settings_on_conflict
  ): org_settings

  """
  insert data into the table: "organizations"
  """
  insert_organizations(
    """the rows to be inserted"""
    objects: [organizations_insert_input!]!

    """upsert condition"""
    on_conflict: organizations_on_conflict
  ): organizations_mutation_response

  """
  insert a single row into the table: "organizations"
  """
  insert_organizations_one(
    """the row to be inserted"""
    object: organizations_insert_input!

    """upsert condition"""
    on_conflict: organizations_on_conflict
  ): organizations

  """
  insert data into the table: "plan"
  """
  insert_plan(
    """the rows to be inserted"""
    objects: [plan_insert_input!]!

    """upsert condition"""
    on_conflict: plan_on_conflict
  ): plan_mutation_response

  """
  insert a single row into the table: "plan"
  """
  insert_plan_one(
    """the row to be inserted"""
    object: plan_insert_input!

    """upsert condition"""
    on_conflict: plan_on_conflict
  ): plan

  """
  insert data into the table: "policies"
  """
  insert_policies(
    """the rows to be inserted"""
    objects: [policies_insert_input!]!

    """upsert condition"""
    on_conflict: policies_on_conflict
  ): policies_mutation_response

  """
  insert a single row into the table: "policies"
  """
  insert_policies_one(
    """the row to be inserted"""
    object: policies_insert_input!

    """upsert condition"""
    on_conflict: policies_on_conflict
  ): policies

  """
  insert data into the table: "pools"
  """
  insert_pools(
    """the rows to be inserted"""
    objects: [pools_insert_input!]!

    """upsert condition"""
    on_conflict: pools_on_conflict
  ): pools_mutation_response

  """
  insert a single row into the table: "pools"
  """
  insert_pools_one(
    """the row to be inserted"""
    object: pools_insert_input!

    """upsert condition"""
    on_conflict: pools_on_conflict
  ): pools

  """
  insert data into the table: "protocol"
  """
  insert_protocol(
    """the rows to be inserted"""
    objects: [protocol_insert_input!]!

    """upsert condition"""
    on_conflict: protocol_on_conflict
  ): protocol_mutation_response

  """
  insert a single row into the table: "protocol"
  """
  insert_protocol_one(
    """the row to be inserted"""
    object: protocol_insert_input!

    """upsert condition"""
    on_conflict: protocol_on_conflict
  ): protocol

  """
  insert data into the table: "rules"
  """
  insert_rules(
    """the rows to be inserted"""
    objects: [rules_insert_input!]!

    """upsert condition"""
    on_conflict: rules_on_conflict
  ): rules_mutation_response

  """
  insert a single row into the table: "rules"
  """
  insert_rules_one(
    """the row to be inserted"""
    object: rules_insert_input!

    """upsert condition"""
    on_conflict: rules_on_conflict
  ): rules

  """
  insert data into the table: "setting_type"
  """
  insert_setting_type(
    """the rows to be inserted"""
    objects: [setting_type_insert_input!]!

    """upsert condition"""
    on_conflict: setting_type_on_conflict
  ): setting_type_mutation_response

  """
  insert a single row into the table: "setting_type"
  """
  insert_setting_type_one(
    """the row to be inserted"""
    object: setting_type_insert_input!

    """upsert condition"""
    on_conflict: setting_type_on_conflict
  ): setting_type

  """
  insert data into the table: "settings_metadata"
  """
  insert_settings_metadata(
    """the rows to be inserted"""
    objects: [settings_metadata_insert_input!]!

    """upsert condition"""
    on_conflict: settings_metadata_on_conflict
  ): settings_metadata_mutation_response

  """
  insert a single row into the table: "settings_metadata"
  """
  insert_settings_metadata_one(
    """the row to be inserted"""
    object: settings_metadata_insert_input!

    """upsert condition"""
    on_conflict: settings_metadata_on_conflict
  ): settings_metadata

  """
  insert data into the table: "status"
  """
  insert_status(
    """the rows to be inserted"""
    objects: [status_insert_input!]!

    """upsert condition"""
    on_conflict: status_on_conflict
  ): status_mutation_response

  """
  insert a single row into the table: "status"
  """
  insert_status_one(
    """the row to be inserted"""
    object: status_insert_input!

    """upsert condition"""
    on_conflict: status_on_conflict
  ): status

  """
  insert data into the table: "subject_type"
  """
  insert_subject_type(
    """the rows to be inserted"""
    objects: [subject_type_insert_input!]!

    """upsert condition"""
    on_conflict: subject_type_on_conflict
  ): subject_type_mutation_response

  """
  insert a single row into the table: "subject_type"
  """
  insert_subject_type_one(
    """the row to be inserted"""
    object: subject_type_insert_input!

    """upsert condition"""
    on_conflict: subject_type_on_conflict
  ): subject_type

  """
  insert data into the table: "subscriptions"
  """
  insert_subscriptions(
    """the rows to be inserted"""
    objects: [subscriptions_insert_input!]!

    """upsert condition"""
    on_conflict: subscriptions_on_conflict
  ): subscriptions_mutation_response

  """
  insert a single row into the table: "subscriptions"
  """
  insert_subscriptions_one(
    """the row to be inserted"""
    object: subscriptions_insert_input!

    """upsert condition"""
    on_conflict: subscriptions_on_conflict
  ): subscriptions

  """
  insert data into the table: "user_groups"
  """
  insert_user_groups(
    """the rows to be inserted"""
    objects: [user_groups_insert_input!]!

    """upsert condition"""
    on_conflict: user_groups_on_conflict
  ): user_groups_mutation_response

  """
  insert a single row into the table: "user_groups"
  """
  insert_user_groups_one(
    """the row to be inserted"""
    object: user_groups_insert_input!

    """upsert condition"""
    on_conflict: user_groups_on_conflict
  ): user_groups

  """
  insert data into the table: "user_notifications"
  """
  insert_user_notifications(
    """the rows to be inserted"""
    objects: [user_notifications_insert_input!]!

    """upsert condition"""
    on_conflict: user_notifications_on_conflict
  ): user_notifications_mutation_response

  """
  insert a single row into the table: "user_notifications"
  """
  insert_user_notifications_one(
    """the row to be inserted"""
    object: user_notifications_insert_input!

    """upsert condition"""
    on_conflict: user_notifications_on_conflict
  ): user_notifications

  """
  insert data into the table: "user_settings"
  """
  insert_user_settings(
    """the rows to be inserted"""
    objects: [user_settings_insert_input!]!

    """upsert condition"""
    on_conflict: user_settings_on_conflict
  ): user_settings_mutation_response

  """
  insert a single row into the table: "user_settings"
  """
  insert_user_settings_one(
    """the row to be inserted"""
    object: user_settings_insert_input!

    """upsert condition"""
    on_conflict: user_settings_on_conflict
  ): user_settings

  """
  update single row of the table: "auth.providers"
  """
  updateAuthProvider(
    """sets the columns of the filtered rows to the given values"""
    _set: authProviders_set_input
    pk_columns: authProviders_pk_columns_input!
  ): authProviders

  """
  update single row of the table: "auth.provider_requests"
  """
  updateAuthProviderRequest(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authProviderRequests_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authProviderRequests_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: authProviderRequests_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authProviderRequests_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authProviderRequests_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authProviderRequests_set_input
    pk_columns: authProviderRequests_pk_columns_input!
  ): authProviderRequests

  """
  update data of the table: "auth.provider_requests"
  """
  updateAuthProviderRequests(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authProviderRequests_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authProviderRequests_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: authProviderRequests_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authProviderRequests_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authProviderRequests_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authProviderRequests_set_input

    """filter the rows which have to be updated"""
    where: authProviderRequests_bool_exp!
  ): authProviderRequests_mutation_response

  """
  update data of the table: "auth.providers"
  """
  updateAuthProviders(
    """sets the columns of the filtered rows to the given values"""
    _set: authProviders_set_input

    """filter the rows which have to be updated"""
    where: authProviders_bool_exp!
  ): authProviders_mutation_response

  """
  update single row of the table: "auth.refresh_tokens"
  """
  updateAuthRefreshToken(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authRefreshTokens_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authRefreshTokens_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: authRefreshTokens_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authRefreshTokens_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authRefreshTokens_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokens_set_input
    pk_columns: authRefreshTokens_pk_columns_input!
  ): authRefreshTokens

  """
  update single row of the table: "auth.refresh_token_types"
  """
  updateAuthRefreshTokenType(
    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokenTypes_set_input
    pk_columns: authRefreshTokenTypes_pk_columns_input!
  ): authRefreshTokenTypes

  """
  update data of the table: "auth.refresh_token_types"
  """
  updateAuthRefreshTokenTypes(
    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokenTypes_set_input

    """filter the rows which have to be updated"""
    where: authRefreshTokenTypes_bool_exp!
  ): authRefreshTokenTypes_mutation_response

  """
  update data of the table: "auth.refresh_tokens"
  """
  updateAuthRefreshTokens(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authRefreshTokens_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authRefreshTokens_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: authRefreshTokens_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authRefreshTokens_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authRefreshTokens_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokens_set_input

    """filter the rows which have to be updated"""
    where: authRefreshTokens_bool_exp!
  ): authRefreshTokens_mutation_response

  """
  update single row of the table: "auth.roles"
  """
  updateAuthRole(
    """sets the columns of the filtered rows to the given values"""
    _set: authRoles_set_input
    pk_columns: authRoles_pk_columns_input!
  ): authRoles

  """
  update data of the table: "auth.roles"
  """
  updateAuthRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: authRoles_set_input

    """filter the rows which have to be updated"""
    where: authRoles_bool_exp!
  ): authRoles_mutation_response

  """
  update single row of the table: "auth.user_providers"
  """
  updateAuthUserProvider(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserProviders_set_input
    pk_columns: authUserProviders_pk_columns_input!
  ): authUserProviders

  """
  update data of the table: "auth.user_providers"
  """
  updateAuthUserProviders(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserProviders_set_input

    """filter the rows which have to be updated"""
    where: authUserProviders_bool_exp!
  ): authUserProviders_mutation_response

  """
  update single row of the table: "auth.user_roles"
  """
  updateAuthUserRole(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserRoles_set_input
    pk_columns: authUserRoles_pk_columns_input!
  ): authUserRoles

  """
  update data of the table: "auth.user_roles"
  """
  updateAuthUserRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserRoles_set_input

    """filter the rows which have to be updated"""
    where: authUserRoles_bool_exp!
  ): authUserRoles_mutation_response

  """
  update single row of the table: "auth.user_security_keys"
  """
  updateAuthUserSecurityKey(
    """increments the numeric columns with given value of the filtered values"""
    _inc: authUserSecurityKeys_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: authUserSecurityKeys_set_input
    pk_columns: authUserSecurityKeys_pk_columns_input!
  ): authUserSecurityKeys

  """
  update data of the table: "auth.user_security_keys"
  """
  updateAuthUserSecurityKeys(
    """increments the numeric columns with given value of the filtered values"""
    _inc: authUserSecurityKeys_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: authUserSecurityKeys_set_input

    """filter the rows which have to be updated"""
    where: authUserSecurityKeys_bool_exp!
  ): authUserSecurityKeys_mutation_response

  """
  update single row of the table: "storage.buckets"
  """
  updateBucket(
    """increments the numeric columns with given value of the filtered values"""
    _inc: buckets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: buckets_set_input
    pk_columns: buckets_pk_columns_input!
  ): buckets

  """
  update data of the table: "storage.buckets"
  """
  updateBuckets(
    """increments the numeric columns with given value of the filtered values"""
    _inc: buckets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: buckets_set_input

    """filter the rows which have to be updated"""
    where: buckets_bool_exp!
  ): buckets_mutation_response

  """
  update single row of the table: "storage.files"
  """
  updateFile(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: files_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: files_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: files_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: files_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: files_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input
    pk_columns: files_pk_columns_input!
  ): files

  """
  update data of the table: "storage.files"
  """
  updateFiles(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: files_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: files_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: files_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: files_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: files_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input

    """filter the rows which have to be updated"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  update single row of the table: "auth.users"
  """
  updateUser(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update data of the table: "auth.users"
  """
  updateUsers(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "storage.virus"
  """
  updateVirus(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: virus_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: virus_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: virus_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: virus_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: virus_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: virus_set_input
    pk_columns: virus_pk_columns_input!
  ): virus

  """
  update data of the table: "storage.virus"
  """
  updateViruses(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: virus_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: virus_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: virus_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: virus_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: virus_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: virus_set_input

    """filter the rows which have to be updated"""
    where: virus_bool_exp!
  ): virus_mutation_response

  """
  update data of the table: "action"
  """
  update_action(
    """sets the columns of the filtered rows to the given values"""
    _set: action_set_input

    """filter the rows which have to be updated"""
    where: action_bool_exp!
  ): action_mutation_response

  """
  update single row of the table: "action"
  """
  update_action_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: action_set_input
    pk_columns: action_pk_columns_input!
  ): action

  """
  update multiples rows of table: "action"
  """
  update_action_many(
    """updates to execute, in order"""
    updates: [action_updates!]!
  ): [action_mutation_response]

  """
  update multiples rows of table: "auth.provider_requests"
  """
  update_authProviderRequests_many(
    """updates to execute, in order"""
    updates: [authProviderRequests_updates!]!
  ): [authProviderRequests_mutation_response]

  """
  update multiples rows of table: "auth.providers"
  """
  update_authProviders_many(
    """updates to execute, in order"""
    updates: [authProviders_updates!]!
  ): [authProviders_mutation_response]

  """
  update multiples rows of table: "auth.refresh_token_types"
  """
  update_authRefreshTokenTypes_many(
    """updates to execute, in order"""
    updates: [authRefreshTokenTypes_updates!]!
  ): [authRefreshTokenTypes_mutation_response]

  """
  update multiples rows of table: "auth.refresh_tokens"
  """
  update_authRefreshTokens_many(
    """updates to execute, in order"""
    updates: [authRefreshTokens_updates!]!
  ): [authRefreshTokens_mutation_response]

  """
  update multiples rows of table: "auth.roles"
  """
  update_authRoles_many(
    """updates to execute, in order"""
    updates: [authRoles_updates!]!
  ): [authRoles_mutation_response]

  """
  update multiples rows of table: "auth.user_providers"
  """
  update_authUserProviders_many(
    """updates to execute, in order"""
    updates: [authUserProviders_updates!]!
  ): [authUserProviders_mutation_response]

  """
  update multiples rows of table: "auth.user_roles"
  """
  update_authUserRoles_many(
    """updates to execute, in order"""
    updates: [authUserRoles_updates!]!
  ): [authUserRoles_mutation_response]

  """
  update multiples rows of table: "auth.user_security_keys"
  """
  update_authUserSecurityKeys_many(
    """updates to execute, in order"""
    updates: [authUserSecurityKeys_updates!]!
  ): [authUserSecurityKeys_mutation_response]

  """
  update multiples rows of table: "storage.buckets"
  """
  update_buckets_many(
    """updates to execute, in order"""
    updates: [buckets_updates!]!
  ): [buckets_mutation_response]

  """
  update data of the table: "device_pools"
  """
  update_device_pools(
    """sets the columns of the filtered rows to the given values"""
    _set: device_pools_set_input

    """filter the rows which have to be updated"""
    where: device_pools_bool_exp!
  ): device_pools_mutation_response

  """
  update single row of the table: "device_pools"
  """
  update_device_pools_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: device_pools_set_input
    pk_columns: device_pools_pk_columns_input!
  ): device_pools

  """
  update multiples rows of table: "device_pools"
  """
  update_device_pools_many(
    """updates to execute, in order"""
    updates: [device_pools_updates!]!
  ): [device_pools_mutation_response]

  """
  update data of the table: "devices"
  """
  update_devices(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: devices_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: devices_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: devices_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: devices_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: devices_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: devices_set_input

    """filter the rows which have to be updated"""
    where: devices_bool_exp!
  ): devices_mutation_response

  """
  update single row of the table: "devices"
  """
  update_devices_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: devices_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: devices_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: devices_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: devices_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: devices_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: devices_set_input
    pk_columns: devices_pk_columns_input!
  ): devices

  """
  update multiples rows of table: "devices"
  """
  update_devices_many(
    """updates to execute, in order"""
    updates: [devices_updates!]!
  ): [devices_mutation_response]

  """
  update data of the table: "direction"
  """
  update_direction(
    """sets the columns of the filtered rows to the given values"""
    _set: direction_set_input

    """filter the rows which have to be updated"""
    where: direction_bool_exp!
  ): direction_mutation_response

  """
  update single row of the table: "direction"
  """
  update_direction_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: direction_set_input
    pk_columns: direction_pk_columns_input!
  ): direction

  """
  update multiples rows of table: "direction"
  """
  update_direction_many(
    """updates to execute, in order"""
    updates: [direction_updates!]!
  ): [direction_mutation_response]

  """
  update multiples rows of table: "storage.files"
  """
  update_files_many(
    """updates to execute, in order"""
    updates: [files_updates!]!
  ): [files_mutation_response]

  """
  update data of the table: "groups"
  """
  update_groups(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: groups_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: groups_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: groups_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: groups_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: groups_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: groups_set_input

    """filter the rows which have to be updated"""
    where: groups_bool_exp!
  ): groups_mutation_response

  """
  update single row of the table: "groups"
  """
  update_groups_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: groups_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: groups_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: groups_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: groups_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: groups_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: groups_set_input
    pk_columns: groups_pk_columns_input!
  ): groups

  """
  update multiples rows of table: "groups"
  """
  update_groups_many(
    """updates to execute, in order"""
    updates: [groups_updates!]!
  ): [groups_mutation_response]

  """
  update data of the table: "invitations"
  """
  update_invitations(
    """sets the columns of the filtered rows to the given values"""
    _set: invitations_set_input

    """filter the rows which have to be updated"""
    where: invitations_bool_exp!
  ): invitations_mutation_response

  """
  update single row of the table: "invitations"
  """
  update_invitations_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: invitations_set_input
    pk_columns: invitations_pk_columns_input!
  ): invitations

  """
  update multiples rows of table: "invitations"
  """
  update_invitations_many(
    """updates to execute, in order"""
    updates: [invitations_updates!]!
  ): [invitations_mutation_response]

  """
  update data of the table: "memberships"
  """
  update_memberships(
    """sets the columns of the filtered rows to the given values"""
    _set: memberships_set_input

    """filter the rows which have to be updated"""
    where: memberships_bool_exp!
  ): memberships_mutation_response

  """
  update single row of the table: "memberships"
  """
  update_memberships_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: memberships_set_input
    pk_columns: memberships_pk_columns_input!
  ): memberships

  """
  update multiples rows of table: "memberships"
  """
  update_memberships_many(
    """updates to execute, in order"""
    updates: [memberships_updates!]!
  ): [memberships_mutation_response]

  """
  update data of the table: "notification_status"
  """
  update_notification_status(
    """sets the columns of the filtered rows to the given values"""
    _set: notification_status_set_input

    """filter the rows which have to be updated"""
    where: notification_status_bool_exp!
  ): notification_status_mutation_response

  """
  update single row of the table: "notification_status"
  """
  update_notification_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notification_status_set_input
    pk_columns: notification_status_pk_columns_input!
  ): notification_status

  """
  update multiples rows of table: "notification_status"
  """
  update_notification_status_many(
    """updates to execute, in order"""
    updates: [notification_status_updates!]!
  ): [notification_status_mutation_response]

  """
  update data of the table: "notification_type"
  """
  update_notification_type(
    """sets the columns of the filtered rows to the given values"""
    _set: notification_type_set_input

    """filter the rows which have to be updated"""
    where: notification_type_bool_exp!
  ): notification_type_mutation_response

  """
  update single row of the table: "notification_type"
  """
  update_notification_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notification_type_set_input
    pk_columns: notification_type_pk_columns_input!
  ): notification_type

  """
  update multiples rows of table: "notification_type"
  """
  update_notification_type_many(
    """updates to execute, in order"""
    updates: [notification_type_updates!]!
  ): [notification_type_mutation_response]

  """
  update data of the table: "notifications"
  """
  update_notifications(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: notifications_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: notifications_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: notifications_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: notifications_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: notifications_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: notifications_set_input

    """filter the rows which have to be updated"""
    where: notifications_bool_exp!
  ): notifications_mutation_response

  """
  update single row of the table: "notifications"
  """
  update_notifications_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: notifications_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: notifications_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: notifications_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: notifications_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: notifications_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: notifications_set_input
    pk_columns: notifications_pk_columns_input!
  ): notifications

  """
  update multiples rows of table: "notifications"
  """
  update_notifications_many(
    """updates to execute, in order"""
    updates: [notifications_updates!]!
  ): [notifications_mutation_response]

  """
  update data of the table: "org_settings"
  """
  update_org_settings(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: org_settings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: org_settings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: org_settings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: org_settings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: org_settings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: org_settings_set_input

    """filter the rows which have to be updated"""
    where: org_settings_bool_exp!
  ): org_settings_mutation_response

  """
  update single row of the table: "org_settings"
  """
  update_org_settings_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: org_settings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: org_settings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: org_settings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: org_settings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: org_settings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: org_settings_set_input
    pk_columns: org_settings_pk_columns_input!
  ): org_settings

  """
  update multiples rows of table: "org_settings"
  """
  update_org_settings_many(
    """updates to execute, in order"""
    updates: [org_settings_updates!]!
  ): [org_settings_mutation_response]

  """
  update data of the table: "organizations"
  """
  update_organizations(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: organizations_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: organizations_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: organizations_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: organizations_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: organizations_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: organizations_set_input

    """filter the rows which have to be updated"""
    where: organizations_bool_exp!
  ): organizations_mutation_response

  """
  update single row of the table: "organizations"
  """
  update_organizations_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: organizations_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: organizations_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: organizations_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: organizations_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: organizations_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: organizations_set_input
    pk_columns: organizations_pk_columns_input!
  ): organizations

  """
  update multiples rows of table: "organizations"
  """
  update_organizations_many(
    """updates to execute, in order"""
    updates: [organizations_updates!]!
  ): [organizations_mutation_response]

  """
  update data of the table: "plan"
  """
  update_plan(
    """sets the columns of the filtered rows to the given values"""
    _set: plan_set_input

    """filter the rows which have to be updated"""
    where: plan_bool_exp!
  ): plan_mutation_response

  """
  update single row of the table: "plan"
  """
  update_plan_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: plan_set_input
    pk_columns: plan_pk_columns_input!
  ): plan

  """
  update multiples rows of table: "plan"
  """
  update_plan_many(
    """updates to execute, in order"""
    updates: [plan_updates!]!
  ): [plan_mutation_response]

  """
  update data of the table: "policies"
  """
  update_policies(
    """increments the numeric columns with given value of the filtered values"""
    _inc: policies_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: policies_set_input

    """filter the rows which have to be updated"""
    where: policies_bool_exp!
  ): policies_mutation_response

  """
  update single row of the table: "policies"
  """
  update_policies_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: policies_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: policies_set_input
    pk_columns: policies_pk_columns_input!
  ): policies

  """
  update multiples rows of table: "policies"
  """
  update_policies_many(
    """updates to execute, in order"""
    updates: [policies_updates!]!
  ): [policies_mutation_response]

  """
  update data of the table: "pools"
  """
  update_pools(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: pools_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: pools_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: pools_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: pools_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: pools_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: pools_set_input

    """filter the rows which have to be updated"""
    where: pools_bool_exp!
  ): pools_mutation_response

  """
  update single row of the table: "pools"
  """
  update_pools_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: pools_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: pools_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: pools_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: pools_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: pools_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: pools_set_input
    pk_columns: pools_pk_columns_input!
  ): pools

  """
  update multiples rows of table: "pools"
  """
  update_pools_many(
    """updates to execute, in order"""
    updates: [pools_updates!]!
  ): [pools_mutation_response]

  """
  update data of the table: "protocol"
  """
  update_protocol(
    """sets the columns of the filtered rows to the given values"""
    _set: protocol_set_input

    """filter the rows which have to be updated"""
    where: protocol_bool_exp!
  ): protocol_mutation_response

  """
  update single row of the table: "protocol"
  """
  update_protocol_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: protocol_set_input
    pk_columns: protocol_pk_columns_input!
  ): protocol

  """
  update multiples rows of table: "protocol"
  """
  update_protocol_many(
    """updates to execute, in order"""
    updates: [protocol_updates!]!
  ): [protocol_mutation_response]

  """
  update data of the table: "rules"
  """
  update_rules(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: rules_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: rules_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: rules_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: rules_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: rules_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: rules_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: rules_set_input

    """filter the rows which have to be updated"""
    where: rules_bool_exp!
  ): rules_mutation_response

  """
  update single row of the table: "rules"
  """
  update_rules_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: rules_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: rules_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: rules_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: rules_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: rules_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: rules_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: rules_set_input
    pk_columns: rules_pk_columns_input!
  ): rules

  """
  update multiples rows of table: "rules"
  """
  update_rules_many(
    """updates to execute, in order"""
    updates: [rules_updates!]!
  ): [rules_mutation_response]

  """
  update data of the table: "setting_type"
  """
  update_setting_type(
    """sets the columns of the filtered rows to the given values"""
    _set: setting_type_set_input

    """filter the rows which have to be updated"""
    where: setting_type_bool_exp!
  ): setting_type_mutation_response

  """
  update single row of the table: "setting_type"
  """
  update_setting_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: setting_type_set_input
    pk_columns: setting_type_pk_columns_input!
  ): setting_type

  """
  update multiples rows of table: "setting_type"
  """
  update_setting_type_many(
    """updates to execute, in order"""
    updates: [setting_type_updates!]!
  ): [setting_type_mutation_response]

  """
  update data of the table: "settings_metadata"
  """
  update_settings_metadata(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: settings_metadata_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: settings_metadata_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: settings_metadata_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: settings_metadata_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: settings_metadata_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: settings_metadata_set_input

    """filter the rows which have to be updated"""
    where: settings_metadata_bool_exp!
  ): settings_metadata_mutation_response

  """
  update single row of the table: "settings_metadata"
  """
  update_settings_metadata_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: settings_metadata_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: settings_metadata_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: settings_metadata_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: settings_metadata_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: settings_metadata_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: settings_metadata_set_input
    pk_columns: settings_metadata_pk_columns_input!
  ): settings_metadata

  """
  update multiples rows of table: "settings_metadata"
  """
  update_settings_metadata_many(
    """updates to execute, in order"""
    updates: [settings_metadata_updates!]!
  ): [settings_metadata_mutation_response]

  """
  update data of the table: "status"
  """
  update_status(
    """sets the columns of the filtered rows to the given values"""
    _set: status_set_input

    """filter the rows which have to be updated"""
    where: status_bool_exp!
  ): status_mutation_response

  """
  update single row of the table: "status"
  """
  update_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: status_set_input
    pk_columns: status_pk_columns_input!
  ): status

  """
  update multiples rows of table: "status"
  """
  update_status_many(
    """updates to execute, in order"""
    updates: [status_updates!]!
  ): [status_mutation_response]

  """
  update data of the table: "subject_type"
  """
  update_subject_type(
    """sets the columns of the filtered rows to the given values"""
    _set: subject_type_set_input

    """filter the rows which have to be updated"""
    where: subject_type_bool_exp!
  ): subject_type_mutation_response

  """
  update single row of the table: "subject_type"
  """
  update_subject_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: subject_type_set_input
    pk_columns: subject_type_pk_columns_input!
  ): subject_type

  """
  update multiples rows of table: "subject_type"
  """
  update_subject_type_many(
    """updates to execute, in order"""
    updates: [subject_type_updates!]!
  ): [subject_type_mutation_response]

  """
  update data of the table: "subscriptions"
  """
  update_subscriptions(
    """increments the numeric columns with given value of the filtered values"""
    _inc: subscriptions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: subscriptions_set_input

    """filter the rows which have to be updated"""
    where: subscriptions_bool_exp!
  ): subscriptions_mutation_response

  """
  update single row of the table: "subscriptions"
  """
  update_subscriptions_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: subscriptions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: subscriptions_set_input
    pk_columns: subscriptions_pk_columns_input!
  ): subscriptions

  """
  update multiples rows of table: "subscriptions"
  """
  update_subscriptions_many(
    """updates to execute, in order"""
    updates: [subscriptions_updates!]!
  ): [subscriptions_mutation_response]

  """
  update data of the table: "user_groups"
  """
  update_user_groups(
    """sets the columns of the filtered rows to the given values"""
    _set: user_groups_set_input

    """filter the rows which have to be updated"""
    where: user_groups_bool_exp!
  ): user_groups_mutation_response

  """
  update single row of the table: "user_groups"
  """
  update_user_groups_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_groups_set_input
    pk_columns: user_groups_pk_columns_input!
  ): user_groups

  """
  update multiples rows of table: "user_groups"
  """
  update_user_groups_many(
    """updates to execute, in order"""
    updates: [user_groups_updates!]!
  ): [user_groups_mutation_response]

  """
  update data of the table: "user_notifications"
  """
  update_user_notifications(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: user_notifications_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: user_notifications_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: user_notifications_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: user_notifications_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: user_notifications_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_notifications_set_input

    """filter the rows which have to be updated"""
    where: user_notifications_bool_exp!
  ): user_notifications_mutation_response

  """
  update single row of the table: "user_notifications"
  """
  update_user_notifications_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: user_notifications_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: user_notifications_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: user_notifications_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: user_notifications_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: user_notifications_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_notifications_set_input
    pk_columns: user_notifications_pk_columns_input!
  ): user_notifications

  """
  update multiples rows of table: "user_notifications"
  """
  update_user_notifications_many(
    """updates to execute, in order"""
    updates: [user_notifications_updates!]!
  ): [user_notifications_mutation_response]

  """
  update data of the table: "user_settings"
  """
  update_user_settings(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: user_settings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: user_settings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: user_settings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: user_settings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: user_settings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_settings_set_input

    """filter the rows which have to be updated"""
    where: user_settings_bool_exp!
  ): user_settings_mutation_response

  """
  update single row of the table: "user_settings"
  """
  update_user_settings_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: user_settings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: user_settings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: user_settings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: user_settings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: user_settings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_settings_set_input
    pk_columns: user_settings_pk_columns_input!
  ): user_settings

  """
  update multiples rows of table: "user_settings"
  """
  update_user_settings_many(
    """updates to execute, in order"""
    updates: [user_settings_updates!]!
  ): [user_settings_mutation_response]

  """
  update multiples rows of table: "auth.users"
  """
  update_users_many(
    """updates to execute, in order"""
    updates: [users_updates!]!
  ): [users_mutation_response]

  """
  update multiples rows of table: "storage.virus"
  """
  update_virus_many(
    """updates to execute, in order"""
    updates: [virus_updates!]!
  ): [virus_mutation_response]
}

"""user notification status enum"""
type notification_status {
  description: String!
  value: String!
}

"""
aggregated selection of "notification_status"
"""
type notification_status_aggregate {
  aggregate: notification_status_aggregate_fields
  nodes: [notification_status!]!
}

"""
aggregate fields of "notification_status"
"""
type notification_status_aggregate_fields {
  count(columns: [notification_status_select_column!], distinct: Boolean): Int!
  max: notification_status_max_fields
  min: notification_status_min_fields
}

"""
Boolean expression to filter rows from the table "notification_status". All fields are combined with a logical 'AND'.
"""
input notification_status_bool_exp {
  _and: [notification_status_bool_exp!]
  _not: notification_status_bool_exp
  _or: [notification_status_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "notification_status"
"""
enum notification_status_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  notification_status_pkey
}

enum notification_status_enum {
  """ARCHIVED"""
  archived

  """READ"""
  read

  """UNREAD"""
  unread
}

"""
Boolean expression to compare columns of type "notification_status_enum". All fields are combined with logical 'AND'.
"""
input notification_status_enum_comparison_exp {
  _eq: notification_status_enum
  _in: [notification_status_enum!]
  _is_null: Boolean
  _neq: notification_status_enum
  _nin: [notification_status_enum!]
}

"""
input type for inserting data into table "notification_status"
"""
input notification_status_insert_input {
  description: String
  value: String
}

"""aggregate max on columns"""
type notification_status_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type notification_status_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "notification_status"
"""
type notification_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notification_status!]!
}

"""
on_conflict condition type for table "notification_status"
"""
input notification_status_on_conflict {
  constraint: notification_status_constraint!
  update_columns: [notification_status_update_column!]! = []
  where: notification_status_bool_exp
}

"""Ordering options when selecting data from "notification_status"."""
input notification_status_order_by {
  description: order_by
  value: order_by
}

"""primary key columns input for table: notification_status"""
input notification_status_pk_columns_input {
  value: String!
}

"""
select columns of table "notification_status"
"""
enum notification_status_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "notification_status"
"""
input notification_status_set_input {
  description: String
  value: String
}

"""
Streaming cursor of the table "notification_status"
"""
input notification_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notification_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notification_status_stream_cursor_value_input {
  description: String
  value: String
}

"""
update columns of table "notification_status"
"""
enum notification_status_update_column {
  """column name"""
  description

  """column name"""
  value
}

input notification_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notification_status_set_input

  """filter the rows which have to be updated"""
  where: notification_status_bool_exp!
}

"""notification type enum"""
type notification_type {
  description: String!
  value: String!
}

"""
aggregated selection of "notification_type"
"""
type notification_type_aggregate {
  aggregate: notification_type_aggregate_fields
  nodes: [notification_type!]!
}

"""
aggregate fields of "notification_type"
"""
type notification_type_aggregate_fields {
  count(columns: [notification_type_select_column!], distinct: Boolean): Int!
  max: notification_type_max_fields
  min: notification_type_min_fields
}

"""
Boolean expression to filter rows from the table "notification_type". All fields are combined with a logical 'AND'.
"""
input notification_type_bool_exp {
  _and: [notification_type_bool_exp!]
  _not: notification_type_bool_exp
  _or: [notification_type_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "notification_type"
"""
enum notification_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  notification_type_pkey
}

enum notification_type_enum {
  """ERROR"""
  error

  """INFO"""
  info

  """WARNING"""
  warning
}

"""
Boolean expression to compare columns of type "notification_type_enum". All fields are combined with logical 'AND'.
"""
input notification_type_enum_comparison_exp {
  _eq: notification_type_enum
  _in: [notification_type_enum!]
  _is_null: Boolean
  _neq: notification_type_enum
  _nin: [notification_type_enum!]
}

"""
input type for inserting data into table "notification_type"
"""
input notification_type_insert_input {
  description: String
  value: String
}

"""aggregate max on columns"""
type notification_type_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type notification_type_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "notification_type"
"""
type notification_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notification_type!]!
}

"""
on_conflict condition type for table "notification_type"
"""
input notification_type_on_conflict {
  constraint: notification_type_constraint!
  update_columns: [notification_type_update_column!]! = []
  where: notification_type_bool_exp
}

"""Ordering options when selecting data from "notification_type"."""
input notification_type_order_by {
  description: order_by
  value: order_by
}

"""primary key columns input for table: notification_type"""
input notification_type_pk_columns_input {
  value: String!
}

"""
select columns of table "notification_type"
"""
enum notification_type_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "notification_type"
"""
input notification_type_set_input {
  description: String
  value: String
}

"""
Streaming cursor of the table "notification_type"
"""
input notification_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notification_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notification_type_stream_cursor_value_input {
  description: String
  value: String
}

"""
update columns of table "notification_type"
"""
enum notification_type_update_column {
  """column name"""
  description

  """column name"""
  value
}

input notification_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notification_type_set_input

  """filter the rows which have to be updated"""
  where: notification_type_bool_exp!
}

"""Table to store the notifications triggered by the application"""
type notifications {
  createdAt: timestamptz!
  createdBy: uuid!
  description: String
  displayName: String!
  id: uuid!
  message: String!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  orgId: uuid

  """An object relationship"""
  organization: organizations
  tags: [String!]
  title: String!
  type: notification_type_enum!
  updatedAt: timestamptz!
  updatedBy: uuid!
}

"""
aggregated selection of "notifications"
"""
type notifications_aggregate {
  aggregate: notifications_aggregate_fields
  nodes: [notifications!]!
}

input notifications_aggregate_bool_exp {
  count: notifications_aggregate_bool_exp_count
}

input notifications_aggregate_bool_exp_count {
  arguments: [notifications_select_column!]
  distinct: Boolean
  filter: notifications_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "notifications"
"""
type notifications_aggregate_fields {
  count(columns: [notifications_select_column!], distinct: Boolean): Int!
  max: notifications_max_fields
  min: notifications_min_fields
}

"""
order by aggregate values of table "notifications"
"""
input notifications_aggregate_order_by {
  count: order_by
  max: notifications_max_order_by
  min: notifications_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input notifications_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "notifications"
"""
input notifications_arr_rel_insert_input {
  data: [notifications_insert_input!]!

  """upsert condition"""
  on_conflict: notifications_on_conflict
}

"""
Boolean expression to filter rows from the table "notifications". All fields are combined with a logical 'AND'.
"""
input notifications_bool_exp {
  _and: [notifications_bool_exp!]
  _not: notifications_bool_exp
  _or: [notifications_bool_exp!]
  createdAt: timestamptz_comparison_exp
  createdBy: uuid_comparison_exp
  description: String_comparison_exp
  displayName: String_comparison_exp
  id: uuid_comparison_exp
  message: String_comparison_exp
  metadata: jsonb_comparison_exp
  orgId: uuid_comparison_exp
  organization: organizations_bool_exp
  tags: String_array_comparison_exp
  title: String_comparison_exp
  type: notification_type_enum_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: uuid_comparison_exp
}

"""
unique or primary key constraints on table "notifications"
"""
enum notifications_constraint {
  """
  unique or primary key constraint on columns "display_name", "org_id"
  """
  notifications_org_id_display_name_key

  """
  unique or primary key constraint on columns "id"
  """
  notifications_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input notifications_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input notifications_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input notifications_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "notifications"
"""
input notifications_insert_input {
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  message: String
  metadata: jsonb
  orgId: uuid
  organization: organizations_obj_rel_insert_input
  tags: [String!]
  title: String
  type: notification_type_enum
  updatedAt: timestamptz
  updatedBy: uuid
}

"""aggregate max on columns"""
type notifications_max_fields {
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  message: String
  orgId: uuid
  tags: [String!]
  title: String
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
order by max() on columns of table "notifications"
"""
input notifications_max_order_by {
  createdAt: order_by
  createdBy: order_by
  description: order_by
  displayName: order_by
  id: order_by
  message: order_by
  orgId: order_by
  tags: order_by
  title: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""aggregate min on columns"""
type notifications_min_fields {
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  message: String
  orgId: uuid
  tags: [String!]
  title: String
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
order by min() on columns of table "notifications"
"""
input notifications_min_order_by {
  createdAt: order_by
  createdBy: order_by
  description: order_by
  displayName: order_by
  id: order_by
  message: order_by
  orgId: order_by
  tags: order_by
  title: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""
response of any mutation on the table "notifications"
"""
type notifications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notifications!]!
}

"""
input type for inserting object relation for remote table "notifications"
"""
input notifications_obj_rel_insert_input {
  data: notifications_insert_input!

  """upsert condition"""
  on_conflict: notifications_on_conflict
}

"""
on_conflict condition type for table "notifications"
"""
input notifications_on_conflict {
  constraint: notifications_constraint!
  update_columns: [notifications_update_column!]! = []
  where: notifications_bool_exp
}

"""Ordering options when selecting data from "notifications"."""
input notifications_order_by {
  createdAt: order_by
  createdBy: order_by
  description: order_by
  displayName: order_by
  id: order_by
  message: order_by
  metadata: order_by
  orgId: order_by
  organization: organizations_order_by
  tags: order_by
  title: order_by
  type: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""primary key columns input for table: notifications"""
input notifications_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input notifications_prepend_input {
  metadata: jsonb
}

"""
select columns of table "notifications"
"""
enum notifications_select_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  message

  """column name"""
  metadata

  """column name"""
  orgId

  """column name"""
  tags

  """column name"""
  title

  """column name"""
  type

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

"""
input type for updating data in table "notifications"
"""
input notifications_set_input {
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  message: String
  metadata: jsonb
  orgId: uuid
  tags: [String!]
  title: String
  type: notification_type_enum
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
Streaming cursor of the table "notifications"
"""
input notifications_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notifications_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notifications_stream_cursor_value_input {
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  message: String
  metadata: jsonb
  orgId: uuid
  tags: [String!]
  title: String
  type: notification_type_enum
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
update columns of table "notifications"
"""
enum notifications_update_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  message

  """column name"""
  metadata

  """column name"""
  orgId

  """column name"""
  tags

  """column name"""
  title

  """column name"""
  type

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

input notifications_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: notifications_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: notifications_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: notifications_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: notifications_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: notifications_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: notifications_set_input

  """filter the rows which have to be updated"""
  where: notifications_bool_exp!
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""Table containing organization's settings and feature flags"""
type org_settings {
  createdAt: timestamptz!
  createdBy: uuid!
  key: String!
  orgId: uuid!
  updatedAt: timestamptz!
  updatedBy: uuid!
  value(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "org_settings"
"""
type org_settings_aggregate {
  aggregate: org_settings_aggregate_fields
  nodes: [org_settings!]!
}

input org_settings_aggregate_bool_exp {
  count: org_settings_aggregate_bool_exp_count
}

input org_settings_aggregate_bool_exp_count {
  arguments: [org_settings_select_column!]
  distinct: Boolean
  filter: org_settings_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "org_settings"
"""
type org_settings_aggregate_fields {
  count(columns: [org_settings_select_column!], distinct: Boolean): Int!
  max: org_settings_max_fields
  min: org_settings_min_fields
}

"""
order by aggregate values of table "org_settings"
"""
input org_settings_aggregate_order_by {
  count: order_by
  max: org_settings_max_order_by
  min: org_settings_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input org_settings_append_input {
  value: jsonb
}

"""
input type for inserting array relation for remote table "org_settings"
"""
input org_settings_arr_rel_insert_input {
  data: [org_settings_insert_input!]!

  """upsert condition"""
  on_conflict: org_settings_on_conflict
}

"""
Boolean expression to filter rows from the table "org_settings". All fields are combined with a logical 'AND'.
"""
input org_settings_bool_exp {
  _and: [org_settings_bool_exp!]
  _not: org_settings_bool_exp
  _or: [org_settings_bool_exp!]
  createdAt: timestamptz_comparison_exp
  createdBy: uuid_comparison_exp
  key: String_comparison_exp
  orgId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: uuid_comparison_exp
  value: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "org_settings"
"""
enum org_settings_constraint {
  """
  unique or primary key constraint on columns "key", "org_id"
  """
  org_settings_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input org_settings_delete_at_path_input {
  value: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input org_settings_delete_elem_input {
  value: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input org_settings_delete_key_input {
  value: String
}

"""
input type for inserting data into table "org_settings"
"""
input org_settings_insert_input {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
  value: jsonb
}

"""aggregate max on columns"""
type org_settings_max_fields {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
order by max() on columns of table "org_settings"
"""
input org_settings_max_order_by {
  createdAt: order_by
  createdBy: order_by
  key: order_by
  orgId: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""aggregate min on columns"""
type org_settings_min_fields {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
order by min() on columns of table "org_settings"
"""
input org_settings_min_order_by {
  createdAt: order_by
  createdBy: order_by
  key: order_by
  orgId: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""
response of any mutation on the table "org_settings"
"""
type org_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [org_settings!]!
}

"""
on_conflict condition type for table "org_settings"
"""
input org_settings_on_conflict {
  constraint: org_settings_constraint!
  update_columns: [org_settings_update_column!]! = []
  where: org_settings_bool_exp
}

"""Ordering options when selecting data from "org_settings"."""
input org_settings_order_by {
  createdAt: order_by
  createdBy: order_by
  key: order_by
  orgId: order_by
  updatedAt: order_by
  updatedBy: order_by
  value: order_by
}

"""primary key columns input for table: org_settings"""
input org_settings_pk_columns_input {
  key: String!
  orgId: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input org_settings_prepend_input {
  value: jsonb
}

"""
select columns of table "org_settings"
"""
enum org_settings_select_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  key

  """column name"""
  orgId

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  value
}

"""
input type for updating data in table "org_settings"
"""
input org_settings_set_input {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
  value: jsonb
}

"""
Streaming cursor of the table "org_settings"
"""
input org_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: org_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input org_settings_stream_cursor_value_input {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
  value: jsonb
}

"""
update columns of table "org_settings"
"""
enum org_settings_update_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  key

  """column name"""
  orgId

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  value
}

input org_settings_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: org_settings_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: org_settings_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: org_settings_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: org_settings_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: org_settings_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: org_settings_set_input

  """filter the rows which have to be updated"""
  where: org_settings_bool_exp!
}

"""
View that expand public.org_setting table with missing key/values from public.settings_metadata
"""
type org_settings_with_defaults {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
  value(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "org_settings_with_defaults"
"""
type org_settings_with_defaults_aggregate {
  aggregate: org_settings_with_defaults_aggregate_fields
  nodes: [org_settings_with_defaults!]!
}

input org_settings_with_defaults_aggregate_bool_exp {
  count: org_settings_with_defaults_aggregate_bool_exp_count
}

input org_settings_with_defaults_aggregate_bool_exp_count {
  arguments: [org_settings_with_defaults_select_column!]
  distinct: Boolean
  filter: org_settings_with_defaults_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "org_settings_with_defaults"
"""
type org_settings_with_defaults_aggregate_fields {
  count(columns: [org_settings_with_defaults_select_column!], distinct: Boolean): Int!
  max: org_settings_with_defaults_max_fields
  min: org_settings_with_defaults_min_fields
}

"""
order by aggregate values of table "org_settings_with_defaults"
"""
input org_settings_with_defaults_aggregate_order_by {
  count: order_by
  max: org_settings_with_defaults_max_order_by
  min: org_settings_with_defaults_min_order_by
}

"""
input type for inserting array relation for remote table "org_settings_with_defaults"
"""
input org_settings_with_defaults_arr_rel_insert_input {
  data: [org_settings_with_defaults_insert_input!]!
}

"""
Boolean expression to filter rows from the table "org_settings_with_defaults". All fields are combined with a logical 'AND'.
"""
input org_settings_with_defaults_bool_exp {
  _and: [org_settings_with_defaults_bool_exp!]
  _not: org_settings_with_defaults_bool_exp
  _or: [org_settings_with_defaults_bool_exp!]
  createdAt: timestamptz_comparison_exp
  createdBy: uuid_comparison_exp
  key: String_comparison_exp
  orgId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: uuid_comparison_exp
  value: jsonb_comparison_exp
}

"""
input type for inserting data into table "org_settings_with_defaults"
"""
input org_settings_with_defaults_insert_input {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
  value: jsonb
}

"""aggregate max on columns"""
type org_settings_with_defaults_max_fields {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
order by max() on columns of table "org_settings_with_defaults"
"""
input org_settings_with_defaults_max_order_by {
  createdAt: order_by
  createdBy: order_by
  key: order_by
  orgId: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""aggregate min on columns"""
type org_settings_with_defaults_min_fields {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
order by min() on columns of table "org_settings_with_defaults"
"""
input org_settings_with_defaults_min_order_by {
  createdAt: order_by
  createdBy: order_by
  key: order_by
  orgId: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""
Ordering options when selecting data from "org_settings_with_defaults".
"""
input org_settings_with_defaults_order_by {
  createdAt: order_by
  createdBy: order_by
  key: order_by
  orgId: order_by
  updatedAt: order_by
  updatedBy: order_by
  value: order_by
}

"""
select columns of table "org_settings_with_defaults"
"""
enum org_settings_with_defaults_select_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  key

  """column name"""
  orgId

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  value
}

"""
Streaming cursor of the table "org_settings_with_defaults"
"""
input org_settings_with_defaults_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: org_settings_with_defaults_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input org_settings_with_defaults_stream_cursor_value_input {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
  value: jsonb
}

"""
Table containing organizations owned by users. Auto-enroll members based on email domain
"""
type organizations {
  allowedEmailDomains: [String!]
  allowedEmails: [String!]
  autoEnroll: Boolean!
  avatarUrl: String
  blockedEmailDomains: [String!]
  blockedEmails: [String!]
  createdAt: timestamptz!
  createdBy: uuid!
  description: String

  """An array relationship"""
  devices(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """An aggregate relationship"""
  devices_aggregate(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): devices_aggregate!
  displayName: String!

  """An array relationship"""
  groups(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]!

  """An aggregate relationship"""
  groups_aggregate(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): groups_aggregate!
  id: uuid!

  """An array relationship"""
  invitations(
    """distinct select on columns"""
    distinct_on: [invitations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitations_order_by!]

    """filter the rows returned"""
    where: invitations_bool_exp
  ): [invitations!]!

  """An aggregate relationship"""
  invitations_aggregate(
    """distinct select on columns"""
    distinct_on: [invitations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitations_order_by!]

    """filter the rows returned"""
    where: invitations_bool_exp
  ): invitations_aggregate!

  """An array relationship"""
  memberships(
    """distinct select on columns"""
    distinct_on: [memberships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [memberships_order_by!]

    """filter the rows returned"""
    where: memberships_bool_exp
  ): [memberships!]!

  """An aggregate relationship"""
  memberships_aggregate(
    """distinct select on columns"""
    distinct_on: [memberships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [memberships_order_by!]

    """filter the rows returned"""
    where: memberships_bool_exp
  ): memberships_aggregate!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """An aggregate relationship"""
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """An object relationship"""
  owner: users!
  ownerId: uuid!

  """An array relationship"""
  policies(
    """distinct select on columns"""
    distinct_on: [policies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [policies_order_by!]

    """filter the rows returned"""
    where: policies_bool_exp
  ): [policies!]!

  """An aggregate relationship"""
  policies_aggregate(
    """distinct select on columns"""
    distinct_on: [policies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [policies_order_by!]

    """filter the rows returned"""
    where: policies_bool_exp
  ): policies_aggregate!

  """An array relationship"""
  pools(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]!

  """An aggregate relationship"""
  pools_aggregate(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): pools_aggregate!

  """An array relationship"""
  rules(
    """distinct select on columns"""
    distinct_on: [rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rules_order_by!]

    """filter the rows returned"""
    where: rules_bool_exp
  ): [rules!]!

  """An aggregate relationship"""
  rules_aggregate(
    """distinct select on columns"""
    distinct_on: [rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rules_order_by!]

    """filter the rows returned"""
    where: rules_bool_exp
  ): rules_aggregate!

  """An array relationship"""
  settings(
    """distinct select on columns"""
    distinct_on: [org_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_settings_order_by!]

    """filter the rows returned"""
    where: org_settings_bool_exp
  ): [org_settings!]!

  """An array relationship"""
  settingsWithDefaults(
    """distinct select on columns"""
    distinct_on: [org_settings_with_defaults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_settings_with_defaults_order_by!]

    """filter the rows returned"""
    where: org_settings_with_defaults_bool_exp
  ): [org_settings_with_defaults!]!

  """An aggregate relationship"""
  settingsWithDefaults_aggregate(
    """distinct select on columns"""
    distinct_on: [org_settings_with_defaults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_settings_with_defaults_order_by!]

    """filter the rows returned"""
    where: org_settings_with_defaults_bool_exp
  ): org_settings_with_defaults_aggregate!

  """An aggregate relationship"""
  settings_aggregate(
    """distinct select on columns"""
    distinct_on: [org_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_settings_order_by!]

    """filter the rows returned"""
    where: org_settings_bool_exp
  ): org_settings_aggregate!

  """An array relationship"""
  subscriptions(
    """distinct select on columns"""
    distinct_on: [subscriptions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptions_order_by!]

    """filter the rows returned"""
    where: subscriptions_bool_exp
  ): [subscriptions!]!

  """An aggregate relationship"""
  subscriptions_aggregate(
    """distinct select on columns"""
    distinct_on: [subscriptions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptions_order_by!]

    """filter the rows returned"""
    where: subscriptions_bool_exp
  ): subscriptions_aggregate!
  tags: [String!]
  updatedAt: timestamptz!
  updatedBy: uuid!
}

"""
aggregated selection of "organizations"
"""
type organizations_aggregate {
  aggregate: organizations_aggregate_fields
  nodes: [organizations!]!
}

"""
aggregate fields of "organizations"
"""
type organizations_aggregate_fields {
  count(columns: [organizations_select_column!], distinct: Boolean): Int!
  max: organizations_max_fields
  min: organizations_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input organizations_append_input {
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "organizations". All fields are combined with a logical 'AND'.
"""
input organizations_bool_exp {
  _and: [organizations_bool_exp!]
  _not: organizations_bool_exp
  _or: [organizations_bool_exp!]
  allowedEmailDomains: String_array_comparison_exp
  allowedEmails: String_array_comparison_exp
  autoEnroll: Boolean_comparison_exp
  avatarUrl: String_comparison_exp
  blockedEmailDomains: String_array_comparison_exp
  blockedEmails: String_array_comparison_exp
  createdAt: timestamptz_comparison_exp
  createdBy: uuid_comparison_exp
  description: String_comparison_exp
  devices: devices_bool_exp
  devices_aggregate: devices_aggregate_bool_exp
  displayName: String_comparison_exp
  groups: groups_bool_exp
  groups_aggregate: groups_aggregate_bool_exp
  id: uuid_comparison_exp
  invitations: invitations_bool_exp
  invitations_aggregate: invitations_aggregate_bool_exp
  memberships: memberships_bool_exp
  memberships_aggregate: memberships_aggregate_bool_exp
  metadata: jsonb_comparison_exp
  notifications: notifications_bool_exp
  notifications_aggregate: notifications_aggregate_bool_exp
  owner: users_bool_exp
  ownerId: uuid_comparison_exp
  policies: policies_bool_exp
  policies_aggregate: policies_aggregate_bool_exp
  pools: pools_bool_exp
  pools_aggregate: pools_aggregate_bool_exp
  rules: rules_bool_exp
  rules_aggregate: rules_aggregate_bool_exp
  settings: org_settings_bool_exp
  settingsWithDefaults: org_settings_with_defaults_bool_exp
  settingsWithDefaults_aggregate: org_settings_with_defaults_aggregate_bool_exp
  settings_aggregate: org_settings_aggregate_bool_exp
  subscriptions: subscriptions_bool_exp
  subscriptions_aggregate: subscriptions_aggregate_bool_exp
  tags: String_array_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: uuid_comparison_exp
}

"""
unique or primary key constraints on table "organizations"
"""
enum organizations_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  organizations_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input organizations_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input organizations_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input organizations_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "organizations"
"""
input organizations_insert_input {
  allowedEmailDomains: [String!]
  allowedEmails: [String!]
  autoEnroll: Boolean
  avatarUrl: String
  blockedEmailDomains: [String!]
  blockedEmails: [String!]
  createdAt: timestamptz
  createdBy: uuid
  description: String
  devices: devices_arr_rel_insert_input
  displayName: String
  groups: groups_arr_rel_insert_input
  id: uuid
  invitations: invitations_arr_rel_insert_input
  memberships: memberships_arr_rel_insert_input
  metadata: jsonb
  notifications: notifications_arr_rel_insert_input
  owner: users_obj_rel_insert_input
  ownerId: uuid
  policies: policies_arr_rel_insert_input
  pools: pools_arr_rel_insert_input
  rules: rules_arr_rel_insert_input
  settings: org_settings_arr_rel_insert_input
  settingsWithDefaults: org_settings_with_defaults_arr_rel_insert_input
  subscriptions: subscriptions_arr_rel_insert_input
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
}

"""aggregate max on columns"""
type organizations_max_fields {
  allowedEmailDomains: [String!]
  allowedEmails: [String!]
  avatarUrl: String
  blockedEmailDomains: [String!]
  blockedEmails: [String!]
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  ownerId: uuid
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
}

"""aggregate min on columns"""
type organizations_min_fields {
  allowedEmailDomains: [String!]
  allowedEmails: [String!]
  avatarUrl: String
  blockedEmailDomains: [String!]
  blockedEmails: [String!]
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  ownerId: uuid
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
response of any mutation on the table "organizations"
"""
type organizations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [organizations!]!
}

"""
input type for inserting object relation for remote table "organizations"
"""
input organizations_obj_rel_insert_input {
  data: organizations_insert_input!

  """upsert condition"""
  on_conflict: organizations_on_conflict
}

"""
on_conflict condition type for table "organizations"
"""
input organizations_on_conflict {
  constraint: organizations_constraint!
  update_columns: [organizations_update_column!]! = []
  where: organizations_bool_exp
}

"""Ordering options when selecting data from "organizations"."""
input organizations_order_by {
  allowedEmailDomains: order_by
  allowedEmails: order_by
  autoEnroll: order_by
  avatarUrl: order_by
  blockedEmailDomains: order_by
  blockedEmails: order_by
  createdAt: order_by
  createdBy: order_by
  description: order_by
  devices_aggregate: devices_aggregate_order_by
  displayName: order_by
  groups_aggregate: groups_aggregate_order_by
  id: order_by
  invitations_aggregate: invitations_aggregate_order_by
  memberships_aggregate: memberships_aggregate_order_by
  metadata: order_by
  notifications_aggregate: notifications_aggregate_order_by
  owner: users_order_by
  ownerId: order_by
  policies_aggregate: policies_aggregate_order_by
  pools_aggregate: pools_aggregate_order_by
  rules_aggregate: rules_aggregate_order_by
  settingsWithDefaults_aggregate: org_settings_with_defaults_aggregate_order_by
  settings_aggregate: org_settings_aggregate_order_by
  subscriptions_aggregate: subscriptions_aggregate_order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""primary key columns input for table: organizations"""
input organizations_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input organizations_prepend_input {
  metadata: jsonb
}

"""
select columns of table "organizations"
"""
enum organizations_select_column {
  """column name"""
  allowedEmailDomains

  """column name"""
  allowedEmails

  """column name"""
  autoEnroll

  """column name"""
  avatarUrl

  """column name"""
  blockedEmailDomains

  """column name"""
  blockedEmails

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  ownerId

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

"""
input type for updating data in table "organizations"
"""
input organizations_set_input {
  allowedEmailDomains: [String!]
  allowedEmails: [String!]
  autoEnroll: Boolean
  avatarUrl: String
  blockedEmailDomains: [String!]
  blockedEmails: [String!]
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  metadata: jsonb
  ownerId: uuid
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
Streaming cursor of the table "organizations"
"""
input organizations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: organizations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input organizations_stream_cursor_value_input {
  allowedEmailDomains: [String!]
  allowedEmails: [String!]
  autoEnroll: Boolean
  avatarUrl: String
  blockedEmailDomains: [String!]
  blockedEmails: [String!]
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  metadata: jsonb
  ownerId: uuid
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
update columns of table "organizations"
"""
enum organizations_update_column {
  """column name"""
  allowedEmailDomains

  """column name"""
  allowedEmails

  """column name"""
  autoEnroll

  """column name"""
  avatarUrl

  """column name"""
  blockedEmailDomains

  """column name"""
  blockedEmails

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  ownerId

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

input organizations_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: organizations_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: organizations_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: organizations_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: organizations_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: organizations_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: organizations_set_input

  """filter the rows which have to be updated"""
  where: organizations_bool_exp!
}

"""plan enum"""
type plan {
  description: String!
  value: String!
}

"""
aggregated selection of "plan"
"""
type plan_aggregate {
  aggregate: plan_aggregate_fields
  nodes: [plan!]!
}

"""
aggregate fields of "plan"
"""
type plan_aggregate_fields {
  count(columns: [plan_select_column!], distinct: Boolean): Int!
  max: plan_max_fields
  min: plan_min_fields
}

"""
Boolean expression to filter rows from the table "plan". All fields are combined with a logical 'AND'.
"""
input plan_bool_exp {
  _and: [plan_bool_exp!]
  _not: plan_bool_exp
  _or: [plan_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "plan"
"""
enum plan_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  plan_pkey
}

enum plan_enum {
  """ENTERPRISE"""
  enterprise

  """PRO"""
  pro

  """STARTER"""
  starter
}

"""
Boolean expression to compare columns of type "plan_enum". All fields are combined with logical 'AND'.
"""
input plan_enum_comparison_exp {
  _eq: plan_enum
  _in: [plan_enum!]
  _is_null: Boolean
  _neq: plan_enum
  _nin: [plan_enum!]
}

"""
input type for inserting data into table "plan"
"""
input plan_insert_input {
  description: String
  value: String
}

"""aggregate max on columns"""
type plan_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type plan_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "plan"
"""
type plan_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [plan!]!
}

"""
on_conflict condition type for table "plan"
"""
input plan_on_conflict {
  constraint: plan_constraint!
  update_columns: [plan_update_column!]! = []
  where: plan_bool_exp
}

"""Ordering options when selecting data from "plan"."""
input plan_order_by {
  description: order_by
  value: order_by
}

"""primary key columns input for table: plan"""
input plan_pk_columns_input {
  value: String!
}

"""
select columns of table "plan"
"""
enum plan_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "plan"
"""
input plan_set_input {
  description: String
  value: String
}

"""
Streaming cursor of the table "plan"
"""
input plan_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: plan_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input plan_stream_cursor_value_input {
  description: String
  value: String
}

"""
update columns of table "plan"
"""
enum plan_update_column {
  """column name"""
  description

  """column name"""
  value
}

input plan_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: plan_set_input

  """filter the rows which have to be updated"""
  where: plan_bool_exp!
}

"""Joint table associating subjects polymorphically with rules"""
type policies {
  active: Boolean!
  createdAt: timestamptz!
  createdBy: uuid!
  id: uuid!
  orgId: uuid!

  """An object relationship"""
  organization: organizations!

  """An object relationship"""
  rule: rules!
  ruleId: uuid!
  subjectDisplayName: String!
  subjectId: uuid!
  subjectSecondaryId: String!
  subjectType: subject_type_enum!
  updatedAt: timestamptz!
  updatedBy: uuid!
  validFrom: timestamptz!
  validTo: timestamptz
  weight: smallint!
}

"""
aggregated selection of "policies"
"""
type policies_aggregate {
  aggregate: policies_aggregate_fields
  nodes: [policies!]!
}

input policies_aggregate_bool_exp {
  bool_and: policies_aggregate_bool_exp_bool_and
  bool_or: policies_aggregate_bool_exp_bool_or
  count: policies_aggregate_bool_exp_count
}

input policies_aggregate_bool_exp_bool_and {
  arguments: policies_select_column_policies_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: policies_bool_exp
  predicate: Boolean_comparison_exp!
}

input policies_aggregate_bool_exp_bool_or {
  arguments: policies_select_column_policies_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: policies_bool_exp
  predicate: Boolean_comparison_exp!
}

input policies_aggregate_bool_exp_count {
  arguments: [policies_select_column!]
  distinct: Boolean
  filter: policies_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "policies"
"""
type policies_aggregate_fields {
  avg: policies_avg_fields
  count(columns: [policies_select_column!], distinct: Boolean): Int!
  max: policies_max_fields
  min: policies_min_fields
  stddev: policies_stddev_fields
  stddev_pop: policies_stddev_pop_fields
  stddev_samp: policies_stddev_samp_fields
  sum: policies_sum_fields
  var_pop: policies_var_pop_fields
  var_samp: policies_var_samp_fields
  variance: policies_variance_fields
}

"""
order by aggregate values of table "policies"
"""
input policies_aggregate_order_by {
  avg: policies_avg_order_by
  count: order_by
  max: policies_max_order_by
  min: policies_min_order_by
  stddev: policies_stddev_order_by
  stddev_pop: policies_stddev_pop_order_by
  stddev_samp: policies_stddev_samp_order_by
  sum: policies_sum_order_by
  var_pop: policies_var_pop_order_by
  var_samp: policies_var_samp_order_by
  variance: policies_variance_order_by
}

"""
input type for inserting array relation for remote table "policies"
"""
input policies_arr_rel_insert_input {
  data: [policies_insert_input!]!

  """upsert condition"""
  on_conflict: policies_on_conflict
}

"""aggregate avg on columns"""
type policies_avg_fields {
  weight: Float
}

"""
order by avg() on columns of table "policies"
"""
input policies_avg_order_by {
  weight: order_by
}

"""
Boolean expression to filter rows from the table "policies". All fields are combined with a logical 'AND'.
"""
input policies_bool_exp {
  _and: [policies_bool_exp!]
  _not: policies_bool_exp
  _or: [policies_bool_exp!]
  active: Boolean_comparison_exp
  createdAt: timestamptz_comparison_exp
  createdBy: uuid_comparison_exp
  id: uuid_comparison_exp
  orgId: uuid_comparison_exp
  organization: organizations_bool_exp
  rule: rules_bool_exp
  ruleId: uuid_comparison_exp
  subjectDisplayName: String_comparison_exp
  subjectId: uuid_comparison_exp
  subjectSecondaryId: String_comparison_exp
  subjectType: subject_type_enum_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: uuid_comparison_exp
  validFrom: timestamptz_comparison_exp
  validTo: timestamptz_comparison_exp
  weight: smallint_comparison_exp
}

"""
unique or primary key constraints on table "policies"
"""
enum policies_constraint {
  """
  unique or primary key constraint on columns "subject_id", "rule_id", "subject_type", "org_id"
  """
  policies_org_id_rule_id_subject_id_subject_type_key

  """
  unique or primary key constraint on columns "id"
  """
  policies_pkey
}

"""
input type for incrementing numeric columns in table "policies"
"""
input policies_inc_input {
  weight: smallint
}

"""
input type for inserting data into table "policies"
"""
input policies_insert_input {
  active: Boolean
  createdAt: timestamptz
  createdBy: uuid
  id: uuid
  orgId: uuid
  organization: organizations_obj_rel_insert_input
  rule: rules_obj_rel_insert_input
  ruleId: uuid
  subjectDisplayName: String
  subjectId: uuid
  subjectSecondaryId: String
  subjectType: subject_type_enum
  updatedAt: timestamptz
  updatedBy: uuid
  validFrom: timestamptz
  validTo: timestamptz
  weight: smallint
}

"""aggregate max on columns"""
type policies_max_fields {
  createdAt: timestamptz
  createdBy: uuid
  id: uuid
  orgId: uuid
  ruleId: uuid
  subjectDisplayName: String
  subjectId: uuid
  subjectSecondaryId: String
  updatedAt: timestamptz
  updatedBy: uuid
  validFrom: timestamptz
  validTo: timestamptz
  weight: smallint
}

"""
order by max() on columns of table "policies"
"""
input policies_max_order_by {
  createdAt: order_by
  createdBy: order_by
  id: order_by
  orgId: order_by
  ruleId: order_by
  subjectDisplayName: order_by
  subjectId: order_by
  subjectSecondaryId: order_by
  updatedAt: order_by
  updatedBy: order_by
  validFrom: order_by
  validTo: order_by
  weight: order_by
}

"""aggregate min on columns"""
type policies_min_fields {
  createdAt: timestamptz
  createdBy: uuid
  id: uuid
  orgId: uuid
  ruleId: uuid
  subjectDisplayName: String
  subjectId: uuid
  subjectSecondaryId: String
  updatedAt: timestamptz
  updatedBy: uuid
  validFrom: timestamptz
  validTo: timestamptz
  weight: smallint
}

"""
order by min() on columns of table "policies"
"""
input policies_min_order_by {
  createdAt: order_by
  createdBy: order_by
  id: order_by
  orgId: order_by
  ruleId: order_by
  subjectDisplayName: order_by
  subjectId: order_by
  subjectSecondaryId: order_by
  updatedAt: order_by
  updatedBy: order_by
  validFrom: order_by
  validTo: order_by
  weight: order_by
}

"""
response of any mutation on the table "policies"
"""
type policies_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [policies!]!
}

"""
on_conflict condition type for table "policies"
"""
input policies_on_conflict {
  constraint: policies_constraint!
  update_columns: [policies_update_column!]! = []
  where: policies_bool_exp
}

"""Ordering options when selecting data from "policies"."""
input policies_order_by {
  active: order_by
  createdAt: order_by
  createdBy: order_by
  id: order_by
  orgId: order_by
  organization: organizations_order_by
  rule: rules_order_by
  ruleId: order_by
  subjectDisplayName: order_by
  subjectId: order_by
  subjectSecondaryId: order_by
  subjectType: order_by
  updatedAt: order_by
  updatedBy: order_by
  validFrom: order_by
  validTo: order_by
  weight: order_by
}

"""primary key columns input for table: policies"""
input policies_pk_columns_input {
  id: uuid!
}

"""
select columns of table "policies"
"""
enum policies_select_column {
  """column name"""
  active

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  id

  """column name"""
  orgId

  """column name"""
  ruleId

  """column name"""
  subjectDisplayName

  """column name"""
  subjectId

  """column name"""
  subjectSecondaryId

  """column name"""
  subjectType

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  validFrom

  """column name"""
  validTo

  """column name"""
  weight
}

"""
select "policies_aggregate_bool_exp_bool_and_arguments_columns" columns of table "policies"
"""
enum policies_select_column_policies_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  active
}

"""
select "policies_aggregate_bool_exp_bool_or_arguments_columns" columns of table "policies"
"""
enum policies_select_column_policies_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  active
}

"""
input type for updating data in table "policies"
"""
input policies_set_input {
  active: Boolean
  createdAt: timestamptz
  createdBy: uuid
  id: uuid
  orgId: uuid
  ruleId: uuid
  subjectDisplayName: String
  subjectId: uuid
  subjectSecondaryId: String
  subjectType: subject_type_enum
  updatedAt: timestamptz
  updatedBy: uuid
  validFrom: timestamptz
  validTo: timestamptz
  weight: smallint
}

"""aggregate stddev on columns"""
type policies_stddev_fields {
  weight: Float
}

"""
order by stddev() on columns of table "policies"
"""
input policies_stddev_order_by {
  weight: order_by
}

"""aggregate stddev_pop on columns"""
type policies_stddev_pop_fields {
  weight: Float
}

"""
order by stddev_pop() on columns of table "policies"
"""
input policies_stddev_pop_order_by {
  weight: order_by
}

"""aggregate stddev_samp on columns"""
type policies_stddev_samp_fields {
  weight: Float
}

"""
order by stddev_samp() on columns of table "policies"
"""
input policies_stddev_samp_order_by {
  weight: order_by
}

"""
Streaming cursor of the table "policies"
"""
input policies_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: policies_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input policies_stream_cursor_value_input {
  active: Boolean
  createdAt: timestamptz
  createdBy: uuid
  id: uuid
  orgId: uuid
  ruleId: uuid
  subjectDisplayName: String
  subjectId: uuid
  subjectSecondaryId: String
  subjectType: subject_type_enum
  updatedAt: timestamptz
  updatedBy: uuid
  validFrom: timestamptz
  validTo: timestamptz
  weight: smallint
}

"""aggregate sum on columns"""
type policies_sum_fields {
  weight: smallint
}

"""
order by sum() on columns of table "policies"
"""
input policies_sum_order_by {
  weight: order_by
}

"""
update columns of table "policies"
"""
enum policies_update_column {
  """column name"""
  active

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  id

  """column name"""
  orgId

  """column name"""
  ruleId

  """column name"""
  subjectDisplayName

  """column name"""
  subjectId

  """column name"""
  subjectSecondaryId

  """column name"""
  subjectType

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  validFrom

  """column name"""
  validTo

  """column name"""
  weight
}

input policies_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: policies_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: policies_set_input

  """filter the rows which have to be updated"""
  where: policies_bool_exp!
}

"""aggregate var_pop on columns"""
type policies_var_pop_fields {
  weight: Float
}

"""
order by var_pop() on columns of table "policies"
"""
input policies_var_pop_order_by {
  weight: order_by
}

"""aggregate var_samp on columns"""
type policies_var_samp_fields {
  weight: Float
}

"""
order by var_samp() on columns of table "policies"
"""
input policies_var_samp_order_by {
  weight: order_by
}

"""aggregate variance on columns"""
type policies_variance_fields {
  weight: Float
}

"""
order by variance() on columns of table "policies"
"""
input policies_variance_order_by {
  weight: order_by
}

"""Table containing device pools data"""
type pools {
  alternateDns: Boolean
  createdAt: timestamptz!
  createdBy: uuid!
  description: String
  displayName: String!
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  orgId: uuid!
  proxyIp: Boolean
  tags: [String!]
  updatedAt: timestamptz!
  updatedBy: uuid!
  version: String
}

"""
aggregated selection of "pools"
"""
type pools_aggregate {
  aggregate: pools_aggregate_fields
  nodes: [pools!]!
}

input pools_aggregate_bool_exp {
  bool_and: pools_aggregate_bool_exp_bool_and
  bool_or: pools_aggregate_bool_exp_bool_or
  count: pools_aggregate_bool_exp_count
}

input pools_aggregate_bool_exp_bool_and {
  arguments: pools_select_column_pools_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: pools_bool_exp
  predicate: Boolean_comparison_exp!
}

input pools_aggregate_bool_exp_bool_or {
  arguments: pools_select_column_pools_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: pools_bool_exp
  predicate: Boolean_comparison_exp!
}

input pools_aggregate_bool_exp_count {
  arguments: [pools_select_column!]
  distinct: Boolean
  filter: pools_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "pools"
"""
type pools_aggregate_fields {
  count(columns: [pools_select_column!], distinct: Boolean): Int!
  max: pools_max_fields
  min: pools_min_fields
}

"""
order by aggregate values of table "pools"
"""
input pools_aggregate_order_by {
  count: order_by
  max: pools_max_order_by
  min: pools_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input pools_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "pools"
"""
input pools_arr_rel_insert_input {
  data: [pools_insert_input!]!

  """upsert condition"""
  on_conflict: pools_on_conflict
}

"""
Boolean expression to filter rows from the table "pools". All fields are combined with a logical 'AND'.
"""
input pools_bool_exp {
  _and: [pools_bool_exp!]
  _not: pools_bool_exp
  _or: [pools_bool_exp!]
  alternateDns: Boolean_comparison_exp
  createdAt: timestamptz_comparison_exp
  createdBy: uuid_comparison_exp
  description: String_comparison_exp
  displayName: String_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  orgId: uuid_comparison_exp
  proxyIp: Boolean_comparison_exp
  tags: String_array_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: uuid_comparison_exp
  version: String_comparison_exp
}

"""
unique or primary key constraints on table "pools"
"""
enum pools_constraint {
  """
  unique or primary key constraint on columns "display_name", "org_id"
  """
  pools_org_id_display_name_key

  """
  unique or primary key constraint on columns "id"
  """
  pools_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input pools_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input pools_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input pools_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "pools"
"""
input pools_insert_input {
  alternateDns: Boolean
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  metadata: jsonb
  orgId: uuid
  proxyIp: Boolean
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
  version: String
}

"""aggregate max on columns"""
type pools_max_fields {
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  orgId: uuid
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
  version: String
}

"""
order by max() on columns of table "pools"
"""
input pools_max_order_by {
  createdAt: order_by
  createdBy: order_by
  description: order_by
  displayName: order_by
  id: order_by
  orgId: order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
  version: order_by
}

"""aggregate min on columns"""
type pools_min_fields {
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  orgId: uuid
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
  version: String
}

"""
order by min() on columns of table "pools"
"""
input pools_min_order_by {
  createdAt: order_by
  createdBy: order_by
  description: order_by
  displayName: order_by
  id: order_by
  orgId: order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
  version: order_by
}

"""
response of any mutation on the table "pools"
"""
type pools_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [pools!]!
}

"""
input type for inserting object relation for remote table "pools"
"""
input pools_obj_rel_insert_input {
  data: pools_insert_input!

  """upsert condition"""
  on_conflict: pools_on_conflict
}

"""
on_conflict condition type for table "pools"
"""
input pools_on_conflict {
  constraint: pools_constraint!
  update_columns: [pools_update_column!]! = []
  where: pools_bool_exp
}

"""Ordering options when selecting data from "pools"."""
input pools_order_by {
  alternateDns: order_by
  createdAt: order_by
  createdBy: order_by
  description: order_by
  displayName: order_by
  id: order_by
  metadata: order_by
  orgId: order_by
  proxyIp: order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
  version: order_by
}

"""primary key columns input for table: pools"""
input pools_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input pools_prepend_input {
  metadata: jsonb
}

"""
select columns of table "pools"
"""
enum pools_select_column {
  """column name"""
  alternateDns

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  orgId

  """column name"""
  proxyIp

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  version
}

"""
select "pools_aggregate_bool_exp_bool_and_arguments_columns" columns of table "pools"
"""
enum pools_select_column_pools_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  alternateDns

  """column name"""
  proxyIp
}

"""
select "pools_aggregate_bool_exp_bool_or_arguments_columns" columns of table "pools"
"""
enum pools_select_column_pools_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  alternateDns

  """column name"""
  proxyIp
}

"""
input type for updating data in table "pools"
"""
input pools_set_input {
  alternateDns: Boolean
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  metadata: jsonb
  orgId: uuid
  proxyIp: Boolean
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
  version: String
}

"""
Streaming cursor of the table "pools"
"""
input pools_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: pools_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input pools_stream_cursor_value_input {
  alternateDns: Boolean
  createdAt: timestamptz
  createdBy: uuid
  description: String
  displayName: String
  id: uuid
  metadata: jsonb
  orgId: uuid
  proxyIp: Boolean
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
  version: String
}

"""
update columns of table "pools"
"""
enum pools_update_column {
  """column name"""
  alternateDns

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  orgId

  """column name"""
  proxyIp

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  version
}

input pools_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: pools_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: pools_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: pools_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: pools_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: pools_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: pools_set_input

  """filter the rows which have to be updated"""
  where: pools_bool_exp!
}

"""policy network protocol enum"""
type protocol {
  description: String!
  value: String!
}

"""
aggregated selection of "protocol"
"""
type protocol_aggregate {
  aggregate: protocol_aggregate_fields
  nodes: [protocol!]!
}

"""
aggregate fields of "protocol"
"""
type protocol_aggregate_fields {
  count(columns: [protocol_select_column!], distinct: Boolean): Int!
  max: protocol_max_fields
  min: protocol_min_fields
}

"""
Boolean expression to filter rows from the table "protocol". All fields are combined with a logical 'AND'.
"""
input protocol_bool_exp {
  _and: [protocol_bool_exp!]
  _not: protocol_bool_exp
  _or: [protocol_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "protocol"
"""
enum protocol_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  protocol_pkey
}

enum protocol_enum {
  """Any"""
  Any

  """ICMP"""
  ICMP

  """ICMPV6"""
  ICMPV6

  """IGMP"""
  IGMP

  """IP"""
  IP

  """IPV6"""
  IPV6

  """RM"""
  RM

  """TCP"""
  TCP

  """UDP"""
  UDP
}

"""
Boolean expression to compare columns of type "protocol_enum". All fields are combined with logical 'AND'.
"""
input protocol_enum_comparison_exp {
  _eq: protocol_enum
  _in: [protocol_enum!]
  _is_null: Boolean
  _neq: protocol_enum
  _nin: [protocol_enum!]
}

"""
input type for inserting data into table "protocol"
"""
input protocol_insert_input {
  description: String
  value: String
}

"""aggregate max on columns"""
type protocol_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type protocol_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "protocol"
"""
type protocol_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [protocol!]!
}

"""
on_conflict condition type for table "protocol"
"""
input protocol_on_conflict {
  constraint: protocol_constraint!
  update_columns: [protocol_update_column!]! = []
  where: protocol_bool_exp
}

"""Ordering options when selecting data from "protocol"."""
input protocol_order_by {
  description: order_by
  value: order_by
}

"""primary key columns input for table: protocol"""
input protocol_pk_columns_input {
  value: String!
}

"""
select columns of table "protocol"
"""
enum protocol_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "protocol"
"""
input protocol_set_input {
  description: String
  value: String
}

"""
Streaming cursor of the table "protocol"
"""
input protocol_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: protocol_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input protocol_stream_cursor_value_input {
  description: String
  value: String
}

"""
update columns of table "protocol"
"""
enum protocol_update_column {
  """column name"""
  description

  """column name"""
  value
}

input protocol_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: protocol_set_input

  """filter the rows which have to be updated"""
  where: protocol_bool_exp!
}

type query_root {
  """Universities API"""
  ListUniversities(arg1: ListUniversitiesInput!): [ListUniversitiesOutput]

  """Restrooms API"""
  SearchRestrooms(arg1: SearchRestroomsInput!): [SearchRestroomsOutput]

  """
  fetch data from the table: "action"
  """
  action(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """
  fetch aggregated fields from the table: "action"
  """
  action_aggregate(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): action_aggregate!

  """fetch data from the table: "action" using primary key columns"""
  action_by_pk(value: String!): action

  """fetch data from the table: "auth.providers" using primary key columns"""
  authProvider(id: String!): authProviders

  """
  fetch data from the table: "auth.provider_requests" using primary key columns
  """
  authProviderRequest(id: uuid!): authProviderRequests

  """
  fetch data from the table: "auth.provider_requests"
  """
  authProviderRequests(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch aggregated fields from the table: "auth.provider_requests"
  """
  authProviderRequestsAggregate(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): authProviderRequests_aggregate!

  """
  fetch data from the table: "auth.providers"
  """
  authProviders(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  authProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): authProviders_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  authRefreshToken(id: uuid!): authRefreshTokens

  """
  fetch data from the table: "auth.refresh_token_types" using primary key columns
  """
  authRefreshTokenType(value: String!): authRefreshTokenTypes

  """
  fetch data from the table: "auth.refresh_token_types"
  """
  authRefreshTokenTypes(
    """distinct select on columns"""
    distinct_on: [authRefreshTokenTypes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokenTypes_order_by!]

    """filter the rows returned"""
    where: authRefreshTokenTypes_bool_exp
  ): [authRefreshTokenTypes!]!

  """
  fetch aggregated fields from the table: "auth.refresh_token_types"
  """
  authRefreshTokenTypesAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokenTypes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokenTypes_order_by!]

    """filter the rows returned"""
    where: authRefreshTokenTypes_bool_exp
  ): authRefreshTokenTypes_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  authRefreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  authRefreshTokensAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """fetch data from the table: "auth.roles" using primary key columns"""
  authRole(role: String!): authRoles

  """
  fetch data from the table: "auth.roles"
  """
  authRoles(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  authRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): authRoles_aggregate!

  """
  fetch data from the table: "auth.user_providers" using primary key columns
  """
  authUserProvider(id: uuid!): authUserProviders

  """
  fetch data from the table: "auth.user_providers"
  """
  authUserProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """
  fetch aggregated fields from the table: "auth.user_providers"
  """
  authUserProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!

  """fetch data from the table: "auth.user_roles" using primary key columns"""
  authUserRole(id: uuid!): authUserRoles

  """
  fetch data from the table: "auth.user_roles"
  """
  authUserRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch aggregated fields from the table: "auth.user_roles"
  """
  authUserRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """
  fetch data from the table: "auth.user_security_keys" using primary key columns
  """
  authUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  fetch data from the table: "auth.user_security_keys"
  """
  authUserSecurityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """
  fetch aggregated fields from the table: "auth.user_security_keys"
  """
  authUserSecurityKeysAggregate(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): authUserSecurityKeys_aggregate!

  """fetch data from the table: "storage.buckets" using primary key columns"""
  bucket(id: String!): buckets

  """
  fetch data from the table: "storage.buckets"
  """
  buckets(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  fetch aggregated fields from the table: "storage.buckets"
  """
  bucketsAggregate(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): buckets_aggregate!

  """
  execute function "device_associated_pools" which returns "pools"
  """
  device_associated_pools(
    """
    input parameters for function "device_associated_pools"
    """
    args: device_associated_pools_args!

    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]!

  """
  execute function "device_associated_pools" and query aggregates on result of table type "pools"
  """
  device_associated_pools_aggregate(
    """
    input parameters for function "device_associated_pools_aggregate"
    """
    args: device_associated_pools_args!

    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): pools_aggregate!

  """
  execute function "device_dissociated_pools" which returns "pools"
  """
  device_dissociated_pools(
    """
    input parameters for function "device_dissociated_pools"
    """
    args: device_dissociated_pools_args!

    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]!

  """
  execute function "device_dissociated_pools" and query aggregates on result of table type "pools"
  """
  device_dissociated_pools_aggregate(
    """
    input parameters for function "device_dissociated_pools_aggregate"
    """
    args: device_dissociated_pools_args!

    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): pools_aggregate!

  """
  fetch data from the table: "device_pools"
  """
  device_pools(
    """distinct select on columns"""
    distinct_on: [device_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pools_order_by!]

    """filter the rows returned"""
    where: device_pools_bool_exp
  ): [device_pools!]!

  """
  fetch aggregated fields from the table: "device_pools"
  """
  device_pools_aggregate(
    """distinct select on columns"""
    distinct_on: [device_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pools_order_by!]

    """filter the rows returned"""
    where: device_pools_bool_exp
  ): device_pools_aggregate!

  """fetch data from the table: "device_pools" using primary key columns"""
  device_pools_by_pk(deviceId: uuid!, poolId: uuid!): device_pools

  """An array relationship"""
  devices(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """An aggregate relationship"""
  devices_aggregate(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): devices_aggregate!

  """fetch data from the table: "devices" using primary key columns"""
  devices_by_pk(id: uuid!): devices

  """
  fetch data from the table: "direction"
  """
  direction(
    """distinct select on columns"""
    distinct_on: [direction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [direction_order_by!]

    """filter the rows returned"""
    where: direction_bool_exp
  ): [direction!]!

  """
  fetch aggregated fields from the table: "direction"
  """
  direction_aggregate(
    """distinct select on columns"""
    distinct_on: [direction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [direction_order_by!]

    """filter the rows returned"""
    where: direction_bool_exp
  ): direction_aggregate!

  """fetch data from the table: "direction" using primary key columns"""
  direction_by_pk(value: String!): direction

  """fetch data from the table: "storage.files" using primary key columns"""
  file(id: uuid!): files

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "storage.files"
  """
  filesAggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """An array relationship"""
  groups(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]!

  """An aggregate relationship"""
  groups_aggregate(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): groups_aggregate!

  """fetch data from the table: "groups" using primary key columns"""
  groups_by_pk(id: uuid!): groups

  """An array relationship"""
  invitations(
    """distinct select on columns"""
    distinct_on: [invitations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitations_order_by!]

    """filter the rows returned"""
    where: invitations_bool_exp
  ): [invitations!]!

  """An aggregate relationship"""
  invitations_aggregate(
    """distinct select on columns"""
    distinct_on: [invitations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitations_order_by!]

    """filter the rows returned"""
    where: invitations_bool_exp
  ): invitations_aggregate!

  """fetch data from the table: "invitations" using primary key columns"""
  invitations_by_pk(email: citext!, orgId: uuid!): invitations

  """An array relationship"""
  memberships(
    """distinct select on columns"""
    distinct_on: [memberships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [memberships_order_by!]

    """filter the rows returned"""
    where: memberships_bool_exp
  ): [memberships!]!

  """An aggregate relationship"""
  memberships_aggregate(
    """distinct select on columns"""
    distinct_on: [memberships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [memberships_order_by!]

    """filter the rows returned"""
    where: memberships_bool_exp
  ): memberships_aggregate!

  """fetch data from the table: "memberships" using primary key columns"""
  memberships_by_pk(orgId: uuid!, userId: uuid!): memberships

  """
  fetch data from the table: "notification_status"
  """
  notification_status(
    """distinct select on columns"""
    distinct_on: [notification_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_status_order_by!]

    """filter the rows returned"""
    where: notification_status_bool_exp
  ): [notification_status!]!

  """
  fetch aggregated fields from the table: "notification_status"
  """
  notification_status_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_status_order_by!]

    """filter the rows returned"""
    where: notification_status_bool_exp
  ): notification_status_aggregate!

  """
  fetch data from the table: "notification_status" using primary key columns
  """
  notification_status_by_pk(value: String!): notification_status

  """
  fetch data from the table: "notification_type"
  """
  notification_type(
    """distinct select on columns"""
    distinct_on: [notification_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_type_order_by!]

    """filter the rows returned"""
    where: notification_type_bool_exp
  ): [notification_type!]!

  """
  fetch aggregated fields from the table: "notification_type"
  """
  notification_type_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_type_order_by!]

    """filter the rows returned"""
    where: notification_type_bool_exp
  ): notification_type_aggregate!

  """
  fetch data from the table: "notification_type" using primary key columns
  """
  notification_type_by_pk(value: String!): notification_type

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """An aggregate relationship"""
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """fetch data from the table: "notifications" using primary key columns"""
  notifications_by_pk(id: uuid!): notifications

  """
  fetch data from the table: "org_settings"
  """
  org_settings(
    """distinct select on columns"""
    distinct_on: [org_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_settings_order_by!]

    """filter the rows returned"""
    where: org_settings_bool_exp
  ): [org_settings!]!

  """
  fetch aggregated fields from the table: "org_settings"
  """
  org_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [org_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_settings_order_by!]

    """filter the rows returned"""
    where: org_settings_bool_exp
  ): org_settings_aggregate!

  """fetch data from the table: "org_settings" using primary key columns"""
  org_settings_by_pk(key: String!, orgId: uuid!): org_settings

  """
  fetch data from the table: "org_settings_with_defaults"
  """
  org_settings_with_defaults(
    """distinct select on columns"""
    distinct_on: [org_settings_with_defaults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_settings_with_defaults_order_by!]

    """filter the rows returned"""
    where: org_settings_with_defaults_bool_exp
  ): [org_settings_with_defaults!]!

  """
  fetch aggregated fields from the table: "org_settings_with_defaults"
  """
  org_settings_with_defaults_aggregate(
    """distinct select on columns"""
    distinct_on: [org_settings_with_defaults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_settings_with_defaults_order_by!]

    """filter the rows returned"""
    where: org_settings_with_defaults_bool_exp
  ): org_settings_with_defaults_aggregate!

  """
  fetch data from the table: "organizations"
  """
  organizations(
    """distinct select on columns"""
    distinct_on: [organizations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organizations_order_by!]

    """filter the rows returned"""
    where: organizations_bool_exp
  ): [organizations!]!

  """
  fetch aggregated fields from the table: "organizations"
  """
  organizations_aggregate(
    """distinct select on columns"""
    distinct_on: [organizations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organizations_order_by!]

    """filter the rows returned"""
    where: organizations_bool_exp
  ): organizations_aggregate!

  """fetch data from the table: "organizations" using primary key columns"""
  organizations_by_pk(id: uuid!): organizations

  """
  fetch data from the table: "plan"
  """
  plan(
    """distinct select on columns"""
    distinct_on: [plan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [plan_order_by!]

    """filter the rows returned"""
    where: plan_bool_exp
  ): [plan!]!

  """
  fetch aggregated fields from the table: "plan"
  """
  plan_aggregate(
    """distinct select on columns"""
    distinct_on: [plan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [plan_order_by!]

    """filter the rows returned"""
    where: plan_bool_exp
  ): plan_aggregate!

  """fetch data from the table: "plan" using primary key columns"""
  plan_by_pk(value: String!): plan

  """An array relationship"""
  policies(
    """distinct select on columns"""
    distinct_on: [policies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [policies_order_by!]

    """filter the rows returned"""
    where: policies_bool_exp
  ): [policies!]!

  """An aggregate relationship"""
  policies_aggregate(
    """distinct select on columns"""
    distinct_on: [policies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [policies_order_by!]

    """filter the rows returned"""
    where: policies_bool_exp
  ): policies_aggregate!

  """fetch data from the table: "policies" using primary key columns"""
  policies_by_pk(id: uuid!): policies

  """An array relationship"""
  pools(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]!

  """An aggregate relationship"""
  pools_aggregate(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): pools_aggregate!

  """fetch data from the table: "pools" using primary key columns"""
  pools_by_pk(id: uuid!): pools

  """
  fetch data from the table: "protocol"
  """
  protocol(
    """distinct select on columns"""
    distinct_on: [protocol_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [protocol_order_by!]

    """filter the rows returned"""
    where: protocol_bool_exp
  ): [protocol!]!

  """
  fetch aggregated fields from the table: "protocol"
  """
  protocol_aggregate(
    """distinct select on columns"""
    distinct_on: [protocol_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [protocol_order_by!]

    """filter the rows returned"""
    where: protocol_bool_exp
  ): protocol_aggregate!

  """fetch data from the table: "protocol" using primary key columns"""
  protocol_by_pk(value: String!): protocol

  """An array relationship"""
  rules(
    """distinct select on columns"""
    distinct_on: [rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rules_order_by!]

    """filter the rows returned"""
    where: rules_bool_exp
  ): [rules!]!

  """An aggregate relationship"""
  rules_aggregate(
    """distinct select on columns"""
    distinct_on: [rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rules_order_by!]

    """filter the rows returned"""
    where: rules_bool_exp
  ): rules_aggregate!

  """fetch data from the table: "rules" using primary key columns"""
  rules_by_pk(id: uuid!): rules

  """
  fetch data from the table: "setting_type"
  """
  setting_type(
    """distinct select on columns"""
    distinct_on: [setting_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [setting_type_order_by!]

    """filter the rows returned"""
    where: setting_type_bool_exp
  ): [setting_type!]!

  """
  fetch aggregated fields from the table: "setting_type"
  """
  setting_type_aggregate(
    """distinct select on columns"""
    distinct_on: [setting_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [setting_type_order_by!]

    """filter the rows returned"""
    where: setting_type_bool_exp
  ): setting_type_aggregate!

  """fetch data from the table: "setting_type" using primary key columns"""
  setting_type_by_pk(value: String!): setting_type

  """
  fetch data from the table: "settings_metadata"
  """
  settings_metadata(
    """distinct select on columns"""
    distinct_on: [settings_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [settings_metadata_order_by!]

    """filter the rows returned"""
    where: settings_metadata_bool_exp
  ): [settings_metadata!]!

  """
  fetch aggregated fields from the table: "settings_metadata"
  """
  settings_metadata_aggregate(
    """distinct select on columns"""
    distinct_on: [settings_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [settings_metadata_order_by!]

    """filter the rows returned"""
    where: settings_metadata_bool_exp
  ): settings_metadata_aggregate!

  """
  fetch data from the table: "settings_metadata" using primary key columns
  """
  settings_metadata_by_pk(key: String!): settings_metadata

  """
  fetch data from the table: "status"
  """
  status(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): [status!]!

  """
  fetch aggregated fields from the table: "status"
  """
  status_aggregate(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): status_aggregate!

  """fetch data from the table: "status" using primary key columns"""
  status_by_pk(value: String!): status

  """
  fetch data from the table: "subject_type"
  """
  subject_type(
    """distinct select on columns"""
    distinct_on: [subject_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subject_type_order_by!]

    """filter the rows returned"""
    where: subject_type_bool_exp
  ): [subject_type!]!

  """
  fetch aggregated fields from the table: "subject_type"
  """
  subject_type_aggregate(
    """distinct select on columns"""
    distinct_on: [subject_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subject_type_order_by!]

    """filter the rows returned"""
    where: subject_type_bool_exp
  ): subject_type_aggregate!

  """fetch data from the table: "subject_type" using primary key columns"""
  subject_type_by_pk(value: String!): subject_type

  """An array relationship"""
  subscriptions(
    """distinct select on columns"""
    distinct_on: [subscriptions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptions_order_by!]

    """filter the rows returned"""
    where: subscriptions_bool_exp
  ): [subscriptions!]!

  """An aggregate relationship"""
  subscriptions_aggregate(
    """distinct select on columns"""
    distinct_on: [subscriptions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptions_order_by!]

    """filter the rows returned"""
    where: subscriptions_bool_exp
  ): subscriptions_aggregate!

  """fetch data from the table: "subscriptions" using primary key columns"""
  subscriptions_by_pk(id: uuid!): subscriptions

  """fetch data from the table: "auth.users" using primary key columns"""
  user(id: uuid!): users

  """
  execute function "user_associated_groups" which returns "groups"
  """
  user_associated_groups(
    """
    input parameters for function "user_associated_groups"
    """
    args: user_associated_groups_args!

    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]!

  """
  execute function "user_associated_groups" and query aggregates on result of table type "groups"
  """
  user_associated_groups_aggregate(
    """
    input parameters for function "user_associated_groups_aggregate"
    """
    args: user_associated_groups_args!

    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): groups_aggregate!

  """
  execute function "user_dissociated_groups" which returns "groups"
  """
  user_dissociated_groups(
    """
    input parameters for function "user_dissociated_groups"
    """
    args: user_dissociated_groups_args!

    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]!

  """
  execute function "user_dissociated_groups" and query aggregates on result of table type "groups"
  """
  user_dissociated_groups_aggregate(
    """
    input parameters for function "user_dissociated_groups_aggregate"
    """
    args: user_dissociated_groups_args!

    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): groups_aggregate!

  """
  fetch data from the table: "user_groups"
  """
  user_groups(
    """distinct select on columns"""
    distinct_on: [user_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_groups_order_by!]

    """filter the rows returned"""
    where: user_groups_bool_exp
  ): [user_groups!]!

  """
  fetch aggregated fields from the table: "user_groups"
  """
  user_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [user_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_groups_order_by!]

    """filter the rows returned"""
    where: user_groups_bool_exp
  ): user_groups_aggregate!

  """fetch data from the table: "user_groups" using primary key columns"""
  user_groups_by_pk(groupId: uuid!, userId: uuid!): user_groups

  """
  fetch data from the table: "user_notifications"
  """
  user_notifications(
    """distinct select on columns"""
    distinct_on: [user_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_notifications_order_by!]

    """filter the rows returned"""
    where: user_notifications_bool_exp
  ): [user_notifications!]!

  """
  fetch aggregated fields from the table: "user_notifications"
  """
  user_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [user_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_notifications_order_by!]

    """filter the rows returned"""
    where: user_notifications_bool_exp
  ): user_notifications_aggregate!

  """
  fetch data from the table: "user_notifications" using primary key columns
  """
  user_notifications_by_pk(notificationId: uuid!, userId: uuid!): user_notifications

  """
  fetch data from the table: "user_settings"
  """
  user_settings(
    """distinct select on columns"""
    distinct_on: [user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_order_by!]

    """filter the rows returned"""
    where: user_settings_bool_exp
  ): [user_settings!]!

  """
  fetch aggregated fields from the table: "user_settings"
  """
  user_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_order_by!]

    """filter the rows returned"""
    where: user_settings_bool_exp
  ): user_settings_aggregate!

  """fetch data from the table: "user_settings" using primary key columns"""
  user_settings_by_pk(key: String!, orgId: uuid!, user_id: uuid!): user_settings

  """
  fetch data from the table: "user_settings_with_defaults"
  """
  user_settings_with_defaults(
    """distinct select on columns"""
    distinct_on: [user_settings_with_defaults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_with_defaults_order_by!]

    """filter the rows returned"""
    where: user_settings_with_defaults_bool_exp
  ): [user_settings_with_defaults!]!

  """
  fetch aggregated fields from the table: "user_settings_with_defaults"
  """
  user_settings_with_defaults_aggregate(
    """distinct select on columns"""
    distinct_on: [user_settings_with_defaults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_with_defaults_order_by!]

    """filter the rows returned"""
    where: user_settings_with_defaults_bool_exp
  ): user_settings_with_defaults_aggregate!

  """
  fetch data from the table: "auth.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "auth.users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "storage.virus" using primary key columns"""
  virus(id: uuid!): virus

  """
  fetch data from the table: "storage.virus"
  """
  viruses(
    """distinct select on columns"""
    distinct_on: [virus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [virus_order_by!]

    """filter the rows returned"""
    where: virus_bool_exp
  ): [virus!]!

  """
  fetch aggregated fields from the table: "storage.virus"
  """
  virusesAggregate(
    """distinct select on columns"""
    distinct_on: [virus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [virus_order_by!]

    """filter the rows returned"""
    where: virus_bool_exp
  ): virus_aggregate!
}

"""Table containing shared or single-use 5-tuple firewalls rules"""
type rules {
  action: action_enum!
  appId: String
  createdAt: timestamptz!
  createdBy: uuid!
  description: String
  destination: String
  destinationPort: String
  direction: direction_enum!
  displayName: String!
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  orgId: uuid!

  """An array relationship"""
  policies(
    """distinct select on columns"""
    distinct_on: [policies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [policies_order_by!]

    """filter the rows returned"""
    where: policies_bool_exp
  ): [policies!]!

  """An aggregate relationship"""
  policies_aggregate(
    """distinct select on columns"""
    distinct_on: [policies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [policies_order_by!]

    """filter the rows returned"""
    where: policies_bool_exp
  ): policies_aggregate!
  protocol: protocol_enum!
  shared: Boolean!
  source: String
  sourcePort: String
  tags: [String!]
  throttleRate: String
  updatedAt: timestamptz!
  updatedBy: uuid!
  weight: smallint!
}

"""
aggregated selection of "rules"
"""
type rules_aggregate {
  aggregate: rules_aggregate_fields
  nodes: [rules!]!
}

input rules_aggregate_bool_exp {
  bool_and: rules_aggregate_bool_exp_bool_and
  bool_or: rules_aggregate_bool_exp_bool_or
  count: rules_aggregate_bool_exp_count
}

input rules_aggregate_bool_exp_bool_and {
  arguments: rules_select_column_rules_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: rules_bool_exp
  predicate: Boolean_comparison_exp!
}

input rules_aggregate_bool_exp_bool_or {
  arguments: rules_select_column_rules_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: rules_bool_exp
  predicate: Boolean_comparison_exp!
}

input rules_aggregate_bool_exp_count {
  arguments: [rules_select_column!]
  distinct: Boolean
  filter: rules_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "rules"
"""
type rules_aggregate_fields {
  avg: rules_avg_fields
  count(columns: [rules_select_column!], distinct: Boolean): Int!
  max: rules_max_fields
  min: rules_min_fields
  stddev: rules_stddev_fields
  stddev_pop: rules_stddev_pop_fields
  stddev_samp: rules_stddev_samp_fields
  sum: rules_sum_fields
  var_pop: rules_var_pop_fields
  var_samp: rules_var_samp_fields
  variance: rules_variance_fields
}

"""
order by aggregate values of table "rules"
"""
input rules_aggregate_order_by {
  avg: rules_avg_order_by
  count: order_by
  max: rules_max_order_by
  min: rules_min_order_by
  stddev: rules_stddev_order_by
  stddev_pop: rules_stddev_pop_order_by
  stddev_samp: rules_stddev_samp_order_by
  sum: rules_sum_order_by
  var_pop: rules_var_pop_order_by
  var_samp: rules_var_samp_order_by
  variance: rules_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input rules_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "rules"
"""
input rules_arr_rel_insert_input {
  data: [rules_insert_input!]!

  """upsert condition"""
  on_conflict: rules_on_conflict
}

"""aggregate avg on columns"""
type rules_avg_fields {
  weight: Float
}

"""
order by avg() on columns of table "rules"
"""
input rules_avg_order_by {
  weight: order_by
}

"""
Boolean expression to filter rows from the table "rules". All fields are combined with a logical 'AND'.
"""
input rules_bool_exp {
  _and: [rules_bool_exp!]
  _not: rules_bool_exp
  _or: [rules_bool_exp!]
  action: action_enum_comparison_exp
  appId: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  createdBy: uuid_comparison_exp
  description: String_comparison_exp
  destination: String_comparison_exp
  destinationPort: String_comparison_exp
  direction: direction_enum_comparison_exp
  displayName: String_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  orgId: uuid_comparison_exp
  policies: policies_bool_exp
  policies_aggregate: policies_aggregate_bool_exp
  protocol: protocol_enum_comparison_exp
  shared: Boolean_comparison_exp
  source: String_comparison_exp
  sourcePort: String_comparison_exp
  tags: String_array_comparison_exp
  throttleRate: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: uuid_comparison_exp
  weight: smallint_comparison_exp
}

"""
unique or primary key constraints on table "rules"
"""
enum rules_constraint {
  """
  unique or primary key constraint on columns "display_name", "org_id"
  """
  rules_org_id_display_name_key

  """
  unique or primary key constraint on columns "id"
  """
  rules_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input rules_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input rules_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input rules_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "rules"
"""
input rules_inc_input {
  weight: smallint
}

"""
input type for inserting data into table "rules"
"""
input rules_insert_input {
  action: action_enum
  appId: String
  createdAt: timestamptz
  createdBy: uuid
  description: String
  destination: String
  destinationPort: String
  direction: direction_enum
  displayName: String
  id: uuid
  metadata: jsonb
  orgId: uuid
  policies: policies_arr_rel_insert_input
  protocol: protocol_enum
  shared: Boolean
  source: String
  sourcePort: String
  tags: [String!]
  throttleRate: String
  updatedAt: timestamptz
  updatedBy: uuid
  weight: smallint
}

"""aggregate max on columns"""
type rules_max_fields {
  appId: String
  createdAt: timestamptz
  createdBy: uuid
  description: String
  destination: String
  destinationPort: String
  displayName: String
  id: uuid
  orgId: uuid
  source: String
  sourcePort: String
  tags: [String!]
  throttleRate: String
  updatedAt: timestamptz
  updatedBy: uuid
  weight: smallint
}

"""
order by max() on columns of table "rules"
"""
input rules_max_order_by {
  appId: order_by
  createdAt: order_by
  createdBy: order_by
  description: order_by
  destination: order_by
  destinationPort: order_by
  displayName: order_by
  id: order_by
  orgId: order_by
  source: order_by
  sourcePort: order_by
  tags: order_by
  throttleRate: order_by
  updatedAt: order_by
  updatedBy: order_by
  weight: order_by
}

"""aggregate min on columns"""
type rules_min_fields {
  appId: String
  createdAt: timestamptz
  createdBy: uuid
  description: String
  destination: String
  destinationPort: String
  displayName: String
  id: uuid
  orgId: uuid
  source: String
  sourcePort: String
  tags: [String!]
  throttleRate: String
  updatedAt: timestamptz
  updatedBy: uuid
  weight: smallint
}

"""
order by min() on columns of table "rules"
"""
input rules_min_order_by {
  appId: order_by
  createdAt: order_by
  createdBy: order_by
  description: order_by
  destination: order_by
  destinationPort: order_by
  displayName: order_by
  id: order_by
  orgId: order_by
  source: order_by
  sourcePort: order_by
  tags: order_by
  throttleRate: order_by
  updatedAt: order_by
  updatedBy: order_by
  weight: order_by
}

"""
response of any mutation on the table "rules"
"""
type rules_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rules!]!
}

"""
input type for inserting object relation for remote table "rules"
"""
input rules_obj_rel_insert_input {
  data: rules_insert_input!

  """upsert condition"""
  on_conflict: rules_on_conflict
}

"""
on_conflict condition type for table "rules"
"""
input rules_on_conflict {
  constraint: rules_constraint!
  update_columns: [rules_update_column!]! = []
  where: rules_bool_exp
}

"""Ordering options when selecting data from "rules"."""
input rules_order_by {
  action: order_by
  appId: order_by
  createdAt: order_by
  createdBy: order_by
  description: order_by
  destination: order_by
  destinationPort: order_by
  direction: order_by
  displayName: order_by
  id: order_by
  metadata: order_by
  orgId: order_by
  policies_aggregate: policies_aggregate_order_by
  protocol: order_by
  shared: order_by
  source: order_by
  sourcePort: order_by
  tags: order_by
  throttleRate: order_by
  updatedAt: order_by
  updatedBy: order_by
  weight: order_by
}

"""primary key columns input for table: rules"""
input rules_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input rules_prepend_input {
  metadata: jsonb
}

"""
select columns of table "rules"
"""
enum rules_select_column {
  """column name"""
  action

  """column name"""
  appId

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  description

  """column name"""
  destination

  """column name"""
  destinationPort

  """column name"""
  direction

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  orgId

  """column name"""
  protocol

  """column name"""
  shared

  """column name"""
  source

  """column name"""
  sourcePort

  """column name"""
  tags

  """column name"""
  throttleRate

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  weight
}

"""
select "rules_aggregate_bool_exp_bool_and_arguments_columns" columns of table "rules"
"""
enum rules_select_column_rules_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  shared
}

"""
select "rules_aggregate_bool_exp_bool_or_arguments_columns" columns of table "rules"
"""
enum rules_select_column_rules_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  shared
}

"""
input type for updating data in table "rules"
"""
input rules_set_input {
  action: action_enum
  appId: String
  createdAt: timestamptz
  createdBy: uuid
  description: String
  destination: String
  destinationPort: String
  direction: direction_enum
  displayName: String
  id: uuid
  metadata: jsonb
  orgId: uuid
  protocol: protocol_enum
  shared: Boolean
  source: String
  sourcePort: String
  tags: [String!]
  throttleRate: String
  updatedAt: timestamptz
  updatedBy: uuid
  weight: smallint
}

"""aggregate stddev on columns"""
type rules_stddev_fields {
  weight: Float
}

"""
order by stddev() on columns of table "rules"
"""
input rules_stddev_order_by {
  weight: order_by
}

"""aggregate stddev_pop on columns"""
type rules_stddev_pop_fields {
  weight: Float
}

"""
order by stddev_pop() on columns of table "rules"
"""
input rules_stddev_pop_order_by {
  weight: order_by
}

"""aggregate stddev_samp on columns"""
type rules_stddev_samp_fields {
  weight: Float
}

"""
order by stddev_samp() on columns of table "rules"
"""
input rules_stddev_samp_order_by {
  weight: order_by
}

"""
Streaming cursor of the table "rules"
"""
input rules_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rules_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rules_stream_cursor_value_input {
  action: action_enum
  appId: String
  createdAt: timestamptz
  createdBy: uuid
  description: String
  destination: String
  destinationPort: String
  direction: direction_enum
  displayName: String
  id: uuid
  metadata: jsonb
  orgId: uuid
  protocol: protocol_enum
  shared: Boolean
  source: String
  sourcePort: String
  tags: [String!]
  throttleRate: String
  updatedAt: timestamptz
  updatedBy: uuid
  weight: smallint
}

"""aggregate sum on columns"""
type rules_sum_fields {
  weight: smallint
}

"""
order by sum() on columns of table "rules"
"""
input rules_sum_order_by {
  weight: order_by
}

"""
update columns of table "rules"
"""
enum rules_update_column {
  """column name"""
  action

  """column name"""
  appId

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  description

  """column name"""
  destination

  """column name"""
  destinationPort

  """column name"""
  direction

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  orgId

  """column name"""
  protocol

  """column name"""
  shared

  """column name"""
  source

  """column name"""
  sourcePort

  """column name"""
  tags

  """column name"""
  throttleRate

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  weight
}

input rules_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: rules_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: rules_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: rules_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: rules_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: rules_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: rules_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: rules_set_input

  """filter the rows which have to be updated"""
  where: rules_bool_exp!
}

"""aggregate var_pop on columns"""
type rules_var_pop_fields {
  weight: Float
}

"""
order by var_pop() on columns of table "rules"
"""
input rules_var_pop_order_by {
  weight: order_by
}

"""aggregate var_samp on columns"""
type rules_var_samp_fields {
  weight: Float
}

"""
order by var_samp() on columns of table "rules"
"""
input rules_var_samp_order_by {
  weight: order_by
}

"""aggregate variance on columns"""
type rules_variance_fields {
  weight: Float
}

"""
order by variance() on columns of table "rules"
"""
input rules_variance_order_by {
  weight: order_by
}

"""setting type enum"""
type setting_type {
  description: String!
  value: String!
}

"""
aggregated selection of "setting_type"
"""
type setting_type_aggregate {
  aggregate: setting_type_aggregate_fields
  nodes: [setting_type!]!
}

"""
aggregate fields of "setting_type"
"""
type setting_type_aggregate_fields {
  count(columns: [setting_type_select_column!], distinct: Boolean): Int!
  max: setting_type_max_fields
  min: setting_type_min_fields
}

"""
Boolean expression to filter rows from the table "setting_type". All fields are combined with a logical 'AND'.
"""
input setting_type_bool_exp {
  _and: [setting_type_bool_exp!]
  _not: setting_type_bool_exp
  _or: [setting_type_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "setting_type"
"""
enum setting_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  setting_type_pkey
}

enum setting_type_enum {
  """ORGANIZATION"""
  org

  """USER"""
  user
}

"""
Boolean expression to compare columns of type "setting_type_enum". All fields are combined with logical 'AND'.
"""
input setting_type_enum_comparison_exp {
  _eq: setting_type_enum
  _in: [setting_type_enum!]
  _is_null: Boolean
  _neq: setting_type_enum
  _nin: [setting_type_enum!]
}

"""
input type for inserting data into table "setting_type"
"""
input setting_type_insert_input {
  description: String
  value: String
}

"""aggregate max on columns"""
type setting_type_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type setting_type_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "setting_type"
"""
type setting_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [setting_type!]!
}

"""
on_conflict condition type for table "setting_type"
"""
input setting_type_on_conflict {
  constraint: setting_type_constraint!
  update_columns: [setting_type_update_column!]! = []
  where: setting_type_bool_exp
}

"""Ordering options when selecting data from "setting_type"."""
input setting_type_order_by {
  description: order_by
  value: order_by
}

"""primary key columns input for table: setting_type"""
input setting_type_pk_columns_input {
  value: String!
}

"""
select columns of table "setting_type"
"""
enum setting_type_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "setting_type"
"""
input setting_type_set_input {
  description: String
  value: String
}

"""
Streaming cursor of the table "setting_type"
"""
input setting_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: setting_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input setting_type_stream_cursor_value_input {
  description: String
  value: String
}

"""
update columns of table "setting_type"
"""
enum setting_type_update_column {
  """column name"""
  description

  """column name"""
  value
}

input setting_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: setting_type_set_input

  """filter the rows which have to be updated"""
  where: setting_type_bool_exp!
}

"""
Table containing unique Setting keys and Feature Flags for Orgs and Users, act like enum
"""
type settings_metadata {
  allowedValues(
    """JSON select path"""
    path: String
  ): jsonb
  defaultValue(
    """JSON select path"""
    path: String
  ): jsonb
  description: String
  key: String!
  type: setting_type_enum!
}

"""
aggregated selection of "settings_metadata"
"""
type settings_metadata_aggregate {
  aggregate: settings_metadata_aggregate_fields
  nodes: [settings_metadata!]!
}

"""
aggregate fields of "settings_metadata"
"""
type settings_metadata_aggregate_fields {
  count(columns: [settings_metadata_select_column!], distinct: Boolean): Int!
  max: settings_metadata_max_fields
  min: settings_metadata_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input settings_metadata_append_input {
  allowedValues: jsonb
  defaultValue: jsonb
}

"""
Boolean expression to filter rows from the table "settings_metadata". All fields are combined with a logical 'AND'.
"""
input settings_metadata_bool_exp {
  _and: [settings_metadata_bool_exp!]
  _not: settings_metadata_bool_exp
  _or: [settings_metadata_bool_exp!]
  allowedValues: jsonb_comparison_exp
  defaultValue: jsonb_comparison_exp
  description: String_comparison_exp
  key: String_comparison_exp
  type: setting_type_enum_comparison_exp
}

"""
unique or primary key constraints on table "settings_metadata"
"""
enum settings_metadata_constraint {
  """
  unique or primary key constraint on columns "key"
  """
  settings_metadata_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input settings_metadata_delete_at_path_input {
  allowedValues: [String!]
  defaultValue: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input settings_metadata_delete_elem_input {
  allowedValues: Int
  defaultValue: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input settings_metadata_delete_key_input {
  allowedValues: String
  defaultValue: String
}

"""
input type for inserting data into table "settings_metadata"
"""
input settings_metadata_insert_input {
  allowedValues: jsonb
  defaultValue: jsonb
  description: String
  key: String
  type: setting_type_enum
}

"""aggregate max on columns"""
type settings_metadata_max_fields {
  description: String
  key: String
}

"""aggregate min on columns"""
type settings_metadata_min_fields {
  description: String
  key: String
}

"""
response of any mutation on the table "settings_metadata"
"""
type settings_metadata_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [settings_metadata!]!
}

"""
on_conflict condition type for table "settings_metadata"
"""
input settings_metadata_on_conflict {
  constraint: settings_metadata_constraint!
  update_columns: [settings_metadata_update_column!]! = []
  where: settings_metadata_bool_exp
}

"""Ordering options when selecting data from "settings_metadata"."""
input settings_metadata_order_by {
  allowedValues: order_by
  defaultValue: order_by
  description: order_by
  key: order_by
  type: order_by
}

"""primary key columns input for table: settings_metadata"""
input settings_metadata_pk_columns_input {
  key: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input settings_metadata_prepend_input {
  allowedValues: jsonb
  defaultValue: jsonb
}

"""
select columns of table "settings_metadata"
"""
enum settings_metadata_select_column {
  """column name"""
  allowedValues

  """column name"""
  defaultValue

  """column name"""
  description

  """column name"""
  key

  """column name"""
  type
}

"""
input type for updating data in table "settings_metadata"
"""
input settings_metadata_set_input {
  allowedValues: jsonb
  defaultValue: jsonb
  description: String
  key: String
  type: setting_type_enum
}

"""
Streaming cursor of the table "settings_metadata"
"""
input settings_metadata_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: settings_metadata_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input settings_metadata_stream_cursor_value_input {
  allowedValues: jsonb
  defaultValue: jsonb
  description: String
  key: String
  type: setting_type_enum
}

"""
update columns of table "settings_metadata"
"""
enum settings_metadata_update_column {
  """column name"""
  allowedValues

  """column name"""
  defaultValue

  """column name"""
  description

  """column name"""
  key

  """column name"""
  type
}

input settings_metadata_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: settings_metadata_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: settings_metadata_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: settings_metadata_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: settings_metadata_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: settings_metadata_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: settings_metadata_set_input

  """filter the rows which have to be updated"""
  where: settings_metadata_bool_exp!
}

scalar smallint

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

"""status enum"""
type status {
  description: String!
  value: String!
}

"""
aggregated selection of "status"
"""
type status_aggregate {
  aggregate: status_aggregate_fields
  nodes: [status!]!
}

"""
aggregate fields of "status"
"""
type status_aggregate_fields {
  count(columns: [status_select_column!], distinct: Boolean): Int!
  max: status_max_fields
  min: status_min_fields
}

"""
Boolean expression to filter rows from the table "status". All fields are combined with a logical 'AND'.
"""
input status_bool_exp {
  _and: [status_bool_exp!]
  _not: status_bool_exp
  _or: [status_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "status"
"""
enum status_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  status_pkey
}

enum status_enum {
  """ACCEPTED"""
  accepted

  """ACTIVE"""
  active

  """APPROVED"""
  approved

  """CLOSED"""
  closed

  """DECLINED"""
  declined

  """DISABLED"""
  disabled

  """PENDING"""
  pending

  """REJECTED"""
  rejected
}

"""
Boolean expression to compare columns of type "status_enum". All fields are combined with logical 'AND'.
"""
input status_enum_comparison_exp {
  _eq: status_enum
  _in: [status_enum!]
  _is_null: Boolean
  _neq: status_enum
  _nin: [status_enum!]
}

"""
input type for inserting data into table "status"
"""
input status_insert_input {
  description: String
  value: String
}

"""aggregate max on columns"""
type status_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type status_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "status"
"""
type status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [status!]!
}

"""
on_conflict condition type for table "status"
"""
input status_on_conflict {
  constraint: status_constraint!
  update_columns: [status_update_column!]! = []
  where: status_bool_exp
}

"""Ordering options when selecting data from "status"."""
input status_order_by {
  description: order_by
  value: order_by
}

"""primary key columns input for table: status"""
input status_pk_columns_input {
  value: String!
}

"""
select columns of table "status"
"""
enum status_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "status"
"""
input status_set_input {
  description: String
  value: String
}

"""
Streaming cursor of the table "status"
"""
input status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input status_stream_cursor_value_input {
  description: String
  value: String
}

"""
update columns of table "status"
"""
enum status_update_column {
  """column name"""
  description

  """column name"""
  value
}

input status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: status_set_input

  """filter the rows which have to be updated"""
  where: status_bool_exp!
}

"""policy subject type enum"""
type subject_type {
  description: String!
  value: String!
}

"""
aggregated selection of "subject_type"
"""
type subject_type_aggregate {
  aggregate: subject_type_aggregate_fields
  nodes: [subject_type!]!
}

"""
aggregate fields of "subject_type"
"""
type subject_type_aggregate_fields {
  count(columns: [subject_type_select_column!], distinct: Boolean): Int!
  max: subject_type_max_fields
  min: subject_type_min_fields
}

"""
Boolean expression to filter rows from the table "subject_type". All fields are combined with a logical 'AND'.
"""
input subject_type_bool_exp {
  _and: [subject_type_bool_exp!]
  _not: subject_type_bool_exp
  _or: [subject_type_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "subject_type"
"""
enum subject_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  subject_type_pkey
}

enum subject_type_enum {
  """DEVICE"""
  device

  """DEVICE_POOL"""
  device_pool

  """GROUP"""
  group

  """SERVICE_ACCOUNT"""
  service_account

  """USER"""
  user
}

"""
Boolean expression to compare columns of type "subject_type_enum". All fields are combined with logical 'AND'.
"""
input subject_type_enum_comparison_exp {
  _eq: subject_type_enum
  _in: [subject_type_enum!]
  _is_null: Boolean
  _neq: subject_type_enum
  _nin: [subject_type_enum!]
}

"""
input type for inserting data into table "subject_type"
"""
input subject_type_insert_input {
  description: String
  value: String
}

"""aggregate max on columns"""
type subject_type_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type subject_type_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "subject_type"
"""
type subject_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [subject_type!]!
}

"""
on_conflict condition type for table "subject_type"
"""
input subject_type_on_conflict {
  constraint: subject_type_constraint!
  update_columns: [subject_type_update_column!]! = []
  where: subject_type_bool_exp
}

"""Ordering options when selecting data from "subject_type"."""
input subject_type_order_by {
  description: order_by
  value: order_by
}

"""primary key columns input for table: subject_type"""
input subject_type_pk_columns_input {
  value: String!
}

"""
select columns of table "subject_type"
"""
enum subject_type_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "subject_type"
"""
input subject_type_set_input {
  description: String
  value: String
}

"""
Streaming cursor of the table "subject_type"
"""
input subject_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: subject_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input subject_type_stream_cursor_value_input {
  description: String
  value: String
}

"""
update columns of table "subject_type"
"""
enum subject_type_update_column {
  """column name"""
  description

  """column name"""
  value
}

input subject_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: subject_type_set_input

  """filter the rows which have to be updated"""
  where: subject_type_bool_exp!
}

type subscription_root {
  """
  fetch data from the table: "action"
  """
  action(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """
  fetch aggregated fields from the table: "action"
  """
  action_aggregate(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): action_aggregate!

  """fetch data from the table: "action" using primary key columns"""
  action_by_pk(value: String!): action

  """
  fetch data from the table in a streaming manner: "action"
  """
  action_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [action_stream_cursor_input]!

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """fetch data from the table: "auth.providers" using primary key columns"""
  authProvider(id: String!): authProviders

  """
  fetch data from the table: "auth.provider_requests" using primary key columns
  """
  authProviderRequest(id: uuid!): authProviderRequests

  """
  fetch data from the table: "auth.provider_requests"
  """
  authProviderRequests(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch aggregated fields from the table: "auth.provider_requests"
  """
  authProviderRequestsAggregate(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): authProviderRequests_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.provider_requests"
  """
  authProviderRequests_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authProviderRequests_stream_cursor_input]!

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch data from the table: "auth.providers"
  """
  authProviders(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  authProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): authProviders_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.providers"
  """
  authProviders_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authProviders_stream_cursor_input]!

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  authRefreshToken(id: uuid!): authRefreshTokens

  """
  fetch data from the table: "auth.refresh_token_types" using primary key columns
  """
  authRefreshTokenType(value: String!): authRefreshTokenTypes

  """
  fetch data from the table: "auth.refresh_token_types"
  """
  authRefreshTokenTypes(
    """distinct select on columns"""
    distinct_on: [authRefreshTokenTypes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokenTypes_order_by!]

    """filter the rows returned"""
    where: authRefreshTokenTypes_bool_exp
  ): [authRefreshTokenTypes!]!

  """
  fetch aggregated fields from the table: "auth.refresh_token_types"
  """
  authRefreshTokenTypesAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokenTypes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokenTypes_order_by!]

    """filter the rows returned"""
    where: authRefreshTokenTypes_bool_exp
  ): authRefreshTokenTypes_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.refresh_token_types"
  """
  authRefreshTokenTypes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authRefreshTokenTypes_stream_cursor_input]!

    """filter the rows returned"""
    where: authRefreshTokenTypes_bool_exp
  ): [authRefreshTokenTypes!]!

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  authRefreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  authRefreshTokensAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.refresh_tokens"
  """
  authRefreshTokens_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authRefreshTokens_stream_cursor_input]!

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """fetch data from the table: "auth.roles" using primary key columns"""
  authRole(role: String!): authRoles

  """
  fetch data from the table: "auth.roles"
  """
  authRoles(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  authRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): authRoles_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.roles"
  """
  authRoles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authRoles_stream_cursor_input]!

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch data from the table: "auth.user_providers" using primary key columns
  """
  authUserProvider(id: uuid!): authUserProviders

  """
  fetch data from the table: "auth.user_providers"
  """
  authUserProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """
  fetch aggregated fields from the table: "auth.user_providers"
  """
  authUserProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.user_providers"
  """
  authUserProviders_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserProviders_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """fetch data from the table: "auth.user_roles" using primary key columns"""
  authUserRole(id: uuid!): authUserRoles

  """
  fetch data from the table: "auth.user_roles"
  """
  authUserRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch aggregated fields from the table: "auth.user_roles"
  """
  authUserRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.user_roles"
  """
  authUserRoles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserRoles_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch data from the table: "auth.user_security_keys" using primary key columns
  """
  authUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  fetch data from the table: "auth.user_security_keys"
  """
  authUserSecurityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """
  fetch aggregated fields from the table: "auth.user_security_keys"
  """
  authUserSecurityKeysAggregate(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): authUserSecurityKeys_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.user_security_keys"
  """
  authUserSecurityKeys_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserSecurityKeys_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """fetch data from the table: "storage.buckets" using primary key columns"""
  bucket(id: String!): buckets

  """
  fetch data from the table: "storage.buckets"
  """
  buckets(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  fetch aggregated fields from the table: "storage.buckets"
  """
  bucketsAggregate(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): buckets_aggregate!

  """
  fetch data from the table in a streaming manner: "storage.buckets"
  """
  buckets_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [buckets_stream_cursor_input]!

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  execute function "device_associated_pools" which returns "pools"
  """
  device_associated_pools(
    """
    input parameters for function "device_associated_pools"
    """
    args: device_associated_pools_args!

    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]!

  """
  execute function "device_associated_pools" and query aggregates on result of table type "pools"
  """
  device_associated_pools_aggregate(
    """
    input parameters for function "device_associated_pools_aggregate"
    """
    args: device_associated_pools_args!

    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): pools_aggregate!

  """
  execute function "device_dissociated_pools" which returns "pools"
  """
  device_dissociated_pools(
    """
    input parameters for function "device_dissociated_pools"
    """
    args: device_dissociated_pools_args!

    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]!

  """
  execute function "device_dissociated_pools" and query aggregates on result of table type "pools"
  """
  device_dissociated_pools_aggregate(
    """
    input parameters for function "device_dissociated_pools_aggregate"
    """
    args: device_dissociated_pools_args!

    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): pools_aggregate!

  """
  fetch data from the table: "device_pools"
  """
  device_pools(
    """distinct select on columns"""
    distinct_on: [device_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pools_order_by!]

    """filter the rows returned"""
    where: device_pools_bool_exp
  ): [device_pools!]!

  """
  fetch aggregated fields from the table: "device_pools"
  """
  device_pools_aggregate(
    """distinct select on columns"""
    distinct_on: [device_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pools_order_by!]

    """filter the rows returned"""
    where: device_pools_bool_exp
  ): device_pools_aggregate!

  """fetch data from the table: "device_pools" using primary key columns"""
  device_pools_by_pk(deviceId: uuid!, poolId: uuid!): device_pools

  """
  fetch data from the table in a streaming manner: "device_pools"
  """
  device_pools_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [device_pools_stream_cursor_input]!

    """filter the rows returned"""
    where: device_pools_bool_exp
  ): [device_pools!]!

  """An array relationship"""
  devices(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """An aggregate relationship"""
  devices_aggregate(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): devices_aggregate!

  """fetch data from the table: "devices" using primary key columns"""
  devices_by_pk(id: uuid!): devices

  """
  fetch data from the table in a streaming manner: "devices"
  """
  devices_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [devices_stream_cursor_input]!

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """
  fetch data from the table: "direction"
  """
  direction(
    """distinct select on columns"""
    distinct_on: [direction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [direction_order_by!]

    """filter the rows returned"""
    where: direction_bool_exp
  ): [direction!]!

  """
  fetch aggregated fields from the table: "direction"
  """
  direction_aggregate(
    """distinct select on columns"""
    distinct_on: [direction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [direction_order_by!]

    """filter the rows returned"""
    where: direction_bool_exp
  ): direction_aggregate!

  """fetch data from the table: "direction" using primary key columns"""
  direction_by_pk(value: String!): direction

  """
  fetch data from the table in a streaming manner: "direction"
  """
  direction_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [direction_stream_cursor_input]!

    """filter the rows returned"""
    where: direction_bool_exp
  ): [direction!]!

  """fetch data from the table: "storage.files" using primary key columns"""
  file(id: uuid!): files

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "storage.files"
  """
  filesAggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """
  fetch data from the table in a streaming manner: "storage.files"
  """
  files_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [files_stream_cursor_input]!

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """An array relationship"""
  groups(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]!

  """An aggregate relationship"""
  groups_aggregate(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): groups_aggregate!

  """fetch data from the table: "groups" using primary key columns"""
  groups_by_pk(id: uuid!): groups

  """
  fetch data from the table in a streaming manner: "groups"
  """
  groups_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [groups_stream_cursor_input]!

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]!

  """An array relationship"""
  invitations(
    """distinct select on columns"""
    distinct_on: [invitations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitations_order_by!]

    """filter the rows returned"""
    where: invitations_bool_exp
  ): [invitations!]!

  """An aggregate relationship"""
  invitations_aggregate(
    """distinct select on columns"""
    distinct_on: [invitations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitations_order_by!]

    """filter the rows returned"""
    where: invitations_bool_exp
  ): invitations_aggregate!

  """fetch data from the table: "invitations" using primary key columns"""
  invitations_by_pk(email: citext!, orgId: uuid!): invitations

  """
  fetch data from the table in a streaming manner: "invitations"
  """
  invitations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [invitations_stream_cursor_input]!

    """filter the rows returned"""
    where: invitations_bool_exp
  ): [invitations!]!

  """An array relationship"""
  memberships(
    """distinct select on columns"""
    distinct_on: [memberships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [memberships_order_by!]

    """filter the rows returned"""
    where: memberships_bool_exp
  ): [memberships!]!

  """An aggregate relationship"""
  memberships_aggregate(
    """distinct select on columns"""
    distinct_on: [memberships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [memberships_order_by!]

    """filter the rows returned"""
    where: memberships_bool_exp
  ): memberships_aggregate!

  """fetch data from the table: "memberships" using primary key columns"""
  memberships_by_pk(orgId: uuid!, userId: uuid!): memberships

  """
  fetch data from the table in a streaming manner: "memberships"
  """
  memberships_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [memberships_stream_cursor_input]!

    """filter the rows returned"""
    where: memberships_bool_exp
  ): [memberships!]!

  """
  fetch data from the table: "notification_status"
  """
  notification_status(
    """distinct select on columns"""
    distinct_on: [notification_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_status_order_by!]

    """filter the rows returned"""
    where: notification_status_bool_exp
  ): [notification_status!]!

  """
  fetch aggregated fields from the table: "notification_status"
  """
  notification_status_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_status_order_by!]

    """filter the rows returned"""
    where: notification_status_bool_exp
  ): notification_status_aggregate!

  """
  fetch data from the table: "notification_status" using primary key columns
  """
  notification_status_by_pk(value: String!): notification_status

  """
  fetch data from the table in a streaming manner: "notification_status"
  """
  notification_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notification_status_stream_cursor_input]!

    """filter the rows returned"""
    where: notification_status_bool_exp
  ): [notification_status!]!

  """
  fetch data from the table: "notification_type"
  """
  notification_type(
    """distinct select on columns"""
    distinct_on: [notification_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_type_order_by!]

    """filter the rows returned"""
    where: notification_type_bool_exp
  ): [notification_type!]!

  """
  fetch aggregated fields from the table: "notification_type"
  """
  notification_type_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_type_order_by!]

    """filter the rows returned"""
    where: notification_type_bool_exp
  ): notification_type_aggregate!

  """
  fetch data from the table: "notification_type" using primary key columns
  """
  notification_type_by_pk(value: String!): notification_type

  """
  fetch data from the table in a streaming manner: "notification_type"
  """
  notification_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notification_type_stream_cursor_input]!

    """filter the rows returned"""
    where: notification_type_bool_exp
  ): [notification_type!]!

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """An aggregate relationship"""
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """fetch data from the table: "notifications" using primary key columns"""
  notifications_by_pk(id: uuid!): notifications

  """
  fetch data from the table in a streaming manner: "notifications"
  """
  notifications_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notifications_stream_cursor_input]!

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """
  fetch data from the table: "org_settings"
  """
  org_settings(
    """distinct select on columns"""
    distinct_on: [org_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_settings_order_by!]

    """filter the rows returned"""
    where: org_settings_bool_exp
  ): [org_settings!]!

  """
  fetch aggregated fields from the table: "org_settings"
  """
  org_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [org_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_settings_order_by!]

    """filter the rows returned"""
    where: org_settings_bool_exp
  ): org_settings_aggregate!

  """fetch data from the table: "org_settings" using primary key columns"""
  org_settings_by_pk(key: String!, orgId: uuid!): org_settings

  """
  fetch data from the table in a streaming manner: "org_settings"
  """
  org_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [org_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: org_settings_bool_exp
  ): [org_settings!]!

  """
  fetch data from the table: "org_settings_with_defaults"
  """
  org_settings_with_defaults(
    """distinct select on columns"""
    distinct_on: [org_settings_with_defaults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_settings_with_defaults_order_by!]

    """filter the rows returned"""
    where: org_settings_with_defaults_bool_exp
  ): [org_settings_with_defaults!]!

  """
  fetch aggregated fields from the table: "org_settings_with_defaults"
  """
  org_settings_with_defaults_aggregate(
    """distinct select on columns"""
    distinct_on: [org_settings_with_defaults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_settings_with_defaults_order_by!]

    """filter the rows returned"""
    where: org_settings_with_defaults_bool_exp
  ): org_settings_with_defaults_aggregate!

  """
  fetch data from the table in a streaming manner: "org_settings_with_defaults"
  """
  org_settings_with_defaults_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [org_settings_with_defaults_stream_cursor_input]!

    """filter the rows returned"""
    where: org_settings_with_defaults_bool_exp
  ): [org_settings_with_defaults!]!

  """
  fetch data from the table: "organizations"
  """
  organizations(
    """distinct select on columns"""
    distinct_on: [organizations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organizations_order_by!]

    """filter the rows returned"""
    where: organizations_bool_exp
  ): [organizations!]!

  """
  fetch aggregated fields from the table: "organizations"
  """
  organizations_aggregate(
    """distinct select on columns"""
    distinct_on: [organizations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organizations_order_by!]

    """filter the rows returned"""
    where: organizations_bool_exp
  ): organizations_aggregate!

  """fetch data from the table: "organizations" using primary key columns"""
  organizations_by_pk(id: uuid!): organizations

  """
  fetch data from the table in a streaming manner: "organizations"
  """
  organizations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [organizations_stream_cursor_input]!

    """filter the rows returned"""
    where: organizations_bool_exp
  ): [organizations!]!

  """
  fetch data from the table: "plan"
  """
  plan(
    """distinct select on columns"""
    distinct_on: [plan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [plan_order_by!]

    """filter the rows returned"""
    where: plan_bool_exp
  ): [plan!]!

  """
  fetch aggregated fields from the table: "plan"
  """
  plan_aggregate(
    """distinct select on columns"""
    distinct_on: [plan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [plan_order_by!]

    """filter the rows returned"""
    where: plan_bool_exp
  ): plan_aggregate!

  """fetch data from the table: "plan" using primary key columns"""
  plan_by_pk(value: String!): plan

  """
  fetch data from the table in a streaming manner: "plan"
  """
  plan_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [plan_stream_cursor_input]!

    """filter the rows returned"""
    where: plan_bool_exp
  ): [plan!]!

  """An array relationship"""
  policies(
    """distinct select on columns"""
    distinct_on: [policies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [policies_order_by!]

    """filter the rows returned"""
    where: policies_bool_exp
  ): [policies!]!

  """An aggregate relationship"""
  policies_aggregate(
    """distinct select on columns"""
    distinct_on: [policies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [policies_order_by!]

    """filter the rows returned"""
    where: policies_bool_exp
  ): policies_aggregate!

  """fetch data from the table: "policies" using primary key columns"""
  policies_by_pk(id: uuid!): policies

  """
  fetch data from the table in a streaming manner: "policies"
  """
  policies_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [policies_stream_cursor_input]!

    """filter the rows returned"""
    where: policies_bool_exp
  ): [policies!]!

  """An array relationship"""
  pools(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]!

  """An aggregate relationship"""
  pools_aggregate(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): pools_aggregate!

  """fetch data from the table: "pools" using primary key columns"""
  pools_by_pk(id: uuid!): pools

  """
  fetch data from the table in a streaming manner: "pools"
  """
  pools_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [pools_stream_cursor_input]!

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]!

  """
  fetch data from the table: "protocol"
  """
  protocol(
    """distinct select on columns"""
    distinct_on: [protocol_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [protocol_order_by!]

    """filter the rows returned"""
    where: protocol_bool_exp
  ): [protocol!]!

  """
  fetch aggregated fields from the table: "protocol"
  """
  protocol_aggregate(
    """distinct select on columns"""
    distinct_on: [protocol_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [protocol_order_by!]

    """filter the rows returned"""
    where: protocol_bool_exp
  ): protocol_aggregate!

  """fetch data from the table: "protocol" using primary key columns"""
  protocol_by_pk(value: String!): protocol

  """
  fetch data from the table in a streaming manner: "protocol"
  """
  protocol_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [protocol_stream_cursor_input]!

    """filter the rows returned"""
    where: protocol_bool_exp
  ): [protocol!]!

  """An array relationship"""
  rules(
    """distinct select on columns"""
    distinct_on: [rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rules_order_by!]

    """filter the rows returned"""
    where: rules_bool_exp
  ): [rules!]!

  """An aggregate relationship"""
  rules_aggregate(
    """distinct select on columns"""
    distinct_on: [rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rules_order_by!]

    """filter the rows returned"""
    where: rules_bool_exp
  ): rules_aggregate!

  """fetch data from the table: "rules" using primary key columns"""
  rules_by_pk(id: uuid!): rules

  """
  fetch data from the table in a streaming manner: "rules"
  """
  rules_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rules_stream_cursor_input]!

    """filter the rows returned"""
    where: rules_bool_exp
  ): [rules!]!

  """
  fetch data from the table: "setting_type"
  """
  setting_type(
    """distinct select on columns"""
    distinct_on: [setting_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [setting_type_order_by!]

    """filter the rows returned"""
    where: setting_type_bool_exp
  ): [setting_type!]!

  """
  fetch aggregated fields from the table: "setting_type"
  """
  setting_type_aggregate(
    """distinct select on columns"""
    distinct_on: [setting_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [setting_type_order_by!]

    """filter the rows returned"""
    where: setting_type_bool_exp
  ): setting_type_aggregate!

  """fetch data from the table: "setting_type" using primary key columns"""
  setting_type_by_pk(value: String!): setting_type

  """
  fetch data from the table in a streaming manner: "setting_type"
  """
  setting_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [setting_type_stream_cursor_input]!

    """filter the rows returned"""
    where: setting_type_bool_exp
  ): [setting_type!]!

  """
  fetch data from the table: "settings_metadata"
  """
  settings_metadata(
    """distinct select on columns"""
    distinct_on: [settings_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [settings_metadata_order_by!]

    """filter the rows returned"""
    where: settings_metadata_bool_exp
  ): [settings_metadata!]!

  """
  fetch aggregated fields from the table: "settings_metadata"
  """
  settings_metadata_aggregate(
    """distinct select on columns"""
    distinct_on: [settings_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [settings_metadata_order_by!]

    """filter the rows returned"""
    where: settings_metadata_bool_exp
  ): settings_metadata_aggregate!

  """
  fetch data from the table: "settings_metadata" using primary key columns
  """
  settings_metadata_by_pk(key: String!): settings_metadata

  """
  fetch data from the table in a streaming manner: "settings_metadata"
  """
  settings_metadata_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [settings_metadata_stream_cursor_input]!

    """filter the rows returned"""
    where: settings_metadata_bool_exp
  ): [settings_metadata!]!

  """
  fetch data from the table: "status"
  """
  status(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): [status!]!

  """
  fetch aggregated fields from the table: "status"
  """
  status_aggregate(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): status_aggregate!

  """fetch data from the table: "status" using primary key columns"""
  status_by_pk(value: String!): status

  """
  fetch data from the table in a streaming manner: "status"
  """
  status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [status_stream_cursor_input]!

    """filter the rows returned"""
    where: status_bool_exp
  ): [status!]!

  """
  fetch data from the table: "subject_type"
  """
  subject_type(
    """distinct select on columns"""
    distinct_on: [subject_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subject_type_order_by!]

    """filter the rows returned"""
    where: subject_type_bool_exp
  ): [subject_type!]!

  """
  fetch aggregated fields from the table: "subject_type"
  """
  subject_type_aggregate(
    """distinct select on columns"""
    distinct_on: [subject_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subject_type_order_by!]

    """filter the rows returned"""
    where: subject_type_bool_exp
  ): subject_type_aggregate!

  """fetch data from the table: "subject_type" using primary key columns"""
  subject_type_by_pk(value: String!): subject_type

  """
  fetch data from the table in a streaming manner: "subject_type"
  """
  subject_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [subject_type_stream_cursor_input]!

    """filter the rows returned"""
    where: subject_type_bool_exp
  ): [subject_type!]!

  """An array relationship"""
  subscriptions(
    """distinct select on columns"""
    distinct_on: [subscriptions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptions_order_by!]

    """filter the rows returned"""
    where: subscriptions_bool_exp
  ): [subscriptions!]!

  """An aggregate relationship"""
  subscriptions_aggregate(
    """distinct select on columns"""
    distinct_on: [subscriptions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptions_order_by!]

    """filter the rows returned"""
    where: subscriptions_bool_exp
  ): subscriptions_aggregate!

  """fetch data from the table: "subscriptions" using primary key columns"""
  subscriptions_by_pk(id: uuid!): subscriptions

  """
  fetch data from the table in a streaming manner: "subscriptions"
  """
  subscriptions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [subscriptions_stream_cursor_input]!

    """filter the rows returned"""
    where: subscriptions_bool_exp
  ): [subscriptions!]!

  """fetch data from the table: "auth.users" using primary key columns"""
  user(id: uuid!): users

  """
  execute function "user_associated_groups" which returns "groups"
  """
  user_associated_groups(
    """
    input parameters for function "user_associated_groups"
    """
    args: user_associated_groups_args!

    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]!

  """
  execute function "user_associated_groups" and query aggregates on result of table type "groups"
  """
  user_associated_groups_aggregate(
    """
    input parameters for function "user_associated_groups_aggregate"
    """
    args: user_associated_groups_args!

    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): groups_aggregate!

  """
  execute function "user_dissociated_groups" which returns "groups"
  """
  user_dissociated_groups(
    """
    input parameters for function "user_dissociated_groups"
    """
    args: user_dissociated_groups_args!

    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]!

  """
  execute function "user_dissociated_groups" and query aggregates on result of table type "groups"
  """
  user_dissociated_groups_aggregate(
    """
    input parameters for function "user_dissociated_groups_aggregate"
    """
    args: user_dissociated_groups_args!

    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): groups_aggregate!

  """
  fetch data from the table: "user_groups"
  """
  user_groups(
    """distinct select on columns"""
    distinct_on: [user_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_groups_order_by!]

    """filter the rows returned"""
    where: user_groups_bool_exp
  ): [user_groups!]!

  """
  fetch aggregated fields from the table: "user_groups"
  """
  user_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [user_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_groups_order_by!]

    """filter the rows returned"""
    where: user_groups_bool_exp
  ): user_groups_aggregate!

  """fetch data from the table: "user_groups" using primary key columns"""
  user_groups_by_pk(groupId: uuid!, userId: uuid!): user_groups

  """
  fetch data from the table in a streaming manner: "user_groups"
  """
  user_groups_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_groups_stream_cursor_input]!

    """filter the rows returned"""
    where: user_groups_bool_exp
  ): [user_groups!]!

  """
  fetch data from the table: "user_notifications"
  """
  user_notifications(
    """distinct select on columns"""
    distinct_on: [user_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_notifications_order_by!]

    """filter the rows returned"""
    where: user_notifications_bool_exp
  ): [user_notifications!]!

  """
  fetch aggregated fields from the table: "user_notifications"
  """
  user_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [user_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_notifications_order_by!]

    """filter the rows returned"""
    where: user_notifications_bool_exp
  ): user_notifications_aggregate!

  """
  fetch data from the table: "user_notifications" using primary key columns
  """
  user_notifications_by_pk(notificationId: uuid!, userId: uuid!): user_notifications

  """
  fetch data from the table in a streaming manner: "user_notifications"
  """
  user_notifications_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_notifications_stream_cursor_input]!

    """filter the rows returned"""
    where: user_notifications_bool_exp
  ): [user_notifications!]!

  """
  fetch data from the table: "user_settings"
  """
  user_settings(
    """distinct select on columns"""
    distinct_on: [user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_order_by!]

    """filter the rows returned"""
    where: user_settings_bool_exp
  ): [user_settings!]!

  """
  fetch aggregated fields from the table: "user_settings"
  """
  user_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_order_by!]

    """filter the rows returned"""
    where: user_settings_bool_exp
  ): user_settings_aggregate!

  """fetch data from the table: "user_settings" using primary key columns"""
  user_settings_by_pk(key: String!, orgId: uuid!, user_id: uuid!): user_settings

  """
  fetch data from the table in a streaming manner: "user_settings"
  """
  user_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: user_settings_bool_exp
  ): [user_settings!]!

  """
  fetch data from the table: "user_settings_with_defaults"
  """
  user_settings_with_defaults(
    """distinct select on columns"""
    distinct_on: [user_settings_with_defaults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_with_defaults_order_by!]

    """filter the rows returned"""
    where: user_settings_with_defaults_bool_exp
  ): [user_settings_with_defaults!]!

  """
  fetch aggregated fields from the table: "user_settings_with_defaults"
  """
  user_settings_with_defaults_aggregate(
    """distinct select on columns"""
    distinct_on: [user_settings_with_defaults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_with_defaults_order_by!]

    """filter the rows returned"""
    where: user_settings_with_defaults_bool_exp
  ): user_settings_with_defaults_aggregate!

  """
  fetch data from the table in a streaming manner: "user_settings_with_defaults"
  """
  user_settings_with_defaults_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_settings_with_defaults_stream_cursor_input]!

    """filter the rows returned"""
    where: user_settings_with_defaults_bool_exp
  ): [user_settings_with_defaults!]!

  """
  fetch data from the table: "auth.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "auth.users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.users"
  """
  users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [users_stream_cursor_input]!

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """fetch data from the table: "storage.virus" using primary key columns"""
  virus(id: uuid!): virus

  """
  fetch data from the table in a streaming manner: "storage.virus"
  """
  virus_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [virus_stream_cursor_input]!

    """filter the rows returned"""
    where: virus_bool_exp
  ): [virus!]!

  """
  fetch data from the table: "storage.virus"
  """
  viruses(
    """distinct select on columns"""
    distinct_on: [virus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [virus_order_by!]

    """filter the rows returned"""
    where: virus_bool_exp
  ): [virus!]!

  """
  fetch aggregated fields from the table: "storage.virus"
  """
  virusesAggregate(
    """distinct select on columns"""
    distinct_on: [virus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [virus_order_by!]

    """filter the rows returned"""
    where: virus_bool_exp
  ): virus_aggregate!
}

"""Table containing subscriptions for an organization"""
type subscriptions {
  createdAt: timestamptz!
  createdBy: uuid!
  credits: Int!
  id: uuid!
  orgId: uuid!

  """An object relationship"""
  organization: organizations!
  plan: plan_enum!
  status: status_enum!
  stripeCheckoutSessionId: String
  stripeCustomerId: String
  stripeSubscriptionId: String
  updatedAt: timestamptz!
  updatedBy: uuid!
  validUntil: timestamptz!
}

"""
aggregated selection of "subscriptions"
"""
type subscriptions_aggregate {
  aggregate: subscriptions_aggregate_fields
  nodes: [subscriptions!]!
}

input subscriptions_aggregate_bool_exp {
  count: subscriptions_aggregate_bool_exp_count
}

input subscriptions_aggregate_bool_exp_count {
  arguments: [subscriptions_select_column!]
  distinct: Boolean
  filter: subscriptions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "subscriptions"
"""
type subscriptions_aggregate_fields {
  avg: subscriptions_avg_fields
  count(columns: [subscriptions_select_column!], distinct: Boolean): Int!
  max: subscriptions_max_fields
  min: subscriptions_min_fields
  stddev: subscriptions_stddev_fields
  stddev_pop: subscriptions_stddev_pop_fields
  stddev_samp: subscriptions_stddev_samp_fields
  sum: subscriptions_sum_fields
  var_pop: subscriptions_var_pop_fields
  var_samp: subscriptions_var_samp_fields
  variance: subscriptions_variance_fields
}

"""
order by aggregate values of table "subscriptions"
"""
input subscriptions_aggregate_order_by {
  avg: subscriptions_avg_order_by
  count: order_by
  max: subscriptions_max_order_by
  min: subscriptions_min_order_by
  stddev: subscriptions_stddev_order_by
  stddev_pop: subscriptions_stddev_pop_order_by
  stddev_samp: subscriptions_stddev_samp_order_by
  sum: subscriptions_sum_order_by
  var_pop: subscriptions_var_pop_order_by
  var_samp: subscriptions_var_samp_order_by
  variance: subscriptions_variance_order_by
}

"""
input type for inserting array relation for remote table "subscriptions"
"""
input subscriptions_arr_rel_insert_input {
  data: [subscriptions_insert_input!]!

  """upsert condition"""
  on_conflict: subscriptions_on_conflict
}

"""aggregate avg on columns"""
type subscriptions_avg_fields {
  credits: Float
}

"""
order by avg() on columns of table "subscriptions"
"""
input subscriptions_avg_order_by {
  credits: order_by
}

"""
Boolean expression to filter rows from the table "subscriptions". All fields are combined with a logical 'AND'.
"""
input subscriptions_bool_exp {
  _and: [subscriptions_bool_exp!]
  _not: subscriptions_bool_exp
  _or: [subscriptions_bool_exp!]
  createdAt: timestamptz_comparison_exp
  createdBy: uuid_comparison_exp
  credits: Int_comparison_exp
  id: uuid_comparison_exp
  orgId: uuid_comparison_exp
  organization: organizations_bool_exp
  plan: plan_enum_comparison_exp
  status: status_enum_comparison_exp
  stripeCheckoutSessionId: String_comparison_exp
  stripeCustomerId: String_comparison_exp
  stripeSubscriptionId: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: uuid_comparison_exp
  validUntil: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "subscriptions"
"""
enum subscriptions_constraint {
  """
  unique or primary key constraint on columns "plan", "org_id"
  """
  subscriptions_org_id_plan_key

  """
  unique or primary key constraint on columns "id"
  """
  subscriptions_pkey
}

"""
input type for incrementing numeric columns in table "subscriptions"
"""
input subscriptions_inc_input {
  credits: Int
}

"""
input type for inserting data into table "subscriptions"
"""
input subscriptions_insert_input {
  createdAt: timestamptz
  createdBy: uuid
  credits: Int
  id: uuid
  orgId: uuid
  organization: organizations_obj_rel_insert_input
  plan: plan_enum
  status: status_enum
  stripeCheckoutSessionId: String
  stripeCustomerId: String
  stripeSubscriptionId: String
  updatedAt: timestamptz
  updatedBy: uuid
  validUntil: timestamptz
}

"""aggregate max on columns"""
type subscriptions_max_fields {
  createdAt: timestamptz
  createdBy: uuid
  credits: Int
  id: uuid
  orgId: uuid
  stripeCheckoutSessionId: String
  stripeCustomerId: String
  stripeSubscriptionId: String
  updatedAt: timestamptz
  updatedBy: uuid
  validUntil: timestamptz
}

"""
order by max() on columns of table "subscriptions"
"""
input subscriptions_max_order_by {
  createdAt: order_by
  createdBy: order_by
  credits: order_by
  id: order_by
  orgId: order_by
  stripeCheckoutSessionId: order_by
  stripeCustomerId: order_by
  stripeSubscriptionId: order_by
  updatedAt: order_by
  updatedBy: order_by
  validUntil: order_by
}

"""aggregate min on columns"""
type subscriptions_min_fields {
  createdAt: timestamptz
  createdBy: uuid
  credits: Int
  id: uuid
  orgId: uuid
  stripeCheckoutSessionId: String
  stripeCustomerId: String
  stripeSubscriptionId: String
  updatedAt: timestamptz
  updatedBy: uuid
  validUntil: timestamptz
}

"""
order by min() on columns of table "subscriptions"
"""
input subscriptions_min_order_by {
  createdAt: order_by
  createdBy: order_by
  credits: order_by
  id: order_by
  orgId: order_by
  stripeCheckoutSessionId: order_by
  stripeCustomerId: order_by
  stripeSubscriptionId: order_by
  updatedAt: order_by
  updatedBy: order_by
  validUntil: order_by
}

"""
response of any mutation on the table "subscriptions"
"""
type subscriptions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [subscriptions!]!
}

"""
on_conflict condition type for table "subscriptions"
"""
input subscriptions_on_conflict {
  constraint: subscriptions_constraint!
  update_columns: [subscriptions_update_column!]! = []
  where: subscriptions_bool_exp
}

"""Ordering options when selecting data from "subscriptions"."""
input subscriptions_order_by {
  createdAt: order_by
  createdBy: order_by
  credits: order_by
  id: order_by
  orgId: order_by
  organization: organizations_order_by
  plan: order_by
  status: order_by
  stripeCheckoutSessionId: order_by
  stripeCustomerId: order_by
  stripeSubscriptionId: order_by
  updatedAt: order_by
  updatedBy: order_by
  validUntil: order_by
}

"""primary key columns input for table: subscriptions"""
input subscriptions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "subscriptions"
"""
enum subscriptions_select_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  credits

  """column name"""
  id

  """column name"""
  orgId

  """column name"""
  plan

  """column name"""
  status

  """column name"""
  stripeCheckoutSessionId

  """column name"""
  stripeCustomerId

  """column name"""
  stripeSubscriptionId

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  validUntil
}

"""
input type for updating data in table "subscriptions"
"""
input subscriptions_set_input {
  createdAt: timestamptz
  createdBy: uuid
  credits: Int
  id: uuid
  orgId: uuid
  plan: plan_enum
  status: status_enum
  stripeCheckoutSessionId: String
  stripeCustomerId: String
  stripeSubscriptionId: String
  updatedAt: timestamptz
  updatedBy: uuid
  validUntil: timestamptz
}

"""aggregate stddev on columns"""
type subscriptions_stddev_fields {
  credits: Float
}

"""
order by stddev() on columns of table "subscriptions"
"""
input subscriptions_stddev_order_by {
  credits: order_by
}

"""aggregate stddev_pop on columns"""
type subscriptions_stddev_pop_fields {
  credits: Float
}

"""
order by stddev_pop() on columns of table "subscriptions"
"""
input subscriptions_stddev_pop_order_by {
  credits: order_by
}

"""aggregate stddev_samp on columns"""
type subscriptions_stddev_samp_fields {
  credits: Float
}

"""
order by stddev_samp() on columns of table "subscriptions"
"""
input subscriptions_stddev_samp_order_by {
  credits: order_by
}

"""
Streaming cursor of the table "subscriptions"
"""
input subscriptions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: subscriptions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input subscriptions_stream_cursor_value_input {
  createdAt: timestamptz
  createdBy: uuid
  credits: Int
  id: uuid
  orgId: uuid
  plan: plan_enum
  status: status_enum
  stripeCheckoutSessionId: String
  stripeCustomerId: String
  stripeSubscriptionId: String
  updatedAt: timestamptz
  updatedBy: uuid
  validUntil: timestamptz
}

"""aggregate sum on columns"""
type subscriptions_sum_fields {
  credits: Int
}

"""
order by sum() on columns of table "subscriptions"
"""
input subscriptions_sum_order_by {
  credits: order_by
}

"""
update columns of table "subscriptions"
"""
enum subscriptions_update_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  credits

  """column name"""
  id

  """column name"""
  orgId

  """column name"""
  plan

  """column name"""
  status

  """column name"""
  stripeCheckoutSessionId

  """column name"""
  stripeCustomerId

  """column name"""
  stripeSubscriptionId

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  validUntil
}

input subscriptions_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: subscriptions_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: subscriptions_set_input

  """filter the rows which have to be updated"""
  where: subscriptions_bool_exp!
}

"""aggregate var_pop on columns"""
type subscriptions_var_pop_fields {
  credits: Float
}

"""
order by var_pop() on columns of table "subscriptions"
"""
input subscriptions_var_pop_order_by {
  credits: order_by
}

"""aggregate var_samp on columns"""
type subscriptions_var_samp_fields {
  credits: Float
}

"""
order by var_samp() on columns of table "subscriptions"
"""
input subscriptions_var_samp_order_by {
  credits: order_by
}

"""aggregate variance on columns"""
type subscriptions_variance_fields {
  credits: Float
}

"""
order by variance() on columns of table "subscriptions"
"""
input subscriptions_variance_order_by {
  credits: order_by
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

input user_associated_groups_args {
  user_row: users_scalar
}

input user_dissociated_groups_args {
  user_row: users_scalar
}

"""User to Group association table"""
type user_groups {
  """An object relationship"""
  group: groups!
  groupId: uuid!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "user_groups"
"""
type user_groups_aggregate {
  aggregate: user_groups_aggregate_fields
  nodes: [user_groups!]!
}

input user_groups_aggregate_bool_exp {
  count: user_groups_aggregate_bool_exp_count
}

input user_groups_aggregate_bool_exp_count {
  arguments: [user_groups_select_column!]
  distinct: Boolean
  filter: user_groups_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_groups"
"""
type user_groups_aggregate_fields {
  count(columns: [user_groups_select_column!], distinct: Boolean): Int!
  max: user_groups_max_fields
  min: user_groups_min_fields
}

"""
order by aggregate values of table "user_groups"
"""
input user_groups_aggregate_order_by {
  count: order_by
  max: user_groups_max_order_by
  min: user_groups_min_order_by
}

"""
input type for inserting array relation for remote table "user_groups"
"""
input user_groups_arr_rel_insert_input {
  data: [user_groups_insert_input!]!

  """upsert condition"""
  on_conflict: user_groups_on_conflict
}

"""
Boolean expression to filter rows from the table "user_groups". All fields are combined with a logical 'AND'.
"""
input user_groups_bool_exp {
  _and: [user_groups_bool_exp!]
  _not: user_groups_bool_exp
  _or: [user_groups_bool_exp!]
  group: groups_bool_exp
  groupId: uuid_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_groups"
"""
enum user_groups_constraint {
  """
  unique or primary key constraint on columns "user_id", "group_id"
  """
  user_groups_pkey
}

"""
input type for inserting data into table "user_groups"
"""
input user_groups_insert_input {
  group: groups_obj_rel_insert_input
  groupId: uuid
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type user_groups_max_fields {
  groupId: uuid
  userId: uuid
}

"""
order by max() on columns of table "user_groups"
"""
input user_groups_max_order_by {
  groupId: order_by
  userId: order_by
}

"""aggregate min on columns"""
type user_groups_min_fields {
  groupId: uuid
  userId: uuid
}

"""
order by min() on columns of table "user_groups"
"""
input user_groups_min_order_by {
  groupId: order_by
  userId: order_by
}

"""
response of any mutation on the table "user_groups"
"""
type user_groups_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_groups!]!
}

"""
on_conflict condition type for table "user_groups"
"""
input user_groups_on_conflict {
  constraint: user_groups_constraint!
  update_columns: [user_groups_update_column!]! = []
  where: user_groups_bool_exp
}

"""Ordering options when selecting data from "user_groups"."""
input user_groups_order_by {
  group: groups_order_by
  groupId: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: user_groups"""
input user_groups_pk_columns_input {
  groupId: uuid!
  userId: uuid!
}

"""
select columns of table "user_groups"
"""
enum user_groups_select_column {
  """column name"""
  groupId

  """column name"""
  userId
}

"""
input type for updating data in table "user_groups"
"""
input user_groups_set_input {
  groupId: uuid
  userId: uuid
}

"""
Streaming cursor of the table "user_groups"
"""
input user_groups_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_groups_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_groups_stream_cursor_value_input {
  groupId: uuid
  userId: uuid
}

"""
update columns of table "user_groups"
"""
enum user_groups_update_column {
  """column name"""
  groupId

  """column name"""
  userId
}

input user_groups_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_groups_set_input

  """filter the rows which have to be updated"""
  where: user_groups_bool_exp!
}

"""Table containing User's  Notifications collection"""
type user_notifications {
  createdAt: timestamptz!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  notification: notifications!
  notificationId: uuid!
  status: notification_status_enum!
  updatedAt: timestamptz!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "user_notifications"
"""
type user_notifications_aggregate {
  aggregate: user_notifications_aggregate_fields
  nodes: [user_notifications!]!
}

input user_notifications_aggregate_bool_exp {
  count: user_notifications_aggregate_bool_exp_count
}

input user_notifications_aggregate_bool_exp_count {
  arguments: [user_notifications_select_column!]
  distinct: Boolean
  filter: user_notifications_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_notifications"
"""
type user_notifications_aggregate_fields {
  count(columns: [user_notifications_select_column!], distinct: Boolean): Int!
  max: user_notifications_max_fields
  min: user_notifications_min_fields
}

"""
order by aggregate values of table "user_notifications"
"""
input user_notifications_aggregate_order_by {
  count: order_by
  max: user_notifications_max_order_by
  min: user_notifications_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input user_notifications_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "user_notifications"
"""
input user_notifications_arr_rel_insert_input {
  data: [user_notifications_insert_input!]!

  """upsert condition"""
  on_conflict: user_notifications_on_conflict
}

"""
Boolean expression to filter rows from the table "user_notifications". All fields are combined with a logical 'AND'.
"""
input user_notifications_bool_exp {
  _and: [user_notifications_bool_exp!]
  _not: user_notifications_bool_exp
  _or: [user_notifications_bool_exp!]
  createdAt: timestamptz_comparison_exp
  metadata: jsonb_comparison_exp
  notification: notifications_bool_exp
  notificationId: uuid_comparison_exp
  status: notification_status_enum_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_notifications"
"""
enum user_notifications_constraint {
  """
  unique or primary key constraint on columns "user_id", "notification_id"
  """
  user_notifications_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input user_notifications_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input user_notifications_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input user_notifications_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "user_notifications"
"""
input user_notifications_insert_input {
  createdAt: timestamptz
  metadata: jsonb
  notification: notifications_obj_rel_insert_input
  notificationId: uuid
  status: notification_status_enum
  updatedAt: timestamptz
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type user_notifications_max_fields {
  createdAt: timestamptz
  notificationId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "user_notifications"
"""
input user_notifications_max_order_by {
  createdAt: order_by
  notificationId: order_by
  updatedAt: order_by
  userId: order_by
}

"""aggregate min on columns"""
type user_notifications_min_fields {
  createdAt: timestamptz
  notificationId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "user_notifications"
"""
input user_notifications_min_order_by {
  createdAt: order_by
  notificationId: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "user_notifications"
"""
type user_notifications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_notifications!]!
}

"""
on_conflict condition type for table "user_notifications"
"""
input user_notifications_on_conflict {
  constraint: user_notifications_constraint!
  update_columns: [user_notifications_update_column!]! = []
  where: user_notifications_bool_exp
}

"""Ordering options when selecting data from "user_notifications"."""
input user_notifications_order_by {
  createdAt: order_by
  metadata: order_by
  notification: notifications_order_by
  notificationId: order_by
  status: order_by
  updatedAt: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: user_notifications"""
input user_notifications_pk_columns_input {
  notificationId: uuid!
  userId: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input user_notifications_prepend_input {
  metadata: jsonb
}

"""
select columns of table "user_notifications"
"""
enum user_notifications_select_column {
  """column name"""
  createdAt

  """column name"""
  metadata

  """column name"""
  notificationId

  """column name"""
  status

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "user_notifications"
"""
input user_notifications_set_input {
  createdAt: timestamptz
  metadata: jsonb
  notificationId: uuid
  status: notification_status_enum
  updatedAt: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "user_notifications"
"""
input user_notifications_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_notifications_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_notifications_stream_cursor_value_input {
  createdAt: timestamptz
  metadata: jsonb
  notificationId: uuid
  status: notification_status_enum
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "user_notifications"
"""
enum user_notifications_update_column {
  """column name"""
  createdAt

  """column name"""
  metadata

  """column name"""
  notificationId

  """column name"""
  status

  """column name"""
  updatedAt

  """column name"""
  userId
}

input user_notifications_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: user_notifications_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: user_notifications_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: user_notifications_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: user_notifications_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: user_notifications_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_notifications_set_input

  """filter the rows which have to be updated"""
  where: user_notifications_bool_exp!
}

"""Table containing user's settings and feature flags"""
type user_settings {
  createdAt: timestamptz!
  createdBy: uuid!
  key: String!
  orgId: uuid!
  updatedAt: timestamptz!
  updatedBy: uuid!
  user_id: uuid!
  value(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "user_settings"
"""
type user_settings_aggregate {
  aggregate: user_settings_aggregate_fields
  nodes: [user_settings!]!
}

input user_settings_aggregate_bool_exp {
  count: user_settings_aggregate_bool_exp_count
}

input user_settings_aggregate_bool_exp_count {
  arguments: [user_settings_select_column!]
  distinct: Boolean
  filter: user_settings_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_settings"
"""
type user_settings_aggregate_fields {
  count(columns: [user_settings_select_column!], distinct: Boolean): Int!
  max: user_settings_max_fields
  min: user_settings_min_fields
}

"""
order by aggregate values of table "user_settings"
"""
input user_settings_aggregate_order_by {
  count: order_by
  max: user_settings_max_order_by
  min: user_settings_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input user_settings_append_input {
  value: jsonb
}

"""
input type for inserting array relation for remote table "user_settings"
"""
input user_settings_arr_rel_insert_input {
  data: [user_settings_insert_input!]!

  """upsert condition"""
  on_conflict: user_settings_on_conflict
}

"""
Boolean expression to filter rows from the table "user_settings". All fields are combined with a logical 'AND'.
"""
input user_settings_bool_exp {
  _and: [user_settings_bool_exp!]
  _not: user_settings_bool_exp
  _or: [user_settings_bool_exp!]
  createdAt: timestamptz_comparison_exp
  createdBy: uuid_comparison_exp
  key: String_comparison_exp
  orgId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: uuid_comparison_exp
  user_id: uuid_comparison_exp
  value: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "user_settings"
"""
enum user_settings_constraint {
  """
  unique or primary key constraint on columns "user_id", "key", "org_id"
  """
  user_settings_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input user_settings_delete_at_path_input {
  value: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input user_settings_delete_elem_input {
  value: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input user_settings_delete_key_input {
  value: String
}

"""
input type for inserting data into table "user_settings"
"""
input user_settings_insert_input {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
  user_id: uuid
  value: jsonb
}

"""aggregate max on columns"""
type user_settings_max_fields {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
  user_id: uuid
}

"""
order by max() on columns of table "user_settings"
"""
input user_settings_max_order_by {
  createdAt: order_by
  createdBy: order_by
  key: order_by
  orgId: order_by
  updatedAt: order_by
  updatedBy: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type user_settings_min_fields {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
  user_id: uuid
}

"""
order by min() on columns of table "user_settings"
"""
input user_settings_min_order_by {
  createdAt: order_by
  createdBy: order_by
  key: order_by
  orgId: order_by
  updatedAt: order_by
  updatedBy: order_by
  user_id: order_by
}

"""
response of any mutation on the table "user_settings"
"""
type user_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_settings!]!
}

"""
on_conflict condition type for table "user_settings"
"""
input user_settings_on_conflict {
  constraint: user_settings_constraint!
  update_columns: [user_settings_update_column!]! = []
  where: user_settings_bool_exp
}

"""Ordering options when selecting data from "user_settings"."""
input user_settings_order_by {
  createdAt: order_by
  createdBy: order_by
  key: order_by
  orgId: order_by
  updatedAt: order_by
  updatedBy: order_by
  user_id: order_by
  value: order_by
}

"""primary key columns input for table: user_settings"""
input user_settings_pk_columns_input {
  key: String!
  orgId: uuid!
  user_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input user_settings_prepend_input {
  value: jsonb
}

"""
select columns of table "user_settings"
"""
enum user_settings_select_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  key

  """column name"""
  orgId

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  user_id

  """column name"""
  value
}

"""
input type for updating data in table "user_settings"
"""
input user_settings_set_input {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
  user_id: uuid
  value: jsonb
}

"""
Streaming cursor of the table "user_settings"
"""
input user_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_settings_stream_cursor_value_input {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
  user_id: uuid
  value: jsonb
}

"""
update columns of table "user_settings"
"""
enum user_settings_update_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  key

  """column name"""
  orgId

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  user_id

  """column name"""
  value
}

input user_settings_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: user_settings_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: user_settings_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: user_settings_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: user_settings_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: user_settings_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_settings_set_input

  """filter the rows which have to be updated"""
  where: user_settings_bool_exp!
}

"""
View that expand public.user_setting table with missing key/values from public.settings_metadata
"""
type user_settings_with_defaults {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
  userId: uuid
  value(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "user_settings_with_defaults"
"""
type user_settings_with_defaults_aggregate {
  aggregate: user_settings_with_defaults_aggregate_fields
  nodes: [user_settings_with_defaults!]!
}

input user_settings_with_defaults_aggregate_bool_exp {
  count: user_settings_with_defaults_aggregate_bool_exp_count
}

input user_settings_with_defaults_aggregate_bool_exp_count {
  arguments: [user_settings_with_defaults_select_column!]
  distinct: Boolean
  filter: user_settings_with_defaults_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_settings_with_defaults"
"""
type user_settings_with_defaults_aggregate_fields {
  count(columns: [user_settings_with_defaults_select_column!], distinct: Boolean): Int!
  max: user_settings_with_defaults_max_fields
  min: user_settings_with_defaults_min_fields
}

"""
order by aggregate values of table "user_settings_with_defaults"
"""
input user_settings_with_defaults_aggregate_order_by {
  count: order_by
  max: user_settings_with_defaults_max_order_by
  min: user_settings_with_defaults_min_order_by
}

"""
input type for inserting array relation for remote table "user_settings_with_defaults"
"""
input user_settings_with_defaults_arr_rel_insert_input {
  data: [user_settings_with_defaults_insert_input!]!
}

"""
Boolean expression to filter rows from the table "user_settings_with_defaults". All fields are combined with a logical 'AND'.
"""
input user_settings_with_defaults_bool_exp {
  _and: [user_settings_with_defaults_bool_exp!]
  _not: user_settings_with_defaults_bool_exp
  _or: [user_settings_with_defaults_bool_exp!]
  createdAt: timestamptz_comparison_exp
  createdBy: uuid_comparison_exp
  key: String_comparison_exp
  orgId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: uuid_comparison_exp
  userId: uuid_comparison_exp
  value: jsonb_comparison_exp
}

"""
input type for inserting data into table "user_settings_with_defaults"
"""
input user_settings_with_defaults_insert_input {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
  userId: uuid
  value: jsonb
}

"""aggregate max on columns"""
type user_settings_with_defaults_max_fields {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
  userId: uuid
}

"""
order by max() on columns of table "user_settings_with_defaults"
"""
input user_settings_with_defaults_max_order_by {
  createdAt: order_by
  createdBy: order_by
  key: order_by
  orgId: order_by
  updatedAt: order_by
  updatedBy: order_by
  userId: order_by
}

"""aggregate min on columns"""
type user_settings_with_defaults_min_fields {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
  userId: uuid
}

"""
order by min() on columns of table "user_settings_with_defaults"
"""
input user_settings_with_defaults_min_order_by {
  createdAt: order_by
  createdBy: order_by
  key: order_by
  orgId: order_by
  updatedAt: order_by
  updatedBy: order_by
  userId: order_by
}

"""
Ordering options when selecting data from "user_settings_with_defaults".
"""
input user_settings_with_defaults_order_by {
  createdAt: order_by
  createdBy: order_by
  key: order_by
  orgId: order_by
  updatedAt: order_by
  updatedBy: order_by
  userId: order_by
  value: order_by
}

"""
select columns of table "user_settings_with_defaults"
"""
enum user_settings_with_defaults_select_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  key

  """column name"""
  orgId

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  userId

  """column name"""
  value
}

"""
Streaming cursor of the table "user_settings_with_defaults"
"""
input user_settings_with_defaults_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_settings_with_defaults_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_settings_with_defaults_stream_cursor_value_input {
  createdAt: timestamptz
  createdBy: uuid
  key: String
  orgId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
  userId: uuid
  value: jsonb
}

"""
User account information. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type users {
  activeMfaType: String

  """An array relationship"""
  allowedOrgs(
    """distinct select on columns"""
    distinct_on: [memberships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [memberships_order_by!]

    """filter the rows returned"""
    where: memberships_bool_exp
  ): [memberships!]!

  """An aggregate relationship"""
  allowedOrgs_aggregate(
    """distinct select on columns"""
    distinct_on: [memberships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [memberships_order_by!]

    """filter the rows returned"""
    where: memberships_bool_exp
  ): memberships_aggregate!

  """Used as Computed Field on Users Table"""
  associatedGroups(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]
  avatarUrl: String!
  createdAt: timestamptz!
  currentChallenge: String

  """An object relationship"""
  currentOrg: organizations
  defaultOrg: uuid
  defaultRole: String!

  """An object relationship"""
  defaultRoleByRole: authRoles!
  disabled: Boolean!
  displayName: String!

  """Used as Computed Field on Users Table"""
  dissociatedGroups(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]
  email: citext
  emailVerified: Boolean!

  """An array relationship"""
  groups(
    """distinct select on columns"""
    distinct_on: [user_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_groups_order_by!]

    """filter the rows returned"""
    where: user_groups_bool_exp
  ): [user_groups!]!

  """An aggregate relationship"""
  groups_aggregate(
    """distinct select on columns"""
    distinct_on: [user_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_groups_order_by!]

    """filter the rows returned"""
    where: user_groups_bool_exp
  ): user_groups_aggregate!
  id: uuid!

  """An array relationship"""
  invitations(
    """distinct select on columns"""
    distinct_on: [invitations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitations_order_by!]

    """filter the rows returned"""
    where: invitations_bool_exp
  ): [invitations!]!

  """An aggregate relationship"""
  invitations_aggregate(
    """distinct select on columns"""
    distinct_on: [invitations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitations_order_by!]

    """filter the rows returned"""
    where: invitations_bool_exp
  ): invitations_aggregate!
  isAnonymous: Boolean!
  lastSeen: timestamptz
  locale: String!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  newEmail: citext

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [user_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_notifications_order_by!]

    """filter the rows returned"""
    where: user_notifications_bool_exp
  ): [user_notifications!]!

  """An aggregate relationship"""
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [user_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_notifications_order_by!]

    """filter the rows returned"""
    where: user_notifications_bool_exp
  ): user_notifications_aggregate!
  otpHash: String
  otpHashExpiresAt: timestamptz!
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean!

  """An array relationship"""
  refreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """An aggregate relationship"""
  refreshTokens_aggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """An aggregate relationship"""
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """An array relationship"""
  securityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """An aggregate relationship"""
  securityKeys_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): authUserSecurityKeys_aggregate!

  """An array relationship"""
  settings(
    """distinct select on columns"""
    distinct_on: [user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_order_by!]

    """filter the rows returned"""
    where: user_settings_bool_exp
  ): [user_settings!]!

  """An array relationship"""
  settingsWithDefaults(
    """distinct select on columns"""
    distinct_on: [user_settings_with_defaults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_with_defaults_order_by!]

    """filter the rows returned"""
    where: user_settings_with_defaults_bool_exp
  ): [user_settings_with_defaults!]!

  """An aggregate relationship"""
  settingsWithDefaults_aggregate(
    """distinct select on columns"""
    distinct_on: [user_settings_with_defaults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_with_defaults_order_by!]

    """filter the rows returned"""
    where: user_settings_with_defaults_bool_exp
  ): user_settings_with_defaults_aggregate!

  """An aggregate relationship"""
  settings_aggregate(
    """distinct select on columns"""
    distinct_on: [user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_order_by!]

    """filter the rows returned"""
    where: user_settings_bool_exp
  ): user_settings_aggregate!
  ticket: String
  ticketExpiresAt: timestamptz!
  totpSecret: String
  updatedAt: timestamptz!

  """An array relationship"""
  userProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """An aggregate relationship"""
  userProviders_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!
}

"""
aggregated selection of "auth.users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

input users_aggregate_bool_exp {
  bool_and: users_aggregate_bool_exp_bool_and
  bool_or: users_aggregate_bool_exp_bool_or
  count: users_aggregate_bool_exp_count
}

input users_aggregate_bool_exp_bool_and {
  arguments: users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_bool_or {
  arguments: users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_count {
  arguments: [users_select_column!]
  distinct: Boolean
  filter: users_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
order by aggregate values of table "auth.users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input users_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "auth.users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  activeMfaType: String_comparison_exp
  allowedOrgs: memberships_bool_exp
  allowedOrgs_aggregate: memberships_aggregate_bool_exp
  associatedGroups: groups_bool_exp
  avatarUrl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  currentChallenge: String_comparison_exp
  currentOrg: organizations_bool_exp
  defaultOrg: uuid_comparison_exp
  defaultRole: String_comparison_exp
  defaultRoleByRole: authRoles_bool_exp
  disabled: Boolean_comparison_exp
  displayName: String_comparison_exp
  dissociatedGroups: groups_bool_exp
  email: citext_comparison_exp
  emailVerified: Boolean_comparison_exp
  groups: user_groups_bool_exp
  groups_aggregate: user_groups_aggregate_bool_exp
  id: uuid_comparison_exp
  invitations: invitations_bool_exp
  invitations_aggregate: invitations_aggregate_bool_exp
  isAnonymous: Boolean_comparison_exp
  lastSeen: timestamptz_comparison_exp
  locale: String_comparison_exp
  metadata: jsonb_comparison_exp
  newEmail: citext_comparison_exp
  notifications: user_notifications_bool_exp
  notifications_aggregate: user_notifications_aggregate_bool_exp
  otpHash: String_comparison_exp
  otpHashExpiresAt: timestamptz_comparison_exp
  otpMethodLastUsed: String_comparison_exp
  passwordHash: String_comparison_exp
  phoneNumber: String_comparison_exp
  phoneNumberVerified: Boolean_comparison_exp
  refreshTokens: authRefreshTokens_bool_exp
  refreshTokens_aggregate: authRefreshTokens_aggregate_bool_exp
  roles: authUserRoles_bool_exp
  roles_aggregate: authUserRoles_aggregate_bool_exp
  securityKeys: authUserSecurityKeys_bool_exp
  securityKeys_aggregate: authUserSecurityKeys_aggregate_bool_exp
  settings: user_settings_bool_exp
  settingsWithDefaults: user_settings_with_defaults_bool_exp
  settingsWithDefaults_aggregate: user_settings_with_defaults_aggregate_bool_exp
  settings_aggregate: user_settings_aggregate_bool_exp
  ticket: String_comparison_exp
  ticketExpiresAt: timestamptz_comparison_exp
  totpSecret: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userProviders: authUserProviders_bool_exp
  userProviders_aggregate: authUserProviders_aggregate_bool_exp
}

"""
unique or primary key constraints on table "auth.users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  users_email_key

  """
  unique or primary key constraint on columns "phone_number"
  """
  users_phone_number_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input users_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input users_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input users_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "auth.users"
"""
input users_insert_input {
  activeMfaType: String
  allowedOrgs: memberships_arr_rel_insert_input
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  currentOrg: organizations_obj_rel_insert_input
  defaultOrg: uuid
  defaultRole: String
  defaultRoleByRole: authRoles_obj_rel_insert_input
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  groups: user_groups_arr_rel_insert_input
  id: uuid
  invitations: invitations_arr_rel_insert_input
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  newEmail: citext
  notifications: user_notifications_arr_rel_insert_input
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  refreshTokens: authRefreshTokens_arr_rel_insert_input
  roles: authUserRoles_arr_rel_insert_input
  securityKeys: authUserSecurityKeys_arr_rel_insert_input
  settings: user_settings_arr_rel_insert_input
  settingsWithDefaults: user_settings_with_defaults_arr_rel_insert_input
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
  userProviders: authUserProviders_arr_rel_insert_input
}

"""aggregate max on columns"""
type users_max_fields {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultOrg: uuid
  defaultRole: String
  displayName: String
  email: citext
  id: uuid
  lastSeen: timestamptz
  locale: String
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "auth.users"
"""
input users_max_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  defaultOrg: order_by
  defaultRole: order_by
  displayName: order_by
  email: order_by
  id: order_by
  lastSeen: order_by
  locale: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultOrg: uuid
  defaultRole: String
  displayName: String
  email: citext
  id: uuid
  lastSeen: timestamptz
  locale: String
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "auth.users"
"""
input users_min_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  defaultOrg: order_by
  defaultRole: order_by
  displayName: order_by
  email: order_by
  id: order_by
  lastSeen: order_by
  locale: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "auth.users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "auth.users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "auth.users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "auth.users"."""
input users_order_by {
  activeMfaType: order_by
  allowedOrgs_aggregate: memberships_aggregate_order_by
  associatedGroups_aggregate: groups_aggregate_order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  currentOrg: organizations_order_by
  defaultOrg: order_by
  defaultRole: order_by
  defaultRoleByRole: authRoles_order_by
  disabled: order_by
  displayName: order_by
  dissociatedGroups_aggregate: groups_aggregate_order_by
  email: order_by
  emailVerified: order_by
  groups_aggregate: user_groups_aggregate_order_by
  id: order_by
  invitations_aggregate: invitations_aggregate_order_by
  isAnonymous: order_by
  lastSeen: order_by
  locale: order_by
  metadata: order_by
  newEmail: order_by
  notifications_aggregate: user_notifications_aggregate_order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  phoneNumberVerified: order_by
  refreshTokens_aggregate: authRefreshTokens_aggregate_order_by
  roles_aggregate: authUserRoles_aggregate_order_by
  securityKeys_aggregate: authUserSecurityKeys_aggregate_order_by
  settingsWithDefaults_aggregate: user_settings_with_defaults_aggregate_order_by
  settings_aggregate: user_settings_aggregate_order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
  userProviders_aggregate: authUserProviders_aggregate_order_by
}

"""primary key columns input for table: auth.users"""
input users_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input users_prepend_input {
  metadata: jsonb
}

scalar users_scalar

"""
select columns of table "auth.users"
"""
enum users_select_column {
  """column name"""
  activeMfaType

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  currentChallenge

  """column name"""
  defaultOrg

  """column name"""
  defaultRole

  """column name"""
  disabled

  """column name"""
  displayName

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  isAnonymous

  """column name"""
  lastSeen

  """column name"""
  locale

  """column name"""
  metadata

  """column name"""
  newEmail

  """column name"""
  otpHash

  """column name"""
  otpHashExpiresAt

  """column name"""
  otpMethodLastUsed

  """column name"""
  passwordHash

  """column name"""
  phoneNumber

  """column name"""
  phoneNumberVerified

  """column name"""
  ticket

  """column name"""
  ticketExpiresAt

  """column name"""
  totpSecret

  """column name"""
  updatedAt
}

"""
select "users_aggregate_bool_exp_bool_and_arguments_columns" columns of table "auth.users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  disabled

  """column name"""
  emailVerified

  """column name"""
  isAnonymous

  """column name"""
  phoneNumberVerified
}

"""
select "users_aggregate_bool_exp_bool_or_arguments_columns" columns of table "auth.users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  disabled

  """column name"""
  emailVerified

  """column name"""
  isAnonymous

  """column name"""
  phoneNumberVerified
}

"""
input type for updating data in table "auth.users"
"""
input users_set_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultOrg: uuid
  defaultRole: String
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input users_stream_cursor_value_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultOrg: uuid
  defaultRole: String
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
update columns of table "auth.users"
"""
enum users_update_column {
  """column name"""
  activeMfaType

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  currentChallenge

  """column name"""
  defaultOrg

  """column name"""
  defaultRole

  """column name"""
  disabled

  """column name"""
  displayName

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  isAnonymous

  """column name"""
  lastSeen

  """column name"""
  locale

  """column name"""
  metadata

  """column name"""
  newEmail

  """column name"""
  otpHash

  """column name"""
  otpHashExpiresAt

  """column name"""
  otpMethodLastUsed

  """column name"""
  passwordHash

  """column name"""
  phoneNumber

  """column name"""
  phoneNumberVerified

  """column name"""
  ticket

  """column name"""
  ticketExpiresAt

  """column name"""
  totpSecret

  """column name"""
  updatedAt
}

input users_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: users_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: users_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: users_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: users_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: users_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: users_set_input

  """filter the rows which have to be updated"""
  where: users_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "storage.virus"
"""
type virus {
  createdAt: timestamptz!

  """An object relationship"""
  file: files!
  fileId: uuid!
  filename: String!
  id: uuid!
  updatedAt: timestamptz!
  userSession(
    """JSON select path"""
    path: String
  ): jsonb!
  virus: String!
}

"""
aggregated selection of "storage.virus"
"""
type virus_aggregate {
  aggregate: virus_aggregate_fields
  nodes: [virus!]!
}

"""
aggregate fields of "storage.virus"
"""
type virus_aggregate_fields {
  count(columns: [virus_select_column!], distinct: Boolean): Int!
  max: virus_max_fields
  min: virus_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input virus_append_input {
  userSession: jsonb
}

"""
Boolean expression to filter rows from the table "storage.virus". All fields are combined with a logical 'AND'.
"""
input virus_bool_exp {
  _and: [virus_bool_exp!]
  _not: virus_bool_exp
  _or: [virus_bool_exp!]
  createdAt: timestamptz_comparison_exp
  file: files_bool_exp
  fileId: uuid_comparison_exp
  filename: String_comparison_exp
  id: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userSession: jsonb_comparison_exp
  virus: String_comparison_exp
}

"""
unique or primary key constraints on table "storage.virus"
"""
enum virus_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  virus_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input virus_delete_at_path_input {
  userSession: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input virus_delete_elem_input {
  userSession: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input virus_delete_key_input {
  userSession: String
}

"""
input type for inserting data into table "storage.virus"
"""
input virus_insert_input {
  createdAt: timestamptz
  file: files_obj_rel_insert_input
  fileId: uuid
  filename: String
  id: uuid
  updatedAt: timestamptz
  userSession: jsonb
  virus: String
}

"""aggregate max on columns"""
type virus_max_fields {
  createdAt: timestamptz
  fileId: uuid
  filename: String
  id: uuid
  updatedAt: timestamptz
  virus: String
}

"""aggregate min on columns"""
type virus_min_fields {
  createdAt: timestamptz
  fileId: uuid
  filename: String
  id: uuid
  updatedAt: timestamptz
  virus: String
}

"""
response of any mutation on the table "storage.virus"
"""
type virus_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [virus!]!
}

"""
on_conflict condition type for table "storage.virus"
"""
input virus_on_conflict {
  constraint: virus_constraint!
  update_columns: [virus_update_column!]! = []
  where: virus_bool_exp
}

"""Ordering options when selecting data from "storage.virus"."""
input virus_order_by {
  createdAt: order_by
  file: files_order_by
  fileId: order_by
  filename: order_by
  id: order_by
  updatedAt: order_by
  userSession: order_by
  virus: order_by
}

"""primary key columns input for table: storage.virus"""
input virus_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input virus_prepend_input {
  userSession: jsonb
}

"""
select columns of table "storage.virus"
"""
enum virus_select_column {
  """column name"""
  createdAt

  """column name"""
  fileId

  """column name"""
  filename

  """column name"""
  id

  """column name"""
  updatedAt

  """column name"""
  userSession

  """column name"""
  virus
}

"""
input type for updating data in table "storage.virus"
"""
input virus_set_input {
  createdAt: timestamptz
  fileId: uuid
  filename: String
  id: uuid
  updatedAt: timestamptz
  userSession: jsonb
  virus: String
}

"""
Streaming cursor of the table "virus"
"""
input virus_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: virus_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input virus_stream_cursor_value_input {
  createdAt: timestamptz
  fileId: uuid
  filename: String
  id: uuid
  updatedAt: timestamptz
  userSession: jsonb
  virus: String
}

"""
update columns of table "storage.virus"
"""
enum virus_update_column {
  """column name"""
  createdAt

  """column name"""
  fileId

  """column name"""
  filename

  """column name"""
  id

  """column name"""
  updatedAt

  """column name"""
  userSession

  """column name"""
  virus
}

input virus_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: virus_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: virus_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: virus_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: virus_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: virus_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: virus_set_input

  """filter the rows which have to be updated"""
  where: virus_bool_exp!
}
