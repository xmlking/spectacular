schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input ListUniversitiesInput {
  country: String
  name: String
}

type ListUniversitiesOutput {
  alpha_two_code: String
  country: String
  domains: [String!]!
  name: String
  stateprovince: String
  web_pages: [String!]!
}

input SearchRestroomsInput {
  city: String
  limit: Int
  offset: Int
  page: Int
}

type SearchRestroomsOutput {
  accessible: Boolean
  approved: Boolean
  changing_table: Boolean
  city: String
  comment: String
  country: String
  created_at: String
  directions: String
  downvote: Int
  edit_id: Int
  id: Int
  latitude: Float
  longitude: Float
  name: String
  state: String
  street: String
  unisex: Boolean
  updated_at: String
  upvote: Int
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [String!]

  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _is_null: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""action enum"""
type action {
  description: String!
  value: String!
}

"""
aggregated selection of "action"
"""
type action_aggregate {
  aggregate: action_aggregate_fields
  nodes: [action!]!
}

"""
aggregate fields of "action"
"""
type action_aggregate_fields {
  count(columns: [action_select_column!], distinct: Boolean): Int!
  max: action_max_fields
  min: action_min_fields
}

"""
Boolean expression to filter rows from the table "action". All fields are combined with a logical 'AND'.
"""
input action_bool_exp {
  _and: [action_bool_exp!]
  _not: action_bool_exp
  _or: [action_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

enum action_enum {
  """BLOCK"""
  block

  """CALLOUT_INSPECTION"""
  callout_inspection

  """CALLOUT_TERMINATING"""
  callout_terminating

  """CALLOUT_UNKNOWN"""
  callout_unknown

  """PERMIT"""
  permit
}

"""
Boolean expression to compare columns of type "action_enum". All fields are combined with logical 'AND'.
"""
input action_enum_comparison_exp {
  _eq: action_enum
  _in: [action_enum!]
  _is_null: Boolean
  _neq: action_enum
  _nin: [action_enum!]
}

"""aggregate max on columns"""
type action_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type action_min_fields {
  description: String
  value: String
}

"""Ordering options when selecting data from "action"."""
input action_order_by {
  description: order_by
  value: order_by
}

"""
select columns of table "action"
"""
enum action_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
Streaming cursor of the table "action"
"""
input action_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: action_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input action_stream_cursor_value_input {
  description: String
  value: String
}

enum authRefreshTokenTypes_enum {
  """Personal access token"""
  pat

  """Regular refresh token"""
  regular
}

"""
Boolean expression to compare columns of type "authRefreshTokenTypes_enum". All fields are combined with logical 'AND'.
"""
input authRefreshTokenTypes_enum_comparison_exp {
  _eq: authRefreshTokenTypes_enum
  _in: [authRefreshTokenTypes_enum!]
  _is_null: Boolean
  _neq: authRefreshTokenTypes_enum
  _nin: [authRefreshTokenTypes_enum!]
}

"""
User refresh tokens. Hasura auth uses them to rotate new access tokens as long as the refresh token is not expired. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authRefreshTokens {
  createdAt: timestamptz!
  expiresAt: timestamptz!
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  type: authRefreshTokenTypes_enum!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
order by aggregate values of table "auth.refresh_tokens"
"""
input authRefreshTokens_aggregate_order_by {
  count: order_by
  max: authRefreshTokens_max_order_by
  min: authRefreshTokens_min_order_by
}

"""
Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'.
"""
input authRefreshTokens_bool_exp {
  _and: [authRefreshTokens_bool_exp!]
  _not: authRefreshTokens_bool_exp
  _or: [authRefreshTokens_bool_exp!]
  createdAt: timestamptz_comparison_exp
  expiresAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  type: authRefreshTokenTypes_enum_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
order by max() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_max_order_by {
  createdAt: order_by
  expiresAt: order_by
  id: order_by
  userId: order_by
}

"""
order by min() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_min_order_by {
  createdAt: order_by
  expiresAt: order_by
  id: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.refresh_tokens"
"""
type authRefreshTokens_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRefreshTokens!]!
}

"""Ordering options when selecting data from "auth.refresh_tokens"."""
input authRefreshTokens_order_by {
  createdAt: order_by
  expiresAt: order_by
  id: order_by
  metadata: order_by
  type: order_by
  user: users_order_by
  userId: order_by
}

"""
select columns of table "auth.refresh_tokens"
"""
enum authRefreshTokens_select_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  type

  """column name"""
  userId
}

"""
Streaming cursor of the table "authRefreshTokens"
"""
input authRefreshTokens_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authRefreshTokens_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authRefreshTokens_stream_cursor_value_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  metadata: jsonb
  type: authRefreshTokenTypes_enum
  userId: uuid
}

"""
Active providers for a given user. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserProviders {
  createdAt: timestamptz!
  id: uuid!
  providerId: String!
  providerUserId: String!
  updatedAt: timestamptz!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
order by aggregate values of table "auth.user_providers"
"""
input authUserProviders_aggregate_order_by {
  count: order_by
  max: authUserProviders_max_order_by
  min: authUserProviders_min_order_by
}

"""
Boolean expression to filter rows from the table "auth.user_providers". All fields are combined with a logical 'AND'.
"""
input authUserProviders_bool_exp {
  _and: [authUserProviders_bool_exp!]
  _not: authUserProviders_bool_exp
  _or: [authUserProviders_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  providerId: String_comparison_exp
  providerUserId: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
order by max() on columns of table "auth.user_providers"
"""
input authUserProviders_max_order_by {
  createdAt: order_by
  id: order_by
  providerId: order_by
  providerUserId: order_by
  updatedAt: order_by
  userId: order_by
}

"""
order by min() on columns of table "auth.user_providers"
"""
input authUserProviders_min_order_by {
  createdAt: order_by
  id: order_by
  providerId: order_by
  providerUserId: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_providers"
"""
type authUserProviders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserProviders!]!
}

"""Ordering options when selecting data from "auth.user_providers"."""
input authUserProviders_order_by {
  createdAt: order_by
  id: order_by
  providerId: order_by
  providerUserId: order_by
  updatedAt: order_by
  user: users_order_by
  userId: order_by
}

"""
select columns of table "auth.user_providers"
"""
enum authUserProviders_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  providerId

  """column name"""
  providerUserId

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
Streaming cursor of the table "authUserProviders"
"""
input authUserProviders_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserProviders_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserProviders_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  updatedAt: timestamptz
  userId: uuid
}

"""
Roles of users. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserRoles {
  createdAt: timestamptz!
  id: uuid!
  role: String!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_roles"
"""
type authUserRoles_aggregate {
  aggregate: authUserRoles_aggregate_fields
  nodes: [authUserRoles!]!
}

input authUserRoles_aggregate_bool_exp {
  count: authUserRoles_aggregate_bool_exp_count
}

input authUserRoles_aggregate_bool_exp_count {
  arguments: [authUserRoles_select_column!]
  distinct: Boolean
  filter: authUserRoles_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.user_roles"
"""
type authUserRoles_aggregate_fields {
  count(columns: [authUserRoles_select_column!], distinct: Boolean): Int!
  max: authUserRoles_max_fields
  min: authUserRoles_min_fields
}

"""
order by aggregate values of table "auth.user_roles"
"""
input authUserRoles_aggregate_order_by {
  count: order_by
  max: authUserRoles_max_order_by
  min: authUserRoles_min_order_by
}

"""
Boolean expression to filter rows from the table "auth.user_roles". All fields are combined with a logical 'AND'.
"""
input authUserRoles_bool_exp {
  _and: [authUserRoles_bool_exp!]
  _not: authUserRoles_bool_exp
  _or: [authUserRoles_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  role: String_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_roles"
"""
enum authUserRoles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_roles_pkey

  """
  unique or primary key constraint on columns "user_id", "role"
  """
  user_roles_user_id_role_key
}

"""
input type for inserting data into table "auth.user_roles"
"""
input authUserRoles_insert_input {
  role: String
  userId: uuid
}

"""aggregate max on columns"""
type authUserRoles_max_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
order by max() on columns of table "auth.user_roles"
"""
input authUserRoles_max_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserRoles_min_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
order by min() on columns of table "auth.user_roles"
"""
input authUserRoles_min_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_roles"
"""
type authUserRoles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserRoles!]!
}

"""
on_conflict condition type for table "auth.user_roles"
"""
input authUserRoles_on_conflict {
  constraint: authUserRoles_constraint!
  update_columns: [authUserRoles_update_column!]! = []
  where: authUserRoles_bool_exp
}

"""Ordering options when selecting data from "auth.user_roles"."""
input authUserRoles_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  user: users_order_by
  userId: order_by
}

"""
select columns of table "auth.user_roles"
"""
enum authUserRoles_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  role

  """column name"""
  userId
}

"""
Streaming cursor of the table "authUserRoles"
"""
input authUserRoles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserRoles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserRoles_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
placeholder for update columns of table "auth.user_roles" (current role has no relevant permissions)
"""
enum authUserRoles_update_column {
  """placeholder (do not use)"""
  _PLACEHOLDER
}

"""
User webauthn security keys. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserSecurityKeys {
  id: uuid!
  nickname: String

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
order by aggregate values of table "auth.user_security_keys"
"""
input authUserSecurityKeys_aggregate_order_by {
  count: order_by
  max: authUserSecurityKeys_max_order_by
  min: authUserSecurityKeys_min_order_by
}

"""
Boolean expression to filter rows from the table "auth.user_security_keys". All fields are combined with a logical 'AND'.
"""
input authUserSecurityKeys_bool_exp {
  _and: [authUserSecurityKeys_bool_exp!]
  _not: authUserSecurityKeys_bool_exp
  _or: [authUserSecurityKeys_bool_exp!]
  id: uuid_comparison_exp
  nickname: String_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
order by max() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_max_order_by {
  id: order_by
  nickname: order_by
  userId: order_by
}

"""
order by min() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_min_order_by {
  id: order_by
  nickname: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_security_keys"
"""
type authUserSecurityKeys_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserSecurityKeys!]!
}

"""Ordering options when selecting data from "auth.user_security_keys"."""
input authUserSecurityKeys_order_by {
  id: order_by
  nickname: order_by
  user: users_order_by
  userId: order_by
}

"""
select columns of table "auth.user_security_keys"
"""
enum authUserSecurityKeys_select_column {
  """column name"""
  id

  """column name"""
  nickname

  """column name"""
  userId
}

"""
Streaming cursor of the table "authUserSecurityKeys"
"""
input authUserSecurityKeys_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserSecurityKeys_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserSecurityKeys_stream_cursor_value_input {
  id: uuid
  nickname: String
  userId: uuid
}

scalar citext

"""
Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
"""
input citext_comparison_exp {
  _eq: citext
  _gt: citext
  _gte: citext

  """does the column match the given case-insensitive pattern"""
  _ilike: citext
  _in: [citext!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: citext
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: citext
  _lt: citext
  _lte: citext
  _neq: citext

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: citext
  _nin: [citext!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: citext

  """does the column NOT match the given pattern"""
  _nlike: citext

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: citext

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: citext

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: citext

  """does the column match the given SQL regular expression"""
  _similar: citext
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""device to pool bridge table"""
type device_pools {
  """An object relationship"""
  device: devices!
  deviceId: uuid!
  id: uuid!

  """An object relationship"""
  pool: pools!
  poolId: uuid!
}

"""
aggregated selection of "device_pools"
"""
type device_pools_aggregate {
  aggregate: device_pools_aggregate_fields
  nodes: [device_pools!]!
}

input device_pools_aggregate_bool_exp {
  count: device_pools_aggregate_bool_exp_count
}

input device_pools_aggregate_bool_exp_count {
  arguments: [device_pools_select_column!]
  distinct: Boolean
  filter: device_pools_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "device_pools"
"""
type device_pools_aggregate_fields {
  count(columns: [device_pools_select_column!], distinct: Boolean): Int!
  max: device_pools_max_fields
  min: device_pools_min_fields
}

"""
order by aggregate values of table "device_pools"
"""
input device_pools_aggregate_order_by {
  count: order_by
  max: device_pools_max_order_by
  min: device_pools_min_order_by
}

"""
input type for inserting array relation for remote table "device_pools"
"""
input device_pools_arr_rel_insert_input {
  data: [device_pools_insert_input!]!

  """upsert condition"""
  on_conflict: device_pools_on_conflict
}

"""
Boolean expression to filter rows from the table "device_pools". All fields are combined with a logical 'AND'.
"""
input device_pools_bool_exp {
  _and: [device_pools_bool_exp!]
  _not: device_pools_bool_exp
  _or: [device_pools_bool_exp!]
  device: devices_bool_exp
  deviceId: uuid_comparison_exp
  id: uuid_comparison_exp
  pool: pools_bool_exp
  poolId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "device_pools"
"""
enum device_pools_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  device_pools_pkey

  """
  unique or primary key constraint on columns "pool_id", "device_id"
  """
  device_pools_pool_id_device_id_key
}

"""
input type for inserting data into table "device_pools"
"""
input device_pools_insert_input {
  deviceId: uuid
  pool: pools_obj_rel_insert_input
  poolId: uuid
}

"""aggregate max on columns"""
type device_pools_max_fields {
  deviceId: uuid
  id: uuid
  poolId: uuid
}

"""
order by max() on columns of table "device_pools"
"""
input device_pools_max_order_by {
  deviceId: order_by
  id: order_by
  poolId: order_by
}

"""aggregate min on columns"""
type device_pools_min_fields {
  deviceId: uuid
  id: uuid
  poolId: uuid
}

"""
order by min() on columns of table "device_pools"
"""
input device_pools_min_order_by {
  deviceId: order_by
  id: order_by
  poolId: order_by
}

"""
response of any mutation on the table "device_pools"
"""
type device_pools_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [device_pools!]!
}

"""
on_conflict condition type for table "device_pools"
"""
input device_pools_on_conflict {
  constraint: device_pools_constraint!
  update_columns: [device_pools_update_column!]! = []
  where: device_pools_bool_exp
}

"""Ordering options when selecting data from "device_pools"."""
input device_pools_order_by {
  device: devices_order_by
  deviceId: order_by
  id: order_by
  pool: pools_order_by
  poolId: order_by
}

"""
select columns of table "device_pools"
"""
enum device_pools_select_column {
  """column name"""
  deviceId

  """column name"""
  id

  """column name"""
  poolId
}

"""
Streaming cursor of the table "device_pools"
"""
input device_pools_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: device_pools_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input device_pools_stream_cursor_value_input {
  deviceId: uuid
  id: uuid
  poolId: uuid
}

"""
placeholder for update columns of table "device_pools" (current role has no relevant permissions)
"""
enum device_pools_update_column {
  """placeholder (do not use)"""
  _PLACEHOLDER
}

"""Devices Metadata"""
type devices {
  alternateDns: Boolean
  annotations: hstore

  """Used as Computed Field on Devices Table"""
  associatedPools(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]
  createdAt: timestamptz!
  createdBy: String!
  description: String
  displayName: String!

  """Used as Computed Field on Devices Table"""
  dissociatedPools(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]
  id: uuid!
  ip: String!
  organization: String!
  proxyIp: Boolean
  publicIp: String
  tags: [String!]
  updatedAt: timestamptz!
  updatedBy: String!
  version: String
}

"""
aggregated selection of "devices"
"""
type devices_aggregate {
  aggregate: devices_aggregate_fields
  nodes: [devices!]!
}

"""
aggregate fields of "devices"
"""
type devices_aggregate_fields {
  count(columns: [devices_select_column!], distinct: Boolean): Int!
  max: devices_max_fields
  min: devices_min_fields
}

"""
Boolean expression to filter rows from the table "devices". All fields are combined with a logical 'AND'.
"""
input devices_bool_exp {
  _and: [devices_bool_exp!]
  _not: devices_bool_exp
  _or: [devices_bool_exp!]
  alternateDns: Boolean_comparison_exp
  annotations: hstore_comparison_exp
  associatedPools: pools_bool_exp
  createdAt: timestamptz_comparison_exp
  createdBy: String_comparison_exp
  description: String_comparison_exp
  displayName: String_comparison_exp
  dissociatedPools: pools_bool_exp
  id: uuid_comparison_exp
  ip: String_comparison_exp
  organization: String_comparison_exp
  proxyIp: Boolean_comparison_exp
  publicIp: String_comparison_exp
  tags: String_array_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: String_comparison_exp
  version: String_comparison_exp
}

"""aggregate max on columns"""
type devices_max_fields {
  createdAt: timestamptz
  createdBy: String
  description: String
  displayName: String
  id: uuid
  ip: String
  organization: String
  publicIp: String
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: String
  version: String
}

"""aggregate min on columns"""
type devices_min_fields {
  createdAt: timestamptz
  createdBy: String
  description: String
  displayName: String
  id: uuid
  ip: String
  organization: String
  publicIp: String
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: String
  version: String
}

"""
response of any mutation on the table "devices"
"""
type devices_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [devices!]!
}

"""Ordering options when selecting data from "devices"."""
input devices_order_by {
  alternateDns: order_by
  annotations: order_by
  associatedPools_aggregate: pools_aggregate_order_by
  createdAt: order_by
  createdBy: order_by
  description: order_by
  displayName: order_by
  dissociatedPools_aggregate: pools_aggregate_order_by
  id: order_by
  ip: order_by
  organization: order_by
  proxyIp: order_by
  publicIp: order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
  version: order_by
}

"""primary key columns input for table: devices"""
input devices_pk_columns_input {
  id: uuid!
}

"""
select columns of table "devices"
"""
enum devices_select_column {
  """column name"""
  alternateDns

  """column name"""
  annotations

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  organization

  """column name"""
  proxyIp

  """column name"""
  publicIp

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  version
}

"""
input type for updating data in table "devices"
"""
input devices_set_input {
  annotations: hstore
  deletedAt: timestamptz
  description: String
  tags: [String!]
}

"""
Streaming cursor of the table "devices"
"""
input devices_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: devices_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input devices_stream_cursor_value_input {
  alternateDns: Boolean
  annotations: hstore
  createdAt: timestamptz
  createdBy: String
  description: String
  displayName: String
  id: uuid
  ip: String
  organization: String
  proxyIp: Boolean
  publicIp: String
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: String
  version: String
}

input devices_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: devices_set_input

  """filter the rows which have to be updated"""
  where: devices_bool_exp!
}

"""direction enum"""
type direction {
  description: String!
  value: String!
}

"""
aggregated selection of "direction"
"""
type direction_aggregate {
  aggregate: direction_aggregate_fields
  nodes: [direction!]!
}

"""
aggregate fields of "direction"
"""
type direction_aggregate_fields {
  count(columns: [direction_select_column!], distinct: Boolean): Int!
  max: direction_max_fields
  min: direction_min_fields
}

"""
Boolean expression to filter rows from the table "direction". All fields are combined with a logical 'AND'.
"""
input direction_bool_exp {
  _and: [direction_bool_exp!]
  _not: direction_bool_exp
  _or: [direction_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

enum direction_enum {
  """EGRESS"""
  egress

  """INGRESS"""
  ingress
}

"""
Boolean expression to compare columns of type "direction_enum". All fields are combined with logical 'AND'.
"""
input direction_enum_comparison_exp {
  _eq: direction_enum
  _in: [direction_enum!]
  _is_null: Boolean
  _neq: direction_enum
  _nin: [direction_enum!]
}

"""aggregate max on columns"""
type direction_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type direction_min_fields {
  description: String
  value: String
}

"""Ordering options when selecting data from "direction"."""
input direction_order_by {
  description: order_by
  value: order_by
}

"""
select columns of table "direction"
"""
enum direction_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
Streaming cursor of the table "direction"
"""
input direction_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: direction_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input direction_stream_cursor_value_input {
  description: String
  value: String
}

"""
columns and relationships of "storage.files"
"""
type files {
  bucketId: String!
  createdAt: timestamptz!
  etag: String
  id: uuid!
  isUploaded: Boolean
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz!
  uploadedByUserId: uuid
}

"""
Boolean expression to filter rows from the table "storage.files". All fields are combined with a logical 'AND'.
"""
input files_bool_exp {
  _and: [files_bool_exp!]
  _not: files_bool_exp
  _or: [files_bool_exp!]
  bucketId: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  etag: String_comparison_exp
  id: uuid_comparison_exp
  isUploaded: Boolean_comparison_exp
  metadata: jsonb_comparison_exp
  mimeType: String_comparison_exp
  name: String_comparison_exp
  size: Int_comparison_exp
  updatedAt: timestamptz_comparison_exp
  uploadedByUserId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "storage.files"
"""
enum files_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  files_pkey
}

"""
input type for inserting data into table "storage.files"
"""
input files_insert_input {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  metadata: jsonb
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
}

"""
response of any mutation on the table "storage.files"
"""
type files_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [files!]!
}

"""
on_conflict condition type for table "storage.files"
"""
input files_on_conflict {
  constraint: files_constraint!
  update_columns: [files_update_column!]! = []
  where: files_bool_exp
}

"""Ordering options when selecting data from "storage.files"."""
input files_order_by {
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  isUploaded: order_by
  metadata: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""
select columns of table "storage.files"
"""
enum files_select_column {
  """column name"""
  bucketId

  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  isUploaded

  """column name"""
  metadata

  """column name"""
  mimeType

  """column name"""
  name

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploadedByUserId
}

"""
Streaming cursor of the table "files"
"""
input files_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: files_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input files_stream_cursor_value_input {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  metadata: jsonb
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""
placeholder for update columns of table "storage.files" (current role has no relevant permissions)
"""
enum files_update_column {
  """placeholder (do not use)"""
  _PLACEHOLDER
}

"""User groups defined per organization"""
type groups {
  annotations: hstore
  createdAt: timestamptz!
  createdBy: String!
  description: String
  displayName: String!

  """An array relationship"""
  group_users(
    """distinct select on columns"""
    distinct_on: [user_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_groups_order_by!]

    """filter the rows returned"""
    where: user_groups_bool_exp
  ): [user_groups!]!
  id: uuid!
  organization: String!
  tags: [String!]
  updatedAt: timestamptz!
  updatedBy: String!
}

"""
Boolean expression to filter rows from the table "groups". All fields are combined with a logical 'AND'.
"""
input groups_bool_exp {
  _and: [groups_bool_exp!]
  _not: groups_bool_exp
  _or: [groups_bool_exp!]
  annotations: hstore_comparison_exp
  createdAt: timestamptz_comparison_exp
  createdBy: String_comparison_exp
  description: String_comparison_exp
  displayName: String_comparison_exp
  group_users: user_groups_bool_exp
  id: uuid_comparison_exp
  organization: String_comparison_exp
  tags: String_array_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: String_comparison_exp
}

"""
unique or primary key constraints on table "groups"
"""
enum groups_constraint {
  """
  unique or primary key constraint on columns "display_name", "organization"
  """
  groups_display_name_organization_unique

  """
  unique or primary key constraint on columns "id"
  """
  groups_pkey
}

"""
input type for inserting data into table "groups"
"""
input groups_insert_input {
  annotations: hstore
  description: String
  displayName: String
  group_users: user_groups_arr_rel_insert_input
  organization: String
  tags: [String!]
}

"""
response of any mutation on the table "groups"
"""
type groups_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [groups!]!
}

"""
input type for inserting object relation for remote table "groups"
"""
input groups_obj_rel_insert_input {
  data: groups_insert_input!

  """upsert condition"""
  on_conflict: groups_on_conflict
}

"""
on_conflict condition type for table "groups"
"""
input groups_on_conflict {
  constraint: groups_constraint!
  update_columns: [groups_update_column!]! = []
  where: groups_bool_exp
}

"""Ordering options when selecting data from "groups"."""
input groups_order_by {
  annotations: order_by
  createdAt: order_by
  createdBy: order_by
  description: order_by
  displayName: order_by
  group_users_aggregate: user_groups_aggregate_order_by
  id: order_by
  organization: order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""primary key columns input for table: groups"""
input groups_pk_columns_input {
  id: uuid!
}

"""
select columns of table "groups"
"""
enum groups_select_column {
  """column name"""
  annotations

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  organization

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

"""
input type for updating data in table "groups"
"""
input groups_set_input {
  annotations: hstore
  deletedAt: timestamptz
  description: String
  displayName: String
  tags: [String!]
}

"""
Streaming cursor of the table "groups"
"""
input groups_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: groups_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input groups_stream_cursor_value_input {
  annotations: hstore
  createdAt: timestamptz
  createdBy: String
  description: String
  displayName: String
  id: uuid
  organization: String
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: String
}

"""
update columns of table "groups"
"""
enum groups_update_column {
  """column name"""
  annotations

  """column name"""
  deletedAt

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  tags
}

input groups_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: groups_set_input

  """filter the rows which have to be updated"""
  where: groups_bool_exp!
}

scalar hstore

"""
Boolean expression to compare columns of type "hstore". All fields are combined with logical 'AND'.
"""
input hstore_comparison_exp {
  _eq: hstore
  _gt: hstore
  _gte: hstore
  _in: [hstore!]
  _is_null: Boolean
  _lt: hstore
  _lte: hstore
  _neq: hstore
  _nin: [hstore!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""mutation root"""
type mutation_root {
  """
  delete single row from the table: "auth.refresh_tokens"
  """
  deleteAuthRefreshToken(id: uuid!): authRefreshTokens

  """
  delete data from the table: "auth.refresh_tokens"
  """
  deleteAuthRefreshTokens(
    """filter the rows which have to be deleted"""
    where: authRefreshTokens_bool_exp!
  ): authRefreshTokens_mutation_response

  """
  delete single row from the table: "auth.user_providers"
  """
  deleteAuthUserProvider(id: uuid!): authUserProviders

  """
  delete data from the table: "auth.user_providers"
  """
  deleteAuthUserProviders(
    """filter the rows which have to be deleted"""
    where: authUserProviders_bool_exp!
  ): authUserProviders_mutation_response

  """
  delete single row from the table: "auth.user_roles"
  """
  deleteAuthUserRole(id: uuid!): authUserRoles

  """
  delete data from the table: "auth.user_roles"
  """
  deleteAuthUserRoles(
    """filter the rows which have to be deleted"""
    where: authUserRoles_bool_exp!
  ): authUserRoles_mutation_response

  """
  delete single row from the table: "auth.user_security_keys"
  """
  deleteAuthUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  delete data from the table: "auth.user_security_keys"
  """
  deleteAuthUserSecurityKeys(
    """filter the rows which have to be deleted"""
    where: authUserSecurityKeys_bool_exp!
  ): authUserSecurityKeys_mutation_response

  """
  delete single row from the table: "storage.files"
  """
  deleteFile(id: uuid!): files

  """
  delete data from the table: "storage.files"
  """
  deleteFiles(
    """filter the rows which have to be deleted"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  delete data from the table: "device_pools"
  """
  delete_device_pools(
    """filter the rows which have to be deleted"""
    where: device_pools_bool_exp!
  ): device_pools_mutation_response

  """
  delete single row from the table: "device_pools"
  """
  delete_device_pools_by_pk(id: uuid!): device_pools

  """
  delete data from the table: "organizations"
  """
  delete_organizations(
    """filter the rows which have to be deleted"""
    where: organizations_bool_exp!
  ): organizations_mutation_response

  """
  delete single row from the table: "organizations"
  """
  delete_organizations_by_pk(organization: String!): organizations

  """
  delete data from the table: "user_groups"
  """
  delete_user_groups(
    """filter the rows which have to be deleted"""
    where: user_groups_bool_exp!
  ): user_groups_mutation_response

  """
  delete single row from the table: "user_groups"
  """
  delete_user_groups_by_pk(groupId: uuid!, userId: uuid!): user_groups

  """
  delete data from the table: "user_org_roles"
  """
  delete_user_org_roles(
    """filter the rows which have to be deleted"""
    where: user_org_roles_bool_exp!
  ): user_org_roles_mutation_response

  """
  delete single row from the table: "user_org_roles"
  """
  delete_user_org_roles_by_pk(id: uuid!): user_org_roles

  """
  insert a single row into the table: "auth.user_roles"
  """
  insertAuthUserRole(
    """the row to be inserted"""
    object: authUserRoles_insert_input!

    """upsert condition"""
    on_conflict: authUserRoles_on_conflict
  ): authUserRoles

  """
  insert data into the table: "auth.user_roles"
  """
  insertAuthUserRoles(
    """the rows to be inserted"""
    objects: [authUserRoles_insert_input!]!

    """upsert condition"""
    on_conflict: authUserRoles_on_conflict
  ): authUserRoles_mutation_response

  """
  insert a single row into the table: "storage.files"
  """
  insertFile(
    """the row to be inserted"""
    object: files_insert_input!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files

  """
  insert data into the table: "storage.files"
  """
  insertFiles(
    """the rows to be inserted"""
    objects: [files_insert_input!]!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files_mutation_response

  """
  insert data into the table: "device_pools"
  """
  insert_device_pools(
    """the rows to be inserted"""
    objects: [device_pools_insert_input!]!

    """upsert condition"""
    on_conflict: device_pools_on_conflict
  ): device_pools_mutation_response

  """
  insert a single row into the table: "device_pools"
  """
  insert_device_pools_one(
    """the row to be inserted"""
    object: device_pools_insert_input!

    """upsert condition"""
    on_conflict: device_pools_on_conflict
  ): device_pools

  """
  insert data into the table: "groups"
  """
  insert_groups(
    """the rows to be inserted"""
    objects: [groups_insert_input!]!

    """upsert condition"""
    on_conflict: groups_on_conflict
  ): groups_mutation_response

  """
  insert a single row into the table: "groups"
  """
  insert_groups_one(
    """the row to be inserted"""
    object: groups_insert_input!

    """upsert condition"""
    on_conflict: groups_on_conflict
  ): groups

  """
  insert data into the table: "organizations"
  """
  insert_organizations(
    """the rows to be inserted"""
    objects: [organizations_insert_input!]!

    """upsert condition"""
    on_conflict: organizations_on_conflict
  ): organizations_mutation_response

  """
  insert a single row into the table: "organizations"
  """
  insert_organizations_one(
    """the row to be inserted"""
    object: organizations_insert_input!

    """upsert condition"""
    on_conflict: organizations_on_conflict
  ): organizations

  """
  insert data into the table: "policies"
  """
  insert_policies(
    """the rows to be inserted"""
    objects: [policies_insert_input!]!

    """upsert condition"""
    on_conflict: policies_on_conflict
  ): policies_mutation_response

  """
  insert a single row into the table: "policies"
  """
  insert_policies_one(
    """the row to be inserted"""
    object: policies_insert_input!

    """upsert condition"""
    on_conflict: policies_on_conflict
  ): policies

  """
  insert data into the table: "pools"
  """
  insert_pools(
    """the rows to be inserted"""
    objects: [pools_insert_input!]!

    """upsert condition"""
    on_conflict: pools_on_conflict
  ): pools_mutation_response

  """
  insert a single row into the table: "pools"
  """
  insert_pools_one(
    """the row to be inserted"""
    object: pools_insert_input!

    """upsert condition"""
    on_conflict: pools_on_conflict
  ): pools

  """
  insert data into the table: "rules"
  """
  insert_rules(
    """the rows to be inserted"""
    objects: [rules_insert_input!]!

    """upsert condition"""
    on_conflict: rules_on_conflict
  ): rules_mutation_response

  """
  insert a single row into the table: "rules"
  """
  insert_rules_one(
    """the row to be inserted"""
    object: rules_insert_input!

    """upsert condition"""
    on_conflict: rules_on_conflict
  ): rules

  """
  insert data into the table: "user_groups"
  """
  insert_user_groups(
    """the rows to be inserted"""
    objects: [user_groups_insert_input!]!

    """upsert condition"""
    on_conflict: user_groups_on_conflict
  ): user_groups_mutation_response

  """
  insert a single row into the table: "user_groups"
  """
  insert_user_groups_one(
    """the row to be inserted"""
    object: user_groups_insert_input!

    """upsert condition"""
    on_conflict: user_groups_on_conflict
  ): user_groups

  """
  insert data into the table: "user_org_roles"
  """
  insert_user_org_roles(
    """the rows to be inserted"""
    objects: [user_org_roles_insert_input!]!

    """upsert condition"""
    on_conflict: user_org_roles_on_conflict
  ): user_org_roles_mutation_response

  """
  insert a single row into the table: "user_org_roles"
  """
  insert_user_org_roles_one(
    """the row to be inserted"""
    object: user_org_roles_insert_input!

    """upsert condition"""
    on_conflict: user_org_roles_on_conflict
  ): user_org_roles

  """
  update single row of the table: "auth.users"
  """
  updateUser(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update data of the table: "auth.users"
  """
  updateUsers(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update data of the table: "devices"
  """
  update_devices(
    """sets the columns of the filtered rows to the given values"""
    _set: devices_set_input

    """filter the rows which have to be updated"""
    where: devices_bool_exp!
  ): devices_mutation_response

  """
  update single row of the table: "devices"
  """
  update_devices_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: devices_set_input
    pk_columns: devices_pk_columns_input!
  ): devices

  """
  update multiples rows of table: "devices"
  """
  update_devices_many(
    """updates to execute, in order"""
    updates: [devices_updates!]!
  ): [devices_mutation_response]

  """
  update data of the table: "groups"
  """
  update_groups(
    """sets the columns of the filtered rows to the given values"""
    _set: groups_set_input

    """filter the rows which have to be updated"""
    where: groups_bool_exp!
  ): groups_mutation_response

  """
  update single row of the table: "groups"
  """
  update_groups_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: groups_set_input
    pk_columns: groups_pk_columns_input!
  ): groups

  """
  update multiples rows of table: "groups"
  """
  update_groups_many(
    """updates to execute, in order"""
    updates: [groups_updates!]!
  ): [groups_mutation_response]

  """
  update data of the table: "organizations"
  """
  update_organizations(
    """sets the columns of the filtered rows to the given values"""
    _set: organizations_set_input

    """filter the rows which have to be updated"""
    where: organizations_bool_exp!
  ): organizations_mutation_response

  """
  update single row of the table: "organizations"
  """
  update_organizations_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: organizations_set_input
    pk_columns: organizations_pk_columns_input!
  ): organizations

  """
  update multiples rows of table: "organizations"
  """
  update_organizations_many(
    """updates to execute, in order"""
    updates: [organizations_updates!]!
  ): [organizations_mutation_response]

  """
  update data of the table: "policies"
  """
  update_policies(
    """increments the numeric columns with given value of the filtered values"""
    _inc: policies_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: policies_set_input

    """filter the rows which have to be updated"""
    where: policies_bool_exp!
  ): policies_mutation_response

  """
  update single row of the table: "policies"
  """
  update_policies_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: policies_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: policies_set_input
    pk_columns: policies_pk_columns_input!
  ): policies

  """
  update multiples rows of table: "policies"
  """
  update_policies_many(
    """updates to execute, in order"""
    updates: [policies_updates!]!
  ): [policies_mutation_response]

  """
  update data of the table: "pools"
  """
  update_pools(
    """sets the columns of the filtered rows to the given values"""
    _set: pools_set_input

    """filter the rows which have to be updated"""
    where: pools_bool_exp!
  ): pools_mutation_response

  """
  update single row of the table: "pools"
  """
  update_pools_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: pools_set_input
    pk_columns: pools_pk_columns_input!
  ): pools

  """
  update multiples rows of table: "pools"
  """
  update_pools_many(
    """updates to execute, in order"""
    updates: [pools_updates!]!
  ): [pools_mutation_response]

  """
  update data of the table: "rules"
  """
  update_rules(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rules_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rules_set_input

    """filter the rows which have to be updated"""
    where: rules_bool_exp!
  ): rules_mutation_response

  """
  update single row of the table: "rules"
  """
  update_rules_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rules_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rules_set_input
    pk_columns: rules_pk_columns_input!
  ): rules

  """
  update multiples rows of table: "rules"
  """
  update_rules_many(
    """updates to execute, in order"""
    updates: [rules_updates!]!
  ): [rules_mutation_response]

  """
  update data of the table: "user_org_roles"
  """
  update_user_org_roles(
    """sets the columns of the filtered rows to the given values"""
    _set: user_org_roles_set_input

    """filter the rows which have to be updated"""
    where: user_org_roles_bool_exp!
  ): user_org_roles_mutation_response

  """
  update single row of the table: "user_org_roles"
  """
  update_user_org_roles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_org_roles_set_input
    pk_columns: user_org_roles_pk_columns_input!
  ): user_org_roles

  """
  update multiples rows of table: "user_org_roles"
  """
  update_user_org_roles_many(
    """updates to execute, in order"""
    updates: [user_org_roles_updates!]!
  ): [user_org_roles_mutation_response]

  """
  update multiples rows of table: "auth.users"
  """
  update_users_many(
    """updates to execute, in order"""
    updates: [users_updates!]!
  ): [users_mutation_response]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""organizations in multitenant env"""
type organizations {
  allowedEmailDomains: [String!]
  allowedEmails: [String!]
  description: String!
  organization: String!
}

"""
order by aggregate values of table "organizations"
"""
input organizations_aggregate_order_by {
  count: order_by
  max: organizations_max_order_by
  min: organizations_min_order_by
}

"""
Boolean expression to filter rows from the table "organizations". All fields are combined with a logical 'AND'.
"""
input organizations_bool_exp {
  _and: [organizations_bool_exp!]
  _not: organizations_bool_exp
  _or: [organizations_bool_exp!]
  allowedEmailDomains: String_array_comparison_exp
  allowedEmails: String_array_comparison_exp
  description: String_comparison_exp
  organization: String_comparison_exp
}

"""
unique or primary key constraints on table "organizations"
"""
enum organizations_constraint {
  """
  unique or primary key constraint on columns "organization"
  """
  organization_pkey
}

"""
input type for inserting data into table "organizations"
"""
input organizations_insert_input {
  allowedEmailDomains: [String!]
  allowedEmails: [String!]
  description: String
  organization: String
}

"""
order by max() on columns of table "organizations"
"""
input organizations_max_order_by {
  allowedEmailDomains: order_by
  allowedEmails: order_by
  description: order_by
  organization: order_by
}

"""
order by min() on columns of table "organizations"
"""
input organizations_min_order_by {
  allowedEmailDomains: order_by
  allowedEmails: order_by
  description: order_by
  organization: order_by
}

"""
response of any mutation on the table "organizations"
"""
type organizations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [organizations!]!
}

"""
on_conflict condition type for table "organizations"
"""
input organizations_on_conflict {
  constraint: organizations_constraint!
  update_columns: [organizations_update_column!]! = []
  where: organizations_bool_exp
}

"""Ordering options when selecting data from "organizations"."""
input organizations_order_by {
  allowedEmailDomains: order_by
  allowedEmails: order_by
  description: order_by
  organization: order_by
}

"""primary key columns input for table: organizations"""
input organizations_pk_columns_input {
  organization: String!
}

"""
select columns of table "organizations"
"""
enum organizations_select_column {
  """column name"""
  allowedEmailDomains

  """column name"""
  allowedEmails

  """column name"""
  description

  """column name"""
  organization
}

"""
input type for updating data in table "organizations"
"""
input organizations_set_input {
  allowedEmailDomains: [String!]
  allowedEmails: [String!]
  description: String
  organization: String
}

"""
Streaming cursor of the table "organizations"
"""
input organizations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: organizations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input organizations_stream_cursor_value_input {
  allowedEmailDomains: [String!]
  allowedEmails: [String!]
  description: String
  organization: String
}

"""
update columns of table "organizations"
"""
enum organizations_update_column {
  """column name"""
  allowedEmailDomains

  """column name"""
  allowedEmails

  """column name"""
  description

  """column name"""
  organization
}

input organizations_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: organizations_set_input

  """filter the rows which have to be updated"""
  where: organizations_bool_exp!
}

"""Joint table associating subjects polymorphically with rules"""
type policies {
  active: Boolean!
  createdAt: timestamptz!
  createdBy: String!
  id: uuid!
  organization: String!

  """An object relationship"""
  rule: rules!
  ruleId: uuid!
  subjectDisplayName: String!
  subjectId: uuid!
  subjectSecondaryId: String!
  subjectType: subject_type_enum!
  updatedAt: timestamptz!
  updatedBy: String!
  validFrom: timestamptz!
  validTo: timestamptz
  weight: smallint!
}

"""
Boolean expression to filter rows from the table "policies". All fields are combined with a logical 'AND'.
"""
input policies_bool_exp {
  _and: [policies_bool_exp!]
  _not: policies_bool_exp
  _or: [policies_bool_exp!]
  active: Boolean_comparison_exp
  createdAt: timestamptz_comparison_exp
  createdBy: String_comparison_exp
  id: uuid_comparison_exp
  organization: String_comparison_exp
  rule: rules_bool_exp
  ruleId: uuid_comparison_exp
  subjectDisplayName: String_comparison_exp
  subjectId: uuid_comparison_exp
  subjectSecondaryId: String_comparison_exp
  subjectType: subject_type_enum_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: String_comparison_exp
  validFrom: timestamptz_comparison_exp
  validTo: timestamptz_comparison_exp
  weight: smallint_comparison_exp
}

"""
unique or primary key constraints on table "policies"
"""
enum policies_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  policies_pkey

  """
  unique or primary key constraint on columns "subject_id", "organization", "rule_id", "subject_type"
  """
  policies_subject_id_subject_type_rule_id_organization_unique
}

"""
input type for incrementing numeric columns in table "policies"
"""
input policies_inc_input {
  weight: smallint
}

"""
input type for inserting data into table "policies"
"""
input policies_insert_input {
  active: Boolean
  organization: String
  rule: rules_obj_rel_insert_input
  ruleId: uuid
  subjectDisplayName: String
  subjectId: uuid
  subjectSecondaryId: String
  subjectType: subject_type_enum
  validFrom: timestamptz
  validTo: timestamptz
  weight: smallint
}

"""
response of any mutation on the table "policies"
"""
type policies_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [policies!]!
}

"""
on_conflict condition type for table "policies"
"""
input policies_on_conflict {
  constraint: policies_constraint!
  update_columns: [policies_update_column!]! = []
  where: policies_bool_exp
}

"""Ordering options when selecting data from "policies"."""
input policies_order_by {
  active: order_by
  createdAt: order_by
  createdBy: order_by
  id: order_by
  organization: order_by
  rule: rules_order_by
  ruleId: order_by
  subjectDisplayName: order_by
  subjectId: order_by
  subjectSecondaryId: order_by
  subjectType: order_by
  updatedAt: order_by
  updatedBy: order_by
  validFrom: order_by
  validTo: order_by
  weight: order_by
}

"""primary key columns input for table: policies"""
input policies_pk_columns_input {
  id: uuid!
}

"""
select columns of table "policies"
"""
enum policies_select_column {
  """column name"""
  active

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  id

  """column name"""
  organization

  """column name"""
  ruleId

  """column name"""
  subjectDisplayName

  """column name"""
  subjectId

  """column name"""
  subjectSecondaryId

  """column name"""
  subjectType

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  validFrom

  """column name"""
  validTo

  """column name"""
  weight
}

"""
input type for updating data in table "policies"
"""
input policies_set_input {
  active: Boolean
  deletedAt: timestamptz
  validFrom: timestamptz
  validTo: timestamptz
  weight: smallint
}

"""
Streaming cursor of the table "policies"
"""
input policies_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: policies_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input policies_stream_cursor_value_input {
  active: Boolean
  createdAt: timestamptz
  createdBy: String
  id: uuid
  organization: String
  ruleId: uuid
  subjectDisplayName: String
  subjectId: uuid
  subjectSecondaryId: String
  subjectType: subject_type_enum
  updatedAt: timestamptz
  updatedBy: String
  validFrom: timestamptz
  validTo: timestamptz
  weight: smallint
}

"""
update columns of table "policies"
"""
enum policies_update_column {
  """column name"""
  active

  """column name"""
  deletedAt

  """column name"""
  validFrom

  """column name"""
  validTo

  """column name"""
  weight
}

input policies_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: policies_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: policies_set_input

  """filter the rows which have to be updated"""
  where: policies_bool_exp!
}

"""Device pools"""
type pools {
  annotations: hstore
  createdAt: timestamptz!
  createdBy: String!
  description: String

  """An array relationship"""
  devices(
    """distinct select on columns"""
    distinct_on: [device_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pools_order_by!]

    """filter the rows returned"""
    where: device_pools_bool_exp
  ): [device_pools!]!

  """An aggregate relationship"""
  devices_aggregate(
    """distinct select on columns"""
    distinct_on: [device_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pools_order_by!]

    """filter the rows returned"""
    where: device_pools_bool_exp
  ): device_pools_aggregate!
  displayName: String!
  id: uuid!
  organization: String!
  tags: [String!]
  updatedAt: timestamptz!
  updatedBy: String!
}

"""
aggregated selection of "pools"
"""
type pools_aggregate {
  aggregate: pools_aggregate_fields
  nodes: [pools!]!
}

"""
aggregate fields of "pools"
"""
type pools_aggregate_fields {
  count(columns: [pools_select_column!], distinct: Boolean): Int!
  max: pools_max_fields
  min: pools_min_fields
}

"""
order by aggregate values of table "pools"
"""
input pools_aggregate_order_by {
  count: order_by
  max: pools_max_order_by
  min: pools_min_order_by
}

"""
Boolean expression to filter rows from the table "pools". All fields are combined with a logical 'AND'.
"""
input pools_bool_exp {
  _and: [pools_bool_exp!]
  _not: pools_bool_exp
  _or: [pools_bool_exp!]
  annotations: hstore_comparison_exp
  createdAt: timestamptz_comparison_exp
  createdBy: String_comparison_exp
  description: String_comparison_exp
  devices: device_pools_bool_exp
  devices_aggregate: device_pools_aggregate_bool_exp
  displayName: String_comparison_exp
  id: uuid_comparison_exp
  organization: String_comparison_exp
  tags: String_array_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: String_comparison_exp
}

"""
unique or primary key constraints on table "pools"
"""
enum pools_constraint {
  """
  unique or primary key constraint on columns "display_name", "organization"
  """
  pools_display_name_organization_unique

  """
  unique or primary key constraint on columns "id"
  """
  pools_pkey
}

"""
input type for inserting data into table "pools"
"""
input pools_insert_input {
  annotations: hstore
  description: String
  devices: device_pools_arr_rel_insert_input
  displayName: String
  organization: String
  tags: [String!]
}

"""aggregate max on columns"""
type pools_max_fields {
  createdAt: timestamptz
  createdBy: String
  description: String
  displayName: String
  id: uuid
  organization: String
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: String
}

"""
order by max() on columns of table "pools"
"""
input pools_max_order_by {
  createdAt: order_by
  createdBy: order_by
  description: order_by
  displayName: order_by
  id: order_by
  organization: order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""aggregate min on columns"""
type pools_min_fields {
  createdAt: timestamptz
  createdBy: String
  description: String
  displayName: String
  id: uuid
  organization: String
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: String
}

"""
order by min() on columns of table "pools"
"""
input pools_min_order_by {
  createdAt: order_by
  createdBy: order_by
  description: order_by
  displayName: order_by
  id: order_by
  organization: order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""
response of any mutation on the table "pools"
"""
type pools_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [pools!]!
}

"""
input type for inserting object relation for remote table "pools"
"""
input pools_obj_rel_insert_input {
  data: pools_insert_input!

  """upsert condition"""
  on_conflict: pools_on_conflict
}

"""
on_conflict condition type for table "pools"
"""
input pools_on_conflict {
  constraint: pools_constraint!
  update_columns: [pools_update_column!]! = []
  where: pools_bool_exp
}

"""Ordering options when selecting data from "pools"."""
input pools_order_by {
  annotations: order_by
  createdAt: order_by
  createdBy: order_by
  description: order_by
  devices_aggregate: device_pools_aggregate_order_by
  displayName: order_by
  id: order_by
  organization: order_by
  tags: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""primary key columns input for table: pools"""
input pools_pk_columns_input {
  id: uuid!
}

"""
select columns of table "pools"
"""
enum pools_select_column {
  """column name"""
  annotations

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  organization

  """column name"""
  tags

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

"""
input type for updating data in table "pools"
"""
input pools_set_input {
  annotations: hstore
  deletedAt: timestamptz
  description: String
  displayName: String
  tags: [String!]
}

"""
Streaming cursor of the table "pools"
"""
input pools_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: pools_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input pools_stream_cursor_value_input {
  annotations: hstore
  createdAt: timestamptz
  createdBy: String
  description: String
  displayName: String
  id: uuid
  organization: String
  tags: [String!]
  updatedAt: timestamptz
  updatedBy: String
}

"""
update columns of table "pools"
"""
enum pools_update_column {
  """column name"""
  annotations

  """column name"""
  deletedAt

  """column name"""
  description

  """column name"""
  displayName

  """column name"""
  tags
}

input pools_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: pools_set_input

  """filter the rows which have to be updated"""
  where: pools_bool_exp!
}

"""network protocol enum"""
type protocol {
  description: String!
  value: String!
}

"""
aggregated selection of "protocol"
"""
type protocol_aggregate {
  aggregate: protocol_aggregate_fields
  nodes: [protocol!]!
}

"""
aggregate fields of "protocol"
"""
type protocol_aggregate_fields {
  count(columns: [protocol_select_column!], distinct: Boolean): Int!
  max: protocol_max_fields
  min: protocol_min_fields
}

"""
Boolean expression to filter rows from the table "protocol". All fields are combined with a logical 'AND'.
"""
input protocol_bool_exp {
  _and: [protocol_bool_exp!]
  _not: protocol_bool_exp
  _or: [protocol_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

enum protocol_enum {
  """Any"""
  Any

  """ICMP"""
  ICMP

  """ICMPV6"""
  ICMPV6

  """IGMP"""
  IGMP

  """IP"""
  IP

  """IPV6"""
  IPV6

  """RM"""
  RM

  """TCP"""
  TCP

  """UDP"""
  UDP
}

"""
Boolean expression to compare columns of type "protocol_enum". All fields are combined with logical 'AND'.
"""
input protocol_enum_comparison_exp {
  _eq: protocol_enum
  _in: [protocol_enum!]
  _is_null: Boolean
  _neq: protocol_enum
  _nin: [protocol_enum!]
}

"""aggregate max on columns"""
type protocol_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type protocol_min_fields {
  description: String
  value: String
}

"""Ordering options when selecting data from "protocol"."""
input protocol_order_by {
  description: order_by
  value: order_by
}

"""
select columns of table "protocol"
"""
enum protocol_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
Streaming cursor of the table "protocol"
"""
input protocol_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: protocol_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input protocol_stream_cursor_value_input {
  description: String
  value: String
}

type query_root {
  """Universities API"""
  ListUniversities(arg1: ListUniversitiesInput!): [ListUniversitiesOutput]

  """Restrooms API"""
  SearchRestrooms(arg1: SearchRestroomsInput!): [SearchRestroomsOutput]

  """
  fetch data from the table: "action"
  """
  action(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """
  fetch aggregated fields from the table: "action"
  """
  action_aggregate(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): action_aggregate!

  """fetch data from the table: "action" using primary key columns"""
  action_by_pk(value: String!): action

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  authRefreshToken(id: uuid!): authRefreshTokens

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  authRefreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """
  fetch data from the table: "auth.user_providers" using primary key columns
  """
  authUserProvider(id: uuid!): authUserProviders

  """
  fetch data from the table: "auth.user_providers"
  """
  authUserProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """fetch data from the table: "auth.user_roles" using primary key columns"""
  authUserRole(id: uuid!): authUserRoles

  """
  fetch data from the table: "auth.user_roles"
  """
  authUserRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch aggregated fields from the table: "auth.user_roles"
  """
  authUserRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """
  fetch data from the table: "auth.user_security_keys" using primary key columns
  """
  authUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  fetch data from the table: "auth.user_security_keys"
  """
  authUserSecurityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """
  fetch data from the table: "device_pools"
  """
  device_pools(
    """distinct select on columns"""
    distinct_on: [device_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pools_order_by!]

    """filter the rows returned"""
    where: device_pools_bool_exp
  ): [device_pools!]!

  """
  fetch aggregated fields from the table: "device_pools"
  """
  device_pools_aggregate(
    """distinct select on columns"""
    distinct_on: [device_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pools_order_by!]

    """filter the rows returned"""
    where: device_pools_bool_exp
  ): device_pools_aggregate!

  """fetch data from the table: "device_pools" using primary key columns"""
  device_pools_by_pk(id: uuid!): device_pools

  """
  fetch data from the table: "devices"
  """
  devices(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """
  fetch aggregated fields from the table: "devices"
  """
  devices_aggregate(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): devices_aggregate!

  """fetch data from the table: "devices" using primary key columns"""
  devices_by_pk(id: uuid!): devices

  """
  fetch data from the table: "direction"
  """
  direction(
    """distinct select on columns"""
    distinct_on: [direction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [direction_order_by!]

    """filter the rows returned"""
    where: direction_bool_exp
  ): [direction!]!

  """
  fetch aggregated fields from the table: "direction"
  """
  direction_aggregate(
    """distinct select on columns"""
    distinct_on: [direction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [direction_order_by!]

    """filter the rows returned"""
    where: direction_bool_exp
  ): direction_aggregate!

  """fetch data from the table: "direction" using primary key columns"""
  direction_by_pk(value: String!): direction

  """fetch data from the table: "storage.files" using primary key columns"""
  file(id: uuid!): files

  """
  fetch data from the table: "storage.files"
  """
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch data from the table: "groups"
  """
  groups(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]!

  """fetch data from the table: "groups" using primary key columns"""
  groups_by_pk(id: uuid!): groups

  """
  fetch data from the table: "organizations"
  """
  organizations(
    """distinct select on columns"""
    distinct_on: [organizations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organizations_order_by!]

    """filter the rows returned"""
    where: organizations_bool_exp
  ): [organizations!]!

  """fetch data from the table: "organizations" using primary key columns"""
  organizations_by_pk(organization: String!): organizations

  """
  fetch data from the table: "policies"
  """
  policies(
    """distinct select on columns"""
    distinct_on: [policies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [policies_order_by!]

    """filter the rows returned"""
    where: policies_bool_exp
  ): [policies!]!

  """fetch data from the table: "policies" using primary key columns"""
  policies_by_pk(id: uuid!): policies

  """
  fetch data from the table: "pools"
  """
  pools(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]!

  """
  fetch aggregated fields from the table: "pools"
  """
  pools_aggregate(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): pools_aggregate!

  """fetch data from the table: "pools" using primary key columns"""
  pools_by_pk(id: uuid!): pools

  """
  fetch data from the table: "protocol"
  """
  protocol(
    """distinct select on columns"""
    distinct_on: [protocol_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [protocol_order_by!]

    """filter the rows returned"""
    where: protocol_bool_exp
  ): [protocol!]!

  """
  fetch aggregated fields from the table: "protocol"
  """
  protocol_aggregate(
    """distinct select on columns"""
    distinct_on: [protocol_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [protocol_order_by!]

    """filter the rows returned"""
    where: protocol_bool_exp
  ): protocol_aggregate!

  """fetch data from the table: "protocol" using primary key columns"""
  protocol_by_pk(value: String!): protocol

  """
  fetch data from the table: "rules"
  """
  rules(
    """distinct select on columns"""
    distinct_on: [rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rules_order_by!]

    """filter the rows returned"""
    where: rules_bool_exp
  ): [rules!]!

  """fetch data from the table: "rules" using primary key columns"""
  rules_by_pk(id: uuid!): rules

  """
  fetch data from the table: "subject_type"
  """
  subject_type(
    """distinct select on columns"""
    distinct_on: [subject_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subject_type_order_by!]

    """filter the rows returned"""
    where: subject_type_bool_exp
  ): [subject_type!]!

  """fetch data from the table: "subject_type" using primary key columns"""
  subject_type_by_pk(value: String!): subject_type

  """fetch data from the table: "auth.users" using primary key columns"""
  user(id: uuid!): users

  """
  fetch data from the table: "user_groups"
  """
  user_groups(
    """distinct select on columns"""
    distinct_on: [user_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_groups_order_by!]

    """filter the rows returned"""
    where: user_groups_bool_exp
  ): [user_groups!]!

  """fetch data from the table: "user_groups" using primary key columns"""
  user_groups_by_pk(groupId: uuid!, userId: uuid!): user_groups

  """
  fetch data from the table: "user_org_roles"
  """
  user_org_roles(
    """distinct select on columns"""
    distinct_on: [user_org_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_org_roles_order_by!]

    """filter the rows returned"""
    where: user_org_roles_bool_exp
  ): [user_org_roles!]!

  """
  fetch aggregated fields from the table: "user_org_roles"
  """
  user_org_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [user_org_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_org_roles_order_by!]

    """filter the rows returned"""
    where: user_org_roles_bool_exp
  ): user_org_roles_aggregate!

  """fetch data from the table: "user_org_roles" using primary key columns"""
  user_org_roles_by_pk(id: uuid!): user_org_roles

  """
  fetch data from the table: "auth.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!
}

"""5-tuple firewalls rules"""
type rules {
  action: action_enum!
  annotations: hstore
  appId: String
  createdAt: timestamptz!
  createdBy: String!
  description: String
  destination: String
  destinationPort: String
  direction: direction_enum!
  displayName: String!
  id: uuid!
  organization: String!
  protocol: protocol_enum!
  shared: Boolean!
  source: String
  sourcePort: String
  tags: [String!]
  throttleRate: String
  updatedAt: timestamptz!
  updatedBy: String!
  weight: smallint!
}

"""
Boolean expression to filter rows from the table "rules". All fields are combined with a logical 'AND'.
"""
input rules_bool_exp {
  _and: [rules_bool_exp!]
  _not: rules_bool_exp
  _or: [rules_bool_exp!]
  action: action_enum_comparison_exp
  annotations: hstore_comparison_exp
  appId: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  createdBy: String_comparison_exp
  description: String_comparison_exp
  destination: String_comparison_exp
  destinationPort: String_comparison_exp
  direction: direction_enum_comparison_exp
  displayName: String_comparison_exp
  id: uuid_comparison_exp
  organization: String_comparison_exp
  protocol: protocol_enum_comparison_exp
  shared: Boolean_comparison_exp
  source: String_comparison_exp
  sourcePort: String_comparison_exp
  tags: String_array_comparison_exp
  throttleRate: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: String_comparison_exp
  weight: smallint_comparison_exp
}

"""
unique or primary key constraints on table "rules"
"""
enum rules_constraint {
  """
  unique or primary key constraint on columns "display_name", "organization"
  """
  rules_display_name_organization_unique

  """
  unique or primary key constraint on columns "id"
  """
  rules_pkey
}

"""
input type for incrementing numeric columns in table "rules"
"""
input rules_inc_input {
  weight: smallint
}

"""
input type for inserting data into table "rules"
"""
input rules_insert_input {
  action: action_enum
  annotations: hstore
  appId: String
  description: String
  destination: String
  destinationPort: String
  direction: direction_enum
  displayName: String
  organization: String
  protocol: protocol_enum
  shared: Boolean
  source: String
  sourcePort: String
  tags: [String!]
  throttleRate: String
  weight: smallint
}

"""
response of any mutation on the table "rules"
"""
type rules_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rules!]!
}

"""
input type for inserting object relation for remote table "rules"
"""
input rules_obj_rel_insert_input {
  data: rules_insert_input!

  """upsert condition"""
  on_conflict: rules_on_conflict
}

"""
on_conflict condition type for table "rules"
"""
input rules_on_conflict {
  constraint: rules_constraint!
  update_columns: [rules_update_column!]! = []
  where: rules_bool_exp
}

"""Ordering options when selecting data from "rules"."""
input rules_order_by {
  action: order_by
  annotations: order_by
  appId: order_by
  createdAt: order_by
  createdBy: order_by
  description: order_by
  destination: order_by
  destinationPort: order_by
  direction: order_by
  displayName: order_by
  id: order_by
  organization: order_by
  protocol: order_by
  shared: order_by
  source: order_by
  sourcePort: order_by
  tags: order_by
  throttleRate: order_by
  updatedAt: order_by
  updatedBy: order_by
  weight: order_by
}

"""primary key columns input for table: rules"""
input rules_pk_columns_input {
  id: uuid!
}

"""
select columns of table "rules"
"""
enum rules_select_column {
  """column name"""
  action

  """column name"""
  annotations

  """column name"""
  appId

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  description

  """column name"""
  destination

  """column name"""
  destinationPort

  """column name"""
  direction

  """column name"""
  displayName

  """column name"""
  id

  """column name"""
  organization

  """column name"""
  protocol

  """column name"""
  shared

  """column name"""
  source

  """column name"""
  sourcePort

  """column name"""
  tags

  """column name"""
  throttleRate

  """column name"""
  updatedAt

  """column name"""
  updatedBy

  """column name"""
  weight
}

"""
input type for updating data in table "rules"
"""
input rules_set_input {
  action: action_enum
  annotations: hstore
  appId: String
  deletedAt: timestamptz
  description: String
  destination: String
  destinationPort: String
  direction: direction_enum
  displayName: String
  organization: String
  protocol: protocol_enum
  shared: Boolean
  source: String
  sourcePort: String
  tags: [String!]
  throttleRate: String
  weight: smallint
}

"""
Streaming cursor of the table "rules"
"""
input rules_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rules_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rules_stream_cursor_value_input {
  action: action_enum
  annotations: hstore
  appId: String
  createdAt: timestamptz
  createdBy: String
  description: String
  destination: String
  destinationPort: String
  direction: direction_enum
  displayName: String
  id: uuid
  organization: String
  protocol: protocol_enum
  shared: Boolean
  source: String
  sourcePort: String
  tags: [String!]
  throttleRate: String
  updatedAt: timestamptz
  updatedBy: String
  weight: smallint
}

"""
update columns of table "rules"
"""
enum rules_update_column {
  """column name"""
  action

  """column name"""
  annotations

  """column name"""
  appId

  """column name"""
  deletedAt

  """column name"""
  description

  """column name"""
  destination

  """column name"""
  destinationPort

  """column name"""
  direction

  """column name"""
  displayName

  """column name"""
  organization

  """column name"""
  protocol

  """column name"""
  shared

  """column name"""
  source

  """column name"""
  sourcePort

  """column name"""
  tags

  """column name"""
  throttleRate

  """column name"""
  weight
}

input rules_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: rules_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: rules_set_input

  """filter the rows which have to be updated"""
  where: rules_bool_exp!
}

scalar smallint

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

"""subject enum"""
type subject_type {
  description: String!
  value: String!
}

"""
Boolean expression to filter rows from the table "subject_type". All fields are combined with a logical 'AND'.
"""
input subject_type_bool_exp {
  _and: [subject_type_bool_exp!]
  _not: subject_type_bool_exp
  _or: [subject_type_bool_exp!]
  description: String_comparison_exp
  value: String_comparison_exp
}

enum subject_type_enum {
  """DEVICE"""
  device

  """DEVICE_POOL"""
  device_pool

  """GROUP"""
  group

  """SERVICE_ACCOUNT"""
  service_account

  """USER"""
  user
}

"""
Boolean expression to compare columns of type "subject_type_enum". All fields are combined with logical 'AND'.
"""
input subject_type_enum_comparison_exp {
  _eq: subject_type_enum
  _in: [subject_type_enum!]
  _is_null: Boolean
  _neq: subject_type_enum
  _nin: [subject_type_enum!]
}

"""Ordering options when selecting data from "subject_type"."""
input subject_type_order_by {
  description: order_by
  value: order_by
}

"""
select columns of table "subject_type"
"""
enum subject_type_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
Streaming cursor of the table "subject_type"
"""
input subject_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: subject_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input subject_type_stream_cursor_value_input {
  description: String
  value: String
}

type subscription_root {
  """
  fetch data from the table: "action"
  """
  action(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """
  fetch aggregated fields from the table: "action"
  """
  action_aggregate(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): action_aggregate!

  """fetch data from the table: "action" using primary key columns"""
  action_by_pk(value: String!): action

  """
  fetch data from the table in a streaming manner: "action"
  """
  action_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [action_stream_cursor_input]!

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  authRefreshToken(id: uuid!): authRefreshTokens

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  authRefreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """
  fetch data from the table in a streaming manner: "auth.refresh_tokens"
  """
  authRefreshTokens_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authRefreshTokens_stream_cursor_input]!

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """
  fetch data from the table: "auth.user_providers" using primary key columns
  """
  authUserProvider(id: uuid!): authUserProviders

  """
  fetch data from the table: "auth.user_providers"
  """
  authUserProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """
  fetch data from the table in a streaming manner: "auth.user_providers"
  """
  authUserProviders_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserProviders_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """fetch data from the table: "auth.user_roles" using primary key columns"""
  authUserRole(id: uuid!): authUserRoles

  """
  fetch data from the table: "auth.user_roles"
  """
  authUserRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch aggregated fields from the table: "auth.user_roles"
  """
  authUserRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.user_roles"
  """
  authUserRoles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserRoles_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch data from the table: "auth.user_security_keys" using primary key columns
  """
  authUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  fetch data from the table: "auth.user_security_keys"
  """
  authUserSecurityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """
  fetch data from the table in a streaming manner: "auth.user_security_keys"
  """
  authUserSecurityKeys_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserSecurityKeys_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """
  fetch data from the table: "device_pools"
  """
  device_pools(
    """distinct select on columns"""
    distinct_on: [device_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pools_order_by!]

    """filter the rows returned"""
    where: device_pools_bool_exp
  ): [device_pools!]!

  """
  fetch aggregated fields from the table: "device_pools"
  """
  device_pools_aggregate(
    """distinct select on columns"""
    distinct_on: [device_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [device_pools_order_by!]

    """filter the rows returned"""
    where: device_pools_bool_exp
  ): device_pools_aggregate!

  """fetch data from the table: "device_pools" using primary key columns"""
  device_pools_by_pk(id: uuid!): device_pools

  """
  fetch data from the table in a streaming manner: "device_pools"
  """
  device_pools_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [device_pools_stream_cursor_input]!

    """filter the rows returned"""
    where: device_pools_bool_exp
  ): [device_pools!]!

  """
  fetch data from the table: "devices"
  """
  devices(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """
  fetch aggregated fields from the table: "devices"
  """
  devices_aggregate(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): devices_aggregate!

  """fetch data from the table: "devices" using primary key columns"""
  devices_by_pk(id: uuid!): devices

  """
  fetch data from the table in a streaming manner: "devices"
  """
  devices_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [devices_stream_cursor_input]!

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """
  fetch data from the table: "direction"
  """
  direction(
    """distinct select on columns"""
    distinct_on: [direction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [direction_order_by!]

    """filter the rows returned"""
    where: direction_bool_exp
  ): [direction!]!

  """
  fetch aggregated fields from the table: "direction"
  """
  direction_aggregate(
    """distinct select on columns"""
    distinct_on: [direction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [direction_order_by!]

    """filter the rows returned"""
    where: direction_bool_exp
  ): direction_aggregate!

  """fetch data from the table: "direction" using primary key columns"""
  direction_by_pk(value: String!): direction

  """
  fetch data from the table in a streaming manner: "direction"
  """
  direction_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [direction_stream_cursor_input]!

    """filter the rows returned"""
    where: direction_bool_exp
  ): [direction!]!

  """fetch data from the table: "storage.files" using primary key columns"""
  file(id: uuid!): files

  """
  fetch data from the table: "storage.files"
  """
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch data from the table in a streaming manner: "storage.files"
  """
  files_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [files_stream_cursor_input]!

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch data from the table: "groups"
  """
  groups(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]!

  """fetch data from the table: "groups" using primary key columns"""
  groups_by_pk(id: uuid!): groups

  """
  fetch data from the table in a streaming manner: "groups"
  """
  groups_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [groups_stream_cursor_input]!

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]!

  """
  fetch data from the table: "organizations"
  """
  organizations(
    """distinct select on columns"""
    distinct_on: [organizations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organizations_order_by!]

    """filter the rows returned"""
    where: organizations_bool_exp
  ): [organizations!]!

  """fetch data from the table: "organizations" using primary key columns"""
  organizations_by_pk(organization: String!): organizations

  """
  fetch data from the table in a streaming manner: "organizations"
  """
  organizations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [organizations_stream_cursor_input]!

    """filter the rows returned"""
    where: organizations_bool_exp
  ): [organizations!]!

  """
  fetch data from the table: "policies"
  """
  policies(
    """distinct select on columns"""
    distinct_on: [policies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [policies_order_by!]

    """filter the rows returned"""
    where: policies_bool_exp
  ): [policies!]!

  """fetch data from the table: "policies" using primary key columns"""
  policies_by_pk(id: uuid!): policies

  """
  fetch data from the table in a streaming manner: "policies"
  """
  policies_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [policies_stream_cursor_input]!

    """filter the rows returned"""
    where: policies_bool_exp
  ): [policies!]!

  """
  fetch data from the table: "pools"
  """
  pools(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]!

  """
  fetch aggregated fields from the table: "pools"
  """
  pools_aggregate(
    """distinct select on columns"""
    distinct_on: [pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pools_order_by!]

    """filter the rows returned"""
    where: pools_bool_exp
  ): pools_aggregate!

  """fetch data from the table: "pools" using primary key columns"""
  pools_by_pk(id: uuid!): pools

  """
  fetch data from the table in a streaming manner: "pools"
  """
  pools_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [pools_stream_cursor_input]!

    """filter the rows returned"""
    where: pools_bool_exp
  ): [pools!]!

  """
  fetch data from the table: "protocol"
  """
  protocol(
    """distinct select on columns"""
    distinct_on: [protocol_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [protocol_order_by!]

    """filter the rows returned"""
    where: protocol_bool_exp
  ): [protocol!]!

  """
  fetch aggregated fields from the table: "protocol"
  """
  protocol_aggregate(
    """distinct select on columns"""
    distinct_on: [protocol_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [protocol_order_by!]

    """filter the rows returned"""
    where: protocol_bool_exp
  ): protocol_aggregate!

  """fetch data from the table: "protocol" using primary key columns"""
  protocol_by_pk(value: String!): protocol

  """
  fetch data from the table in a streaming manner: "protocol"
  """
  protocol_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [protocol_stream_cursor_input]!

    """filter the rows returned"""
    where: protocol_bool_exp
  ): [protocol!]!

  """
  fetch data from the table: "rules"
  """
  rules(
    """distinct select on columns"""
    distinct_on: [rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rules_order_by!]

    """filter the rows returned"""
    where: rules_bool_exp
  ): [rules!]!

  """fetch data from the table: "rules" using primary key columns"""
  rules_by_pk(id: uuid!): rules

  """
  fetch data from the table in a streaming manner: "rules"
  """
  rules_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rules_stream_cursor_input]!

    """filter the rows returned"""
    where: rules_bool_exp
  ): [rules!]!

  """
  fetch data from the table: "subject_type"
  """
  subject_type(
    """distinct select on columns"""
    distinct_on: [subject_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subject_type_order_by!]

    """filter the rows returned"""
    where: subject_type_bool_exp
  ): [subject_type!]!

  """fetch data from the table: "subject_type" using primary key columns"""
  subject_type_by_pk(value: String!): subject_type

  """
  fetch data from the table in a streaming manner: "subject_type"
  """
  subject_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [subject_type_stream_cursor_input]!

    """filter the rows returned"""
    where: subject_type_bool_exp
  ): [subject_type!]!

  """fetch data from the table: "auth.users" using primary key columns"""
  user(id: uuid!): users

  """
  fetch data from the table: "user_groups"
  """
  user_groups(
    """distinct select on columns"""
    distinct_on: [user_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_groups_order_by!]

    """filter the rows returned"""
    where: user_groups_bool_exp
  ): [user_groups!]!

  """fetch data from the table: "user_groups" using primary key columns"""
  user_groups_by_pk(groupId: uuid!, userId: uuid!): user_groups

  """
  fetch data from the table in a streaming manner: "user_groups"
  """
  user_groups_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_groups_stream_cursor_input]!

    """filter the rows returned"""
    where: user_groups_bool_exp
  ): [user_groups!]!

  """
  fetch data from the table: "user_org_roles"
  """
  user_org_roles(
    """distinct select on columns"""
    distinct_on: [user_org_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_org_roles_order_by!]

    """filter the rows returned"""
    where: user_org_roles_bool_exp
  ): [user_org_roles!]!

  """
  fetch aggregated fields from the table: "user_org_roles"
  """
  user_org_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [user_org_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_org_roles_order_by!]

    """filter the rows returned"""
    where: user_org_roles_bool_exp
  ): user_org_roles_aggregate!

  """fetch data from the table: "user_org_roles" using primary key columns"""
  user_org_roles_by_pk(id: uuid!): user_org_roles

  """
  fetch data from the table in a streaming manner: "user_org_roles"
  """
  user_org_roles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_org_roles_stream_cursor_input]!

    """filter the rows returned"""
    where: user_org_roles_bool_exp
  ): [user_org_roles!]!

  """
  fetch data from the table: "auth.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch data from the table in a streaming manner: "auth.users"
  """
  users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [users_stream_cursor_input]!

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""User to Group association table"""
type user_groups {
  createdAt: timestamptz!

  """An object relationship"""
  group: groups!
  groupId: uuid!
  id: uuid!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
order by aggregate values of table "user_groups"
"""
input user_groups_aggregate_order_by {
  count: order_by
  max: user_groups_max_order_by
  min: user_groups_min_order_by
}

"""
input type for inserting array relation for remote table "user_groups"
"""
input user_groups_arr_rel_insert_input {
  data: [user_groups_insert_input!]!

  """upsert condition"""
  on_conflict: user_groups_on_conflict
}

"""
Boolean expression to filter rows from the table "user_groups". All fields are combined with a logical 'AND'.
"""
input user_groups_bool_exp {
  _and: [user_groups_bool_exp!]
  _not: user_groups_bool_exp
  _or: [user_groups_bool_exp!]
  createdAt: timestamptz_comparison_exp
  group: groups_bool_exp
  groupId: uuid_comparison_exp
  id: uuid_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_groups"
"""
enum user_groups_constraint {
  """
  unique or primary key constraint on columns "user_id", "group_id"
  """
  user_groups_pkey
}

"""
input type for inserting data into table "user_groups"
"""
input user_groups_insert_input {
  group: groups_obj_rel_insert_input
  groupId: uuid
  userId: uuid
}

"""
order by max() on columns of table "user_groups"
"""
input user_groups_max_order_by {
  createdAt: order_by
  groupId: order_by
  id: order_by
  userId: order_by
}

"""
order by min() on columns of table "user_groups"
"""
input user_groups_min_order_by {
  createdAt: order_by
  groupId: order_by
  id: order_by
  userId: order_by
}

"""
response of any mutation on the table "user_groups"
"""
type user_groups_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_groups!]!
}

"""
on_conflict condition type for table "user_groups"
"""
input user_groups_on_conflict {
  constraint: user_groups_constraint!
  update_columns: [user_groups_update_column!]! = []
  where: user_groups_bool_exp
}

"""Ordering options when selecting data from "user_groups"."""
input user_groups_order_by {
  createdAt: order_by
  group: groups_order_by
  groupId: order_by
  id: order_by
  user: users_order_by
  userId: order_by
}

"""
select columns of table "user_groups"
"""
enum user_groups_select_column {
  """column name"""
  createdAt

  """column name"""
  groupId

  """column name"""
  id

  """column name"""
  userId
}

"""
Streaming cursor of the table "user_groups"
"""
input user_groups_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_groups_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_groups_stream_cursor_value_input {
  createdAt: timestamptz
  groupId: uuid
  id: uuid
  userId: uuid
}

"""
placeholder for update columns of table "user_groups" (current role has no relevant permissions)
"""
enum user_groups_update_column {
  """placeholder (do not use)"""
  _PLACEHOLDER
}

"""Roles of User for a given Org."""
type user_org_roles {
  createdAt: timestamptz!
  createdBy: uuid!
  id: uuid!
  isDefaultRole: Boolean!
  organization: String!
  role: String!
  userId: uuid!
}

"""
aggregated selection of "user_org_roles"
"""
type user_org_roles_aggregate {
  aggregate: user_org_roles_aggregate_fields
  nodes: [user_org_roles!]!
}

input user_org_roles_aggregate_bool_exp {
  bool_and: user_org_roles_aggregate_bool_exp_bool_and
  bool_or: user_org_roles_aggregate_bool_exp_bool_or
  count: user_org_roles_aggregate_bool_exp_count
}

input user_org_roles_aggregate_bool_exp_bool_and {
  arguments: user_org_roles_select_column_user_org_roles_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: user_org_roles_bool_exp
  predicate: Boolean_comparison_exp!
}

input user_org_roles_aggregate_bool_exp_bool_or {
  arguments: user_org_roles_select_column_user_org_roles_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: user_org_roles_bool_exp
  predicate: Boolean_comparison_exp!
}

input user_org_roles_aggregate_bool_exp_count {
  arguments: [user_org_roles_select_column!]
  distinct: Boolean
  filter: user_org_roles_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_org_roles"
"""
type user_org_roles_aggregate_fields {
  count(columns: [user_org_roles_select_column!], distinct: Boolean): Int!
  max: user_org_roles_max_fields
  min: user_org_roles_min_fields
}

"""
order by aggregate values of table "user_org_roles"
"""
input user_org_roles_aggregate_order_by {
  count: order_by
  max: user_org_roles_max_order_by
  min: user_org_roles_min_order_by
}

"""
Boolean expression to filter rows from the table "user_org_roles". All fields are combined with a logical 'AND'.
"""
input user_org_roles_bool_exp {
  _and: [user_org_roles_bool_exp!]
  _not: user_org_roles_bool_exp
  _or: [user_org_roles_bool_exp!]
  createdAt: timestamptz_comparison_exp
  createdBy: uuid_comparison_exp
  id: uuid_comparison_exp
  isDefaultRole: Boolean_comparison_exp
  organization: String_comparison_exp
  role: String_comparison_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_org_roles"
"""
enum user_org_roles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_org_roles_pkey

  """
  unique or primary key constraint on columns "user_id", "organization"
  """
  user_org_roles_user_id_organization_default_role_unique

  """
  unique or primary key constraint on columns "user_id", "organization", "role"
  """
  user_org_roles_user_id_role_organization_key
}

"""
input type for inserting data into table "user_org_roles"
"""
input user_org_roles_insert_input {
  isDefaultRole: Boolean
  organization: String
  role: String
  userId: uuid
}

"""aggregate max on columns"""
type user_org_roles_max_fields {
  createdAt: timestamptz
  createdBy: uuid
  id: uuid
  organization: String
  role: String
  userId: uuid
}

"""
order by max() on columns of table "user_org_roles"
"""
input user_org_roles_max_order_by {
  createdAt: order_by
  createdBy: order_by
  id: order_by
  organization: order_by
  role: order_by
  userId: order_by
}

"""aggregate min on columns"""
type user_org_roles_min_fields {
  createdAt: timestamptz
  createdBy: uuid
  id: uuid
  organization: String
  role: String
  userId: uuid
}

"""
order by min() on columns of table "user_org_roles"
"""
input user_org_roles_min_order_by {
  createdAt: order_by
  createdBy: order_by
  id: order_by
  organization: order_by
  role: order_by
  userId: order_by
}

"""
response of any mutation on the table "user_org_roles"
"""
type user_org_roles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_org_roles!]!
}

"""
on_conflict condition type for table "user_org_roles"
"""
input user_org_roles_on_conflict {
  constraint: user_org_roles_constraint!
  update_columns: [user_org_roles_update_column!]! = []
  where: user_org_roles_bool_exp
}

"""Ordering options when selecting data from "user_org_roles"."""
input user_org_roles_order_by {
  createdAt: order_by
  createdBy: order_by
  id: order_by
  isDefaultRole: order_by
  organization: order_by
  role: order_by
  userId: order_by
}

"""primary key columns input for table: user_org_roles"""
input user_org_roles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user_org_roles"
"""
enum user_org_roles_select_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  id

  """column name"""
  isDefaultRole

  """column name"""
  organization

  """column name"""
  role

  """column name"""
  userId
}

"""
select "user_org_roles_aggregate_bool_exp_bool_and_arguments_columns" columns of table "user_org_roles"
"""
enum user_org_roles_select_column_user_org_roles_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  isDefaultRole
}

"""
select "user_org_roles_aggregate_bool_exp_bool_or_arguments_columns" columns of table "user_org_roles"
"""
enum user_org_roles_select_column_user_org_roles_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  isDefaultRole
}

"""
input type for updating data in table "user_org_roles"
"""
input user_org_roles_set_input {
  isDefaultRole: Boolean
}

"""
Streaming cursor of the table "user_org_roles"
"""
input user_org_roles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_org_roles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_org_roles_stream_cursor_value_input {
  createdAt: timestamptz
  createdBy: uuid
  id: uuid
  isDefaultRole: Boolean
  organization: String
  role: String
  userId: uuid
}

"""
update columns of table "user_org_roles"
"""
enum user_org_roles_update_column {
  """column name"""
  isDefaultRole
}

input user_org_roles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_org_roles_set_input

  """filter the rows which have to be updated"""
  where: user_org_roles_bool_exp!
}

"""
User account information. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type users {
  activeMfaType: String

  """
  A computed field, executes function "user_allowed_orgs"
  """
  allowedOrgs(
    """distinct select on columns"""
    distinct_on: [organizations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organizations_order_by!]

    """filter the rows returned"""
    where: organizations_bool_exp
  ): [organizations!]
  avatarUrl: String!
  createdAt: timestamptz!

  """
  A computed field, executes function "user_default_org"
  """
  defaultOrg: String
  defaultRole: String!
  disabled: Boolean!
  displayName: String!
  email: citext
  emailVerified: Boolean!
  id: uuid!
  isAnonymous: Boolean!
  lastSeen: timestamptz
  locale: String!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  phoneNumber: String
  phoneNumberVerified: Boolean!

  """An array relationship"""
  refreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """An aggregate relationship"""
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """An array relationship"""
  securityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!
  updatedAt: timestamptz!

  """An array relationship"""
  userOrgRoles(
    """distinct select on columns"""
    distinct_on: [user_org_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_org_roles_order_by!]

    """filter the rows returned"""
    where: user_org_roles_bool_exp
  ): [user_org_roles!]!

  """An aggregate relationship"""
  userOrgRoles_aggregate(
    """distinct select on columns"""
    distinct_on: [user_org_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_org_roles_order_by!]

    """filter the rows returned"""
    where: user_org_roles_bool_exp
  ): user_org_roles_aggregate!

  """An array relationship"""
  userProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input users_append_input {
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "auth.users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  activeMfaType: String_comparison_exp
  allowedOrgs: organizations_bool_exp
  avatarUrl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  defaultOrg: String_comparison_exp
  defaultRole: String_comparison_exp
  disabled: Boolean_comparison_exp
  displayName: String_comparison_exp
  email: citext_comparison_exp
  emailVerified: Boolean_comparison_exp
  id: uuid_comparison_exp
  isAnonymous: Boolean_comparison_exp
  lastSeen: timestamptz_comparison_exp
  locale: String_comparison_exp
  metadata: jsonb_comparison_exp
  phoneNumber: String_comparison_exp
  phoneNumberVerified: Boolean_comparison_exp
  refreshTokens: authRefreshTokens_bool_exp
  roles: authUserRoles_bool_exp
  roles_aggregate: authUserRoles_aggregate_bool_exp
  securityKeys: authUserSecurityKeys_bool_exp
  updatedAt: timestamptz_comparison_exp
  userOrgRoles: user_org_roles_bool_exp
  userOrgRoles_aggregate: user_org_roles_aggregate_bool_exp
  userProviders: authUserProviders_bool_exp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input users_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input users_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input users_delete_key_input {
  metadata: String
}

"""
response of any mutation on the table "auth.users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""Ordering options when selecting data from "auth.users"."""
input users_order_by {
  activeMfaType: order_by
  allowedOrgs_aggregate: organizations_aggregate_order_by
  avatarUrl: order_by
  createdAt: order_by
  defaultOrg: order_by
  defaultRole: order_by
  disabled: order_by
  displayName: order_by
  email: order_by
  emailVerified: order_by
  id: order_by
  isAnonymous: order_by
  lastSeen: order_by
  locale: order_by
  metadata: order_by
  phoneNumber: order_by
  phoneNumberVerified: order_by
  refreshTokens_aggregate: authRefreshTokens_aggregate_order_by
  roles_aggregate: authUserRoles_aggregate_order_by
  securityKeys_aggregate: authUserSecurityKeys_aggregate_order_by
  updatedAt: order_by
  userOrgRoles_aggregate: user_org_roles_aggregate_order_by
  userProviders_aggregate: authUserProviders_aggregate_order_by
}

"""primary key columns input for table: auth.users"""
input users_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input users_prepend_input {
  metadata: jsonb
}

"""
select columns of table "auth.users"
"""
enum users_select_column {
  """column name"""
  activeMfaType

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  defaultRole

  """column name"""
  disabled

  """column name"""
  displayName

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  isAnonymous

  """column name"""
  lastSeen

  """column name"""
  locale

  """column name"""
  metadata

  """column name"""
  phoneNumber

  """column name"""
  phoneNumberVerified

  """column name"""
  updatedAt
}

"""
input type for updating data in table "auth.users"
"""
input users_set_input {
  avatarUrl: String
  defaultRole: String
  disabled: Boolean
  displayName: String
  email: citext
  locale: String
  metadata: jsonb
  phoneNumber: String
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input users_stream_cursor_value_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  defaultRole: String
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  phoneNumber: String
  phoneNumberVerified: Boolean
  updatedAt: timestamptz
}

input users_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: users_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: users_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: users_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: users_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: users_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: users_set_input

  """filter the rows which have to be updated"""
  where: users_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}
